I"7˜<p>Considerring printing different types with this common idiom:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="no">showBool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="w">
</span><span class="no">showNat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="w">
</span><span class="no">showList</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="o">(</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="w">
</span><span class="no">showPair</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="o">(</span><span class="no">B</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">showListOfPairsOfNats</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">showList</span><span class="w"> </span><span class="o">(</span><span class="no">showPair</span><span class="w"> </span><span class="no">showNat</span><span class="w"> </span><span class="no">showNat</span><span class="o">)</span><span class="w">   </span><span class="c">(* LOL *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>The designers of Haskell addressed this clunkiness through <em>typeclasses</em>, a mechanism by which the typechecker is instructed to automatically construct ‚Äútype-driven‚Äù functions [Wadler and Blott 1989].</p>
</blockquote>

<p>Coq followed Haskell‚Äôs lead as well, but</p>

<blockquote>
  <p>because Coq‚Äôs type system is so much richer than that of Haskell, and because typeclasses in Coq are used to automatically construct not only programs but also proofs, Coq‚Äôs presentation of typeclasses is quite a bit less ‚Äútransparent‚Äù</p>
</blockquote>

<h2 id="basics">Basics</h2>

<h3 id="classes-and-instances">Classes and Instances</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">Class</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w">
  </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="w">
</span><span class="o">}.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">showBool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w">
  </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">b</span><span class="p">:</span><span class="no">bool</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="s2">"true"</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="s2">"false"</span><span class="w">
</span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Comparing with Haskell:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kr">class</span> <span class="kt">Show</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">string</span>

<span class="c1">--  you cannot override a `instance` so in reality you need a `newtype` wrapper to do this</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="n">b</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="s">"True"</span> <span class="kr">else</span> <span class="s">"Fasle"</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>The show function is sometimes said to be overloaded, since it can be applied to arguments of many types, with potentially radically different behavior depending on the type of its argument.</p>
</blockquote>

<p>Next, we can define functions that use the overloaded function show like this:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">showOne</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">
  
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">showOne</span><span class="w"> </span><span class="no">true</span><span class="o">).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">showOne</span><span class="w"> </span><span class="mi">42</span><span class="o">).</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">showTwo</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w">
           </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">B</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"First is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s2">" and second is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">b</span><span class="pi">.</span><span class="w">

</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">showTwo</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="mi">42</span><span class="o">).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">showTwo</span><span class="w"> </span><span class="no">Red</span><span class="w"> </span><span class="no">Green</span><span class="o">).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>The parameter <code class="language-plaintext highlighter-rouge">`{Show A}</code> is a <em>class constraint</em>, which states that the function showOne is expected to be applied only to types A that belong to the Show class.</p>
</blockquote>

<blockquote>
  <p>Concretely, this constraint should be thought of as an <em>extra parameter</em> to showOne supplying <em>evidence</em> that A is an instance of Show ‚Äî i.e., it is essentially just a show function for A, which is implicitly invoked by the expression show a.</p>
</blockquote>

<p>ËØªÊó∂ÁåúÊµãÔºàÂêéÊù•ÂèëÁé∞Êé•‰∏ãÊù•ÊúâÊõ¥Ê≠£Á°ÆÁöÑËß£ÈáäÔºâÔºö<code class="language-plaintext highlighter-rouge">show</code> Âú® name resolution Âà∞ <code class="language-plaintext highlighter-rouge">class Show</code> Êó∂Â∞±ÂèØ‰ª•Ê†πÊçÆÂÖ∂ÂèÇÊï∞ÁöÑ typeÔºàÊØîÂ¶Ç <code class="language-plaintext highlighter-rouge">T</code>Ôºâinfer Âá∫„ÄåÊàë‰ª¨ÈúÄË¶Å‰∏Ä‰∏™ <code class="language-plaintext highlighter-rouge">Show T</code> ÁöÑÂÆûÁé∞Ôºà<code class="language-plaintext highlighter-rouge">instance</code>ÔºåÂÖ∂ÂÆûÂ∞±ÊòØ‰∏™ tableÔºâ„ÄçÔºåÂú® Haskell/Rust ‰∏≠Ëøô‰∏™ table ‰ºöÂú® lower Âà∞ IR Êó∂Êâç made explicitÔºåËÄå Coq ËøôÈáåÁöÑËØ≠Ê≥ïÂ∞±Â∑≤ÁªèÂº∫Ë∞É‰∫ÜËøôÈáåÈúÄË¶Å implicitly-and-inferred <code class="language-plaintext highlighter-rouge">{}</code> ‰∏Ä‰∏™ tableÔºåËøô‰∏™ table ÁöÑÂêçÂ≠óÂÖ∂ÂÆû‰∏çÈáçË¶ÅÔºåÂè™Ë¶ÅÂÖ∂ type ÊòØË¢´ <code class="language-plaintext highlighter-rouge">A</code> parametrized ÁöÑ <code class="language-plaintext highlighter-rouge">Show</code> Â∞±Â•Ω‰∫ÜÔºåÁ±ª‰ºº ML ÁöÑ <code class="language-plaintext highlighter-rouge">functor</code> ÊàñËÄÖ Java ÁöÑ generic <code class="language-plaintext highlighter-rouge">interface</code>„ÄÇ</p>

<p>This is <em>Ad-hoc polymorphism</em>.</p>

<h4 id="missing-constraint">Missing Constraint</h4>

<p>What if we forget the class constrints:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="no">Error</span><span class="p">:</span><span class="w">
</span><span class="no">Unable</span><span class="w"> </span><span class="no">to</span><span class="w"> </span><span class="no">satisfy</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">following</span><span class="w"> </span><span class="no">constraints</span><span class="p">:</span><span class="w">
</span><span class="no">In</span><span class="w"> </span><span class="no">environment</span><span class="p">:</span><span class="w">
</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w">
</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w">

</span><span class="nv">?Show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Show A"</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="class-eq">Class <code class="language-plaintext highlighter-rouge">Eq</code></h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="k">Class</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">bool</span><span class="p">;</span><span class="w">
  </span><span class="o">}.</span><span class="w">

</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"x =? y"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">eqb</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="kp">at</span><span class="w"> </span><span class="no">level</span><span class="w"> </span><span class="mi">70</span><span class="o">).</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">eqBool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> 
       </span><span class="kr">match</span><span class="w"> </span><span class="no">b</span><span class="o">,</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kp">with</span><span class="w">
         </span><span class="o">|</span><span class="w"> </span><span class="no">true</span><span class="o">,</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="no">true</span><span class="w">
         </span><span class="o">|</span><span class="w"> </span><span class="no">true</span><span class="o">,</span><span class="w"> </span><span class="no">false</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="no">false</span><span class="w">
         </span><span class="o">|</span><span class="w"> </span><span class="no">false</span><span class="o">,</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="no">false</span><span class="w">
         </span><span class="o">|</span><span class="w"> </span><span class="no">false</span><span class="o">,</span><span class="w"> </span><span class="no">false</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="no">true</span><span class="w">
       </span><span class="kr">end</span><span class="w">
  </span><span class="o">}.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">eqNat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nn">Nat</span><span class="p">.</span><span class="no">eqb</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Why should we need to define a typeclass for boolean equality when <em>Coq‚Äôs propositional equality</em> (<code class="language-plaintext highlighter-rouge">x = y</code>) is completely generic? 
while it makes sense to <em>claim</em> that two values <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> are equal no matter what their type is, it is not possible to write a <em>decidable equality checker</em> for arbitrary types. In particular, equality at types like <code class="language-plaintext highlighter-rouge">nat ‚Üí nat</code> is undecidable.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">x = y</code> ËøîÂõû‰∏Ä‰∏™ÈúÄË¶ÅÂéªËØÅÁöÑ <code class="language-plaintext highlighter-rouge">Prop</code> (relational) ËÄåÈùû executable <code class="language-plaintext highlighter-rouge">Fixpoint</code> (functional)<br />
Âõ†‰∏∫ function ÁöÑ equality ÊúâÊó∂ÂÄô‰ºö undeciableÔºåÊâÄ‰ª•ÊâçÈúÄË¶ÅÂä† Functional Extensionality <code class="language-plaintext highlighter-rouge">Axiom</code>ÔºàËßÅ LF-06Ôºâ</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">Instance</span><span class="w"> </span><span class="no">eqBoolArrowBool</span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="o">(</span><span class="no">bool</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">f1</span><span class="w"> </span><span class="no">f2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
      </span><span class="o">(</span><span class="no">f1</span><span class="w"> </span><span class="no">true</span><span class="o">)</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="o">(</span><span class="no">f2</span><span class="w"> </span><span class="no">true</span><span class="o">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">(</span><span class="no">f1</span><span class="w"> </span><span class="no">false</span><span class="o">)</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="o">(</span><span class="no">f2</span><span class="w"> </span><span class="no">false</span><span class="o">)</span><span class="w"> 
  </span><span class="o">}.</span><span class="w">

</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">id</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">id</span><span class="o">).</span><span class="w">      </span><span class="c">(* ==&gt; true *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">negb</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">negb</span><span class="o">).</span><span class="w">  </span><span class="c">(* ==&gt; true *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">id</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">negb</span><span class="o">).</span><span class="w">    </span><span class="c">(* ==&gt; false *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>ËøôÈáåËøô‰∏™ <code class="language-plaintext highlighter-rouge">eqb</code> ÁöÑÂÆö‰πâ‰πüÊòØÂü∫‰∫é extensionality ÁöÑÂÆö‰πâÔºåÂ¶ÇÊûúËÄÉËôëÂà∞ effectsÔºàdivergence„ÄÅIOÔºâÊòØÂæàÂÆπÊòì break ÁöÑÔºàÁ±ª‰ºº parametricityÔºâ</p>

<h3 id="parameterized-instances-new-typeclasses-from-old">Parameterized Instances: New Typeclasses from Old</h3>

<p>Structural recursion</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">Instance</span><span class="w"> </span><span class="no">showPair</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">B</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">show</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
      </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="o">,</span><span class="no">b</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="kr">in</span><span class="w"> 
        </span><span class="s2">"("</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s2">","</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s2">")"</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">show</span><span class="w"> </span><span class="o">(</span><span class="no">true</span><span class="o">,</span><span class="mi">42</span><span class="o">)).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Structural equality</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">Instance</span><span class="w"> </span><span class="no">eqPair</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">B</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="no">p1</span><span class="w"> </span><span class="no">p2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
      </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">p1a</span><span class="o">,</span><span class="no">p1b</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p1</span><span class="w"> </span><span class="kr">in</span><span class="w">
      </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">p2a</span><span class="o">,</span><span class="no">p2b</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p2</span><span class="w"> </span><span class="kr">in</span><span class="w">
      </span><span class="no">andb</span><span class="w"> </span><span class="o">(</span><span class="no">p1a</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">p2a</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">p1b</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">p2b</span><span class="o">)</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Slightly more complicated example: typical list:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="c">(* the book didn't use any from ListNotation *)</span><span class="w">
</span><span class="k">Fixpoint</span><span class="w"> </span><span class="no">showListAux</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">s</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="s2">""</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">cons</span><span class="w"> </span><span class="no">h</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">h</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">cons</span><span class="w"> </span><span class="no">h</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="no">append</span><span class="w"> </span><span class="o">(</span><span class="no">append</span><span class="w"> </span><span class="o">(</span><span class="no">s</span><span class="w"> </span><span class="no">h</span><span class="o">)</span><span class="w"> </span><span class="s2">", "</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">showListAux</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">t</span><span class="o">)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span><span class="k">Instance</span><span class="w"> </span><span class="no">showList</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">show</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">append</span><span class="w"> </span><span class="s2">"["</span><span class="w"> </span><span class="o">(</span><span class="no">append</span><span class="w"> </span><span class="o">(</span><span class="no">showListAux</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">l</span><span class="o">)</span><span class="w"> </span><span class="s2">"]"</span><span class="o">)</span><span class="w">
  </span><span class="o">}.</span><span class="w">
  
</span><span class="c">(* I used them though *)</span><span class="w">
</span><span class="k">Fixpoint</span><span class="w"> </span><span class="no">eqListAux</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l1</span><span class="o">,</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="kp">with</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">nil</span><span class="o">,</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="o">(</span><span class="no">h1</span><span class="p">::</span><span class="no">t1</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">h2</span><span class="p">::</span><span class="no">t2</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">(</span><span class="no">h1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">h2</span><span class="o">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">(</span><span class="no">eqListAux</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="o">)</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="p">_</span><span class="o">,</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">eqList</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="o">(</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">eqListAux</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="class-hierarchies">Class Hierarchies</h3>

<blockquote>
  <p>we might want a typeclass <code class="language-plaintext highlighter-rouge">Ord</code> for ‚Äúordered types‚Äù that support both equality and a less-or-equal comparison operator.</p>
</blockquote>

<p>A bad way would be declare a new class with two func <code class="language-plaintext highlighter-rouge">eq</code> and <code class="language-plaintext highlighter-rouge">le</code>.</p>

<p>It‚Äôs better to establish dependencies between typeclasses, similar with OOP <code class="language-plaintext highlighter-rouge">class</code> inheritence and subtyping (but better!), this gave good code reuses.</p>

<blockquote>
  <p>We often want to organize typeclasses into hierarchies.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">Class</span><span class="w"> </span><span class="no">Ord</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">le</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">bool</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="no">Ord</span><span class="pi">.</span><span class="w"> </span><span class="c">(* ==&gt;
Ord
     : forall A : Type, Eq A -&gt; Type
*)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>class <code class="language-plaintext highlighter-rouge">Eq</code> is a ‚Äúsuper(type)class‚Äù of <code class="language-plaintext highlighter-rouge">Ord</code> (not to be confused with OOP superclass)</p>

<p>This is <em>Sub-typeclassing</em>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="k">Fixpoint</span><span class="w"> </span><span class="no">listOrdAux</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Ord</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l1</span><span class="o">,</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[],</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="p">_</span><span class="o">,</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">h1</span><span class="p">::</span><span class="no">t1</span><span class="o">,</span><span class="w"> </span><span class="no">h2</span><span class="p">::</span><span class="no">t2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="no">h1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">h2</span><span class="o">)</span><span class="w">
                     </span><span class="kr">then</span><span class="w"> </span><span class="o">(</span><span class="no">listOrdAux</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="o">)</span><span class="w">
                     </span><span class="kr">else</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="no">h1</span><span class="w"> </span><span class="no">h2</span><span class="o">)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">listOrd</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Ord</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Ord</span><span class="w"> </span><span class="o">(</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">le</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">listOrdAux</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w">
  </span><span class="o">}.</span><span class="w">

</span><span class="c">(* truthy *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">]).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">2</span><span class="o">]).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">]).</span><span class="w">

</span><span class="c">(* falsy *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">]).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="o">]).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="how-it-works">How It works</h2>

<h3 id="implicit-generalization">Implicit Generalization</h3>

<p>ÊâÄ‰ª• <code class="language-plaintext highlighter-rouge">`{...}</code> Ëøô‰∏™ ‚Äúbacktick‚Äù notation is called <em>implicit generalization</em>ÔºåÊØî implicit <code class="language-plaintext highlighter-rouge">{}</code> Â§öÂÅö‰∫Ü‰∏Ä‰ª∂Ëá™Âä® generalize Ê≥õÂåñ free varabile ÁöÑ‰∫ãÊÉÖ„ÄÇ</p>

<blockquote>
  <p>that was added to Coq to support typeclasses but that can also be used to good effect elsewhere.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">showOne1</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">

</span><span class="k">Print</span><span class="w"> </span><span class="no">showOne1</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ==&gt;
    showOne1 = 
      fun (A : Type) (H : Show A) (a : A) =&gt; "The value is " ++ show a
           : forall A : Type, Show A -&gt; A -&gt; string

    Arguments A, H are implicit and maximally inserted
*)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>notice that the occurrence of <code class="language-plaintext highlighter-rouge">A</code> inside the <code class="language-plaintext highlighter-rouge">`{...}</code> is unbound and automatically insert the binding that we wrote explicitly before.</p>
</blockquote>

<blockquote>
  <p>The ‚Äúimplicit and maximally generalized‚Äù annotation on the last line means that the automatically inserted bindings are treated (Ê≥®Ôºöprinted) as if they had been written with <code class="language-plaintext highlighter-rouge">{...}</code>, rather than <code class="language-plaintext highlighter-rouge">(...)</code>.</p>
</blockquote>

<blockquote>
  <p>The ‚Äúimplicit‚Äù part means that the type argument <code class="language-plaintext highlighter-rouge">A</code> and the <code class="language-plaintext highlighter-rouge">Show</code> witness <code class="language-plaintext highlighter-rouge">H</code> are usually expected to be left implicit<br />
whenever we write <code class="language-plaintext highlighter-rouge">showOne1</code>, Coq will automatically insert two <em>unification variables</em> as the first two arguments.</p>
</blockquote>

<blockquote>
  <p>This automatic insertion can be disabled by writing <code class="language-plaintext highlighter-rouge">@</code>, so a bare occurrence of <code class="language-plaintext highlighter-rouge">showOne1</code> means the same as <code class="language-plaintext highlighter-rouge">@showOne1 _ _</code></p>
</blockquote>

<p>ËøôÈáåÁöÑ witness <code class="language-plaintext highlighter-rouge">H</code> Âç≥ <code class="language-plaintext highlighter-rouge">A</code> implements <code class="language-plaintext highlighter-rouge">Show</code> ÁöÑ evidenceÔºåÊú¨Ë¥®Â∞±ÊòØ‰∏™ table or recordÔºåÂèØ‰ª• written more explicitly:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">showOne2</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">showOne3</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>ÁîöËá≥</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">showOne4</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="o">}</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="no">showOne</span><span class="w"> </span><span class="o">=</span><span class="w"> 
</span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="w">
     </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">,</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">Implicit</span><span class="pi">.</span><span class="w">

</span><span class="no">showOne</span><span class="w"> </span><span class="o">=</span><span class="w"> 
</span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="no">a</span><span class="w">     </span><span class="c">(* &lt;-- Ê≥®ÊÑèËøôÈáå *)</span><span class="w">
     </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">,</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="vs-haskell">vs. Haskell</h4>

<p>È°∫‰æøÔºåHaskell ÁöÑËØùÔºå<code class="language-plaintext highlighter-rouge">Show</code> ÊòØÂèØ‰ª•Áõ¥Êé• inferred from the use of <code class="language-plaintext highlighter-rouge">show</code> Âæó</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">showOne</span> <span class="n">a</span> <span class="o">=</span> <span class="n">show</span> <span class="n">a</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">showOne</span>
<span class="n">showOne</span> <span class="o">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">String</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>‰ΩÜÊòØ Coq ‰∏çË°åÔºå‰ºöÈÄÄÂåñ‰∏ä„Äå‰∏ä‰∏Ä‰∏™ÂÆö‰πâÁöÑ instance Show„ÄçÔºåËøòÊå∫Â•áÊÄ™ÁöÑÔºà</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">showOne5</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">  </span><span class="c">(* not generalized *)</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="free-superclass-instance">Free Superclass Instance</h4>

<p>``{Ord A}<code class="language-plaintext highlighter-rouge"> led Coq to fill in both </code>A<code class="language-plaintext highlighter-rouge"> and </code>H : Eq A<code class="language-plaintext highlighter-rouge"> because it's the superclass of </code>Ord` (appears as the second argument).</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">max1</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Ord</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">if</span><span class="w"> </span><span class="no">le</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">Implicit</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">max1</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ==&gt;
     max1 = 
       fun (A : Type) (H : Eq A) (H0 : @Ord A H) (x y : A) =&gt;
         if @le A H H0 x y then y else x

   : forall (A : Type) (H : Eq A), 
       @Ord A H -&gt; A -&gt; A -&gt; A    
*)</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="no">Ord</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ==&gt; Ord : forall A : Type, Eq A -&gt; Type *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Ord</code> type ÂÜôËØ¶ÁªÜÁöÑËØùÂèØ‰ª•ÊòØÔºö</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="no">Ord</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Type</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="other-usages-of-">Other usages of <code class="language-plaintext highlighter-rouge">`{}</code></h4>

<p>Implicit generalized <code class="language-plaintext highlighter-rouge">Prop</code> mentioning free vars.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="no">Generalizable</span><span class="w"> </span><span class="k">Variables</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="pi">.</span><span class="w">

</span><span class="k">Lemma</span><span class="w"> </span><span class="no">commutativity_property</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">x</span><span class="o">}.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> </span><span class="ne">omega</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">

</span><span class="k">Check</span><span class="w"> </span><span class="no">commutativity_property</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Implicit generalized <code class="language-plaintext highlighter-rouge">fun</code>/<code class="language-plaintext highlighter-rouge">Œª</code>, however‚Ä¶</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">implicit_fun</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="o">}.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">implicit_fun</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w">  </span><span class="c">(* ==&gt; Error *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(@</span><span class="no">implicit_fun</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Implicitly-generalized but inserted as explicit via <code class="language-plaintext highlighter-rouge">`(...)</code></p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">implicit_fun</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="err">`</span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="o">).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">implicit_fun</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>ËøôÈáåÂèØ‰ª•ÁúãÂà∞ Coq ÁöÑÊâÄÊúâËØ≠Ê≥ïÈÉΩÊòØÊ≠£‰∫§ÁöÑÔºàÈùûÂ∏∏ÁâõÈÄº‚Ä¶‚Ä¶Ôºâ</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">()</code>/<code class="language-plaintext highlighter-rouge">{}</code> ÊéßÂà∂ÊòØÂê¶ÊòØ implicit argument</li>
  <li><code class="language-plaintext highlighter-rouge">`</code>-prefix ÊéßÂà∂ÊòØÂê¶ÂÅö implicit generalization
    <ul>
      <li>N.B. ÂèØËÉΩ‰Ω†ÂøòËÆ∞‰∫Ü‰ΩÜÊòØ <code class="language-plaintext highlighter-rouge">‚Üí</code> is degenerated <code class="language-plaintext highlighter-rouge">‚àÄ</code> (<code class="language-plaintext highlighter-rouge">Œ†</code>)ÔºåÊâÄ‰ª• generalization Ëá™ÁÑ∂‰ºöÁîüÊàê <code class="language-plaintext highlighter-rouge">fun</code></li>
    </ul>
  </li>
</ul>

<h3 id="records-are-products">Records are Products</h3>

<blockquote>
  <p>Record types must be declared before they are used. For example:</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">Record</span><span class="w"> </span><span class="no">Point</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="no">Build_Point</span><span class="w">
    </span><span class="o">{</span><span class="w">
      </span><span class="no">px</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="p">;</span><span class="w">
      </span><span class="no">py</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w">
    </span><span class="o">}.</span><span class="w">

</span><span class="c">(* built with constructor *)</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="o">(</span><span class="no">Build_Point</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="o">).</span><span class="w">

</span><span class="c">(* built with record syntax *)</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">px</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="no">py</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">|}.</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">py</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="no">px</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">|}.</span><span class="w">

</span><span class="c">(* field access, with a clunky "dot notation" *)</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">r</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">px</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="no">py</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">|}.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">r</span><span class="o">.(</span><span class="no">px</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">r</span><span class="o">.(</span><span class="no">py</span><span class="o">)).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Âíå OCaml ‰∏ÄÊ†∑ÊòØ nominal typing ËÄåÈùû structural typing„ÄÇ
Á±ª‰ºº‰∫é OCaml ‰∏≠ÁöÑ record ÂÖ∂ÂÆûÂà∞ backend ‰∫ÜÂ∞±‰ºöÂíå tuple Á≠â‰ª∑ÔºöÈÉΩ‰ºö lower Âà∞ Heap BlockÔºâÔºå
Coq ‰∏≠ÁöÑ Record ÂÖ∂ÂÆûÂíå Pair/Product ‰πüÊòØÁ≠â‰ª∑ÔºöÈÉΩÊòØ arity ‰∏∫ 2 ÁöÑ Inductive typeÔºö</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">Point</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Set</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Point</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">Point</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Êàë‰ªøÈÄ† <code class="language-plaintext highlighter-rouge">Print px.</code> ËæìÂá∫ÁöÑÂÆö‰πâÊ®°Êãü‰∫Ü‰∏Ä‰∏ãÔºö</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Set</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Point2</span><span class="w"> </span><span class="o">(</span><span class="no">px2</span><span class="p">:</span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">py2</span><span class="p">:</span><span class="no">nat</span><span class="o">).</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">px2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">px</span><span class="o">,</span><span class="w"> </span><span class="p">_</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">px</span><span class="pi">.</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">py2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="o">,</span><span class="w"> </span><span class="no">py</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">py</span><span class="pi">.</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">r2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">Build_Point2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="o">.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">r2</span><span class="o">.(</span><span class="no">px2</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">r2</span><span class="o">.(</span><span class="no">py2</span><span class="o">)).</span><span class="w">                        </span><span class="c">(* =&gt; 6 *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">r2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">px2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="no">py2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">|}.</span><span class="w">   </span><span class="c">(* Error: px2 is not a projection *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>ÂèØ‰ª•ÂèëÁé∞ dot notation ÊòØÂèØ‰ª•Â∑•‰ΩúÁöÑÔºå<code class="language-plaintext highlighter-rouge">.</code> Â∫îËØ•Âè™ÊòØ‰∏Ä‰∏™ pipe
‰ΩÜÊòØ <code class="language-plaintext highlighter-rouge">{|...|}</code> ‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πàËøôÈáå‰ºöËÆ§‰∏∫ <code class="language-plaintext highlighter-rouge">px2</code> ‰∏çÊòØ‰∏Ä‰∏™ record projection.</p>

<blockquote>
  <p>Note that the field names have to be different. Any given field name can belong to only one record type. 
This greatly simplifies type inference!</p>
</blockquote>

<h3 id="typeclasses-are-records">Typeclasses are Records</h3>

<blockquote>
  <p>Typeclasses and instances, in turn, are basically just syntactic sugar for record types and values (together with a bit of magic for using proof search to fill in appropriate instances during typechecking‚Ä¶</p>
</blockquote>

<blockquote>
  <p>Internally, a typeclass declaration is elaborated into a <em>parameterized</em> <code class="language-plaintext highlighter-rouge">Record</code> declaration:</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="k">Class</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="o">}.</span><span class="w">

</span><span class="k">Print</span><span class="w"> </span><span class="no">Show</span><span class="pi">.</span><span class="w">
</span><span class="k">Record</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
    </span><span class="no">Build_Show</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="o">}</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">All</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">Show</span><span class="pi">.</span><span class="w">
</span><span class="no">Variant</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="no">Build_Show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">,</span><span class="w"> </span><span class="no">string</span><span class="o">,</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w">

</span><span class="c">(* to make it more clear... *)</span><span class="w">
</span><span class="k">Inductive</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÄ</span><span class="o">(</span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÄ</span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">),</span><span class="w"> </span><span class="no">string</span><span class="o">),</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w">
  
</span><span class="c">(* or more GADT looking, i.e., implicit generalized *)</span><span class="w">
</span><span class="k">Inductive</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Coq actually call a single-field record <code class="language-plaintext highlighter-rouge">Variant</code>. 
Well actually, I found it‚Äôs for any single-constructor <code class="language-plaintext highlighter-rouge">Inductive</code>ly constructed type. 
You can even use <code class="language-plaintext highlighter-rouge">Variant</code> nonchangbly with <code class="language-plaintext highlighter-rouge">Inductive</code> as a keyword‚Ä¶</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">All</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">Point</span><span class="pi">.</span><span class="w">
</span><span class="no">Variant</span><span class="w"> </span><span class="no">Point</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Set</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="no">Build_Point</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">),</span><span class="w"> </span><span class="no">Point</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Analogously, Instance declarations become record values:</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Print</span><span class="w"> </span><span class="no">showNat</span><span class="pi">.</span><span class="w">
</span><span class="no">showNat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">string_of_nat</span><span class="w"> </span><span class="o">|}</span><span class="w">
    </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">nat</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Similarly, overloaded functions like show are really just <em>record projections</em>, which in turn are just functions that select a particular argument of a one-constructor Inductive type.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">Print</span><span class="w"> </span><span class="no">show</span><span class="pi">.</span><span class="w">
</span><span class="no">show</span><span class="w"> </span><span class="o">=</span><span class="w"> 
  </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">Show0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> 
    </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">show</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">Show0</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">show</span><span class="w">
      </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">,</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">All</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">show</span><span class="pi">.</span><span class="w">
</span><span class="no">show</span><span class="w"> </span><span class="o">=</span><span class="w"> 
  </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">Show0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
    </span><span class="kr">match</span><span class="w"> </span><span class="no">Show0</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="o">(</span><span class="kr">forall</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">,</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="kp">with</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Show</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">show</span><span class="w">
    </span><span class="kr">end</span><span class="w">
      </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">),</span><span class="w"> </span><span class="no">string</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="inferring-instances">Inferring Instances</h3>

<blockquote>
  <p>appropriate instances are automatically inferred (and/or constructed!) during typechecking.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">eg42</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="mi">42</span><span class="o">.</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">Implicit</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">eg42</span><span class="pi">.</span><span class="w">
</span><span class="no">eg42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="no">showNat</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>different with <code class="language-plaintext highlighter-rouge">Compute</code>, <code class="language-plaintext highlighter-rouge">Print</code> Â±ÖÁÑ∂ËøòÂèØ‰ª•Ëøô‰πàÊääÊâÄÊúâ implicit argument (after inferred) ÈÉΩÁªô print Âá∫Êù•‚Ä¶‚Ä¶</p>

<p>type inferrence:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">show</code> is expanded to <code class="language-plaintext highlighter-rouge">@show _ _ 42</code></li>
  <li>obviously it‚Äôs <code class="language-plaintext highlighter-rouge">@show nat __42</code></li>
  <li>obviously it‚Äôs <code class="language-plaintext highlighter-rouge">@show nat (?H : Show Nat) 42</code></li>
</ul>

<p>Okay now where to find this witness/evidence/instance/record/table/you-name-it <code class="language-plaintext highlighter-rouge">?H</code></p>

<blockquote>
  <p>It attempts to find or construct such a value using a <em>variant of the <code class="language-plaintext highlighter-rouge">eauto</code> proof search</em> procedure that refers to a ‚Äúhint database‚Äù called <code class="language-plaintext highlighter-rouge">typeclass_instances</code>.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">Print</span><span class="w"> </span><span class="no">HintDb</span><span class="w"> </span><span class="no">typeclass_instances</span><span class="pi">.</span><span class="w">  </span><span class="c">(* too much to be useful *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>‚Äúhint database‚Äù to me is better understood as a reverse of environment or typing context <code class="language-plaintext highlighter-rouge">Œì</code>. Though specialized with only <code class="language-plaintext highlighter-rouge">Instance</code> there.
ÔºàËøô‰πà‰∏ÄÁúãÂÆûÁé∞‰∏Ä‰∏™ Scala ÁöÑ <code class="language-plaintext highlighter-rouge">Implicit</code> ‰πü‰∏çÈöæÂïäÔºâ</p>

<p>Coq can even print what‚Äôs happening during this proof search!</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kr">Set</span><span class="w"> </span><span class="no">Typeclasses</span><span class="w"> </span><span class="no">Debug</span><span class="pi">.</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="o">(</span><span class="no">show</span><span class="w"> </span><span class="mi">42</span><span class="o">).</span><span class="w">
</span><span class="c">(* ==&gt;
     Debug: 1: looking for (Show nat) without backtracking
     Debug: 1.1: exact showNat on (Show nat), 0 subgoal(s)
*)</span><span class="w">

</span><span class="k">Check</span><span class="w"> </span><span class="o">(</span><span class="no">show</span><span class="w"> </span><span class="o">(</span><span class="no">true</span><span class="o">,</span><span class="mi">42</span><span class="o">)).</span><span class="w">
</span><span class="c">(* ==&gt;
     Debug: 1: looking for (Show (bool * nat)) without backtracking
     Debug: 1.1: simple apply @showPair on (Show (bool * nat)), 2 subgoal(s)
     Debug: 1.1.3 : (Show bool)
     Debug: 1.1.3: looking for (Show bool) without backtracking
     Debug: 1.1.3.1: exact showBool on (Show bool), 0 subgoal(s)
     Debug: 1.1.3 : (Show nat)
     Debug: 1.1.3: looking for (Show nat) without backtracking
     Debug: 1.1.3.1: exact showNat on (Show nat), 0 subgoal(s)      *)</span><span class="w">
</span><span class="no">Unset</span><span class="w"> </span><span class="no">Typeclasses</span><span class="w"> </span><span class="no">Debug</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>In summary, here are the steps again:</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="no">show</span><span class="w"> </span><span class="mi">42</span><span class="w">
    </span><span class="o">===&gt;</span><span class="w">   </span><span class="o">{</span><span class="w"> </span><span class="no">Implicit</span><span class="w"> </span><span class="no">arguments</span><span class="w"> </span><span class="o">}</span><span class="w">
</span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="mi">42</span><span class="w">
    </span><span class="o">===&gt;</span><span class="w">   </span><span class="o">{</span><span class="w"> </span><span class="no">Typing</span><span class="w"> </span><span class="o">}</span><span class="w">
</span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="o">(</span><span class="nv">?A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="nv">?Show0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="nv">?A</span><span class="o">)</span><span class="w"> </span><span class="mi">42</span><span class="w">
    </span><span class="o">===&gt;</span><span class="w">   </span><span class="o">{</span><span class="w"> </span><span class="no">Unification</span><span class="w"> </span><span class="o">}</span><span class="w">
</span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="o">(</span><span class="nv">?Show0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="mi">42</span><span class="w">
    </span><span class="o">===&gt;</span><span class="w">   </span><span class="o">{</span><span class="w"> </span><span class="k">Proof</span><span class="w"> </span><span class="no">search</span><span class="w"> </span><span class="no">for</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">Nat</span><span class="w"> </span><span class="no">returns</span><span class="w"> </span><span class="no">showNat</span><span class="w"> </span><span class="o">}</span><span class="w">
</span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="no">showNat</span><span class="w"> </span><span class="mi">42</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="typeclasses-and-proofs">Typeclasses and Proofs</h2>

<h3 id="propositional-typeclass-members">Propositional Typeclass Members</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Class</span><span class="w"> </span><span class="no">EqDec</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="o">{</span><span class="w"> 
    </span><span class="no">eqb_eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÄ</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="o">,</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">‚Üî</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="w"> 
  </span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Instance</span><span class="w"> </span><span class="no">eqdecNat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">EqDec</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb_eq</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nn">Nat</span><span class="p">.</span><span class="no">eqb_eq</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>ËøôÈáåÂèØ‰ª•Áî®‰∫éÊäΩË±° LF-07 ÁöÑ reflection</p>

<h3 id="substructures">Substructures</h3>

<blockquote>
  <p>Naturally, it is also possible to have typeclass instances as members of other typeclasses: these are called <em>substructures</em>.</p>
</blockquote>

<p>ËøôÈáåÁöÑ <code class="language-plaintext highlighter-rouge">relation</code> Êù•Ëá™ Prelude ‰∏çËøáÂíå LF-11 Áî®Ê≥ï‰∏ÄÊ†∑Ôºö</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">Require</span><span class="w"> </span><span class="k">Import</span><span class="w"> </span><span class="nn">Coq</span><span class="p">.</span><span class="nn">Relations</span><span class="p">.</span><span class="no">Relation_Definitions</span><span class="pi">.</span><span class="w">
</span><span class="k">Class</span><span class="w"> </span><span class="no">Reflexive</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w"> 
    </span><span class="ne">reflexivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÄ</span><span class="w"> </span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">x</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span><span class="k">Class</span><span class="w"> </span><span class="no">Transitive</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="kp">transitivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÄ</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="o">,</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">z</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Class</span><span class="w"> </span><span class="no">PreOrder</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w"> </span><span class="no">PreOrder_Reflexive</span><span class="w"> </span><span class="p">:</span><span class="o">&gt;</span><span class="w"> </span><span class="no">Reflexive</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="p">;</span><span class="w">
    </span><span class="no">PreOrder_Transitive</span><span class="w"> </span><span class="p">:</span><span class="o">&gt;</span><span class="w"> </span><span class="no">Transitive</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>The syntax <code class="language-plaintext highlighter-rouge">:&gt;</code> indicates that each <code class="language-plaintext highlighter-rouge">PreOrder</code> can be seen as a <code class="language-plaintext highlighter-rouge">Reflexive</code> and <code class="language-plaintext highlighter-rouge">Transitive</code> relation, so that, any time a reflexive relation is needed, a preorder can be used instead.</p>
</blockquote>

<p>ËøôÈáåÁöÑ <code class="language-plaintext highlighter-rouge">:&gt;</code> ÊñπÂêëÂíå subtyping ÁöÑ <em>subsumption</em> ÊòØÂèçÁùÄÁöÑ‚Ä¶‚Ä¶Ë∑ü SML ÁöÑ ascription <code class="language-plaintext highlighter-rouge">:&gt;</code> ‰∏ÄÊ†∑‚Ä¶‚Ä¶</p>

<ul>
  <li>subtyping  <code class="language-plaintext highlighter-rouge">T :&gt; S</code> : value of <code class="language-plaintext highlighter-rouge">S</code> can safely be used as value of <code class="language-plaintext highlighter-rouge">T</code></li>
  <li>ascription <code class="language-plaintext highlighter-rouge">P :&gt; R</code> : value of <code class="language-plaintext highlighter-rouge">P</code> can safely be used as value of <code class="language-plaintext highlighter-rouge">R</code></li>
</ul>

<p>Why?</p>

<h2 id="some-useful-typeclasses">Some Useful Typeclasses</h2>

<h3 id="dec"><code class="language-plaintext highlighter-rouge">Dec</code></h3>

<blockquote>
  <p>The <code class="language-plaintext highlighter-rouge">ssreflect</code> library defines what it means for a proposition <code class="language-plaintext highlighter-rouge">P</code> to be <em>decidable</em> like this‚Ä¶</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Require</span><span class="w"> </span><span class="k">Import</span><span class="w"> </span><span class="no">ssreflect</span><span class="w"> </span><span class="no">ssrbool</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">decidable</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ==&gt;
     decidable = fun P : Prop =&gt; {P} + {~ P}
*)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>.. where <code class="language-plaintext highlighter-rouge">{P} + {¬¨ P}</code> is an ‚Äúinformative disjunction‚Äù of <code class="language-plaintext highlighter-rouge">P</code> and <code class="language-plaintext highlighter-rouge">¬¨P</code>.</p>
</blockquote>

<p>Âç≥‰∏§‰∏™ evidenceÔºàÂèÇËÄÉ LF-07)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Class</span><span class="w"> </span><span class="no">Dec</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">dec</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">decidable</span><span class="w"> </span><span class="no">P</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="monad">Monad</h3>

<blockquote>
  <p>In Haskell, one place typeclasses are used very heavily is with the Monad typeclass, especially in conjunction with Haskell‚Äôs ‚Äúdo notation‚Äù for monadic actions.</p>
</blockquote>

<blockquote>
  <p>Monads are an extremely powerful tool for organizing and streamlining code in a wide range of situations where computations can be thought of as yielding a result along with some kind of ‚Äúeffect.‚Äù</p>
</blockquote>

<p>ËØ¥ËØùÂæà‰∏•Ë∞®„Äåin a wide range of situations where ‚Ä¶ ‚Äúeffect‚Äù„Äç</p>

<blockquote>
  <p>most older projects simply define their own monads and monadic notations ‚Äî sometimes typeclass-based, often not ‚Äî while newer projects use one of several generic libraries for monads. Our current favorite (as of Summer 2017) is the monad typeclasses in Gregory Malecha‚Äôs <code class="language-plaintext highlighter-rouge">ext-lib</code> package:</p>
</blockquote>

<p><a href="https://github.com/coq-ext-lib/coq-ext-lib/blob/v8.5/theories/Structures/Monad.v">https://github.com/coq-ext-lib/coq-ext-lib/blob/v8.5/theories/Structures/Monad.v</a></p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Require</span><span class="w"> </span><span class="k">Export</span><span class="w"> </span><span class="nn">ExtLib</span><span class="p">.</span><span class="nn">Structures</span><span class="p">.</span><span class="no">Monads</span><span class="pi">.</span><span class="w">
</span><span class="k">Export</span><span class="w"> </span><span class="no">MonadNotation</span><span class="pi">.</span><span class="w">
</span><span class="no">Open</span><span class="w"> </span><span class="no">Scope</span><span class="w"> </span><span class="no">monad_scope</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">Class</span><span class="w"> </span><span class="no">Monad</span><span class="w"> </span><span class="o">(</span><span class="no">M</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> 
  </span><span class="no">ret</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÄ</span><span class="w"> </span><span class="o">{</span><span class="no">T</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">},</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">M</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">;</span><span class="w">
  </span><span class="no">bind</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÄ</span><span class="w"> </span><span class="o">{</span><span class="no">T</span><span class="w"> </span><span class="no">U</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">},</span><span class="w"> </span><span class="no">M</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="o">(</span><span class="no">T</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">M</span><span class="w"> </span><span class="no">U</span><span class="o">)</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">M</span><span class="w"> </span><span class="no">U</span><span class="w">
</span><span class="o">}.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">optionMonad</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Monad</span><span class="w"> </span><span class="no">option</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w">
  </span><span class="no">ret</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">Some</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">;</span><span class="w">
  </span><span class="no">bind</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">U</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="kr">match</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="kp">with</span><span class="w">
      </span><span class="no">None</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="no">None</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">Some</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">‚áí</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w">
    </span><span class="kr">end</span><span class="w">
</span><span class="o">}.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Compare with Haskell:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="n">m</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
  
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="o">=</span> <span class="kt">Just</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
    <span class="kt">Nothing</span>  <span class="o">&gt;&gt;=</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span>
    <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After mimic <code class="language-plaintext highlighter-rouge">do</code> notation: (as PLF-11)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">sum3</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">option</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="no">x0</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">nth_opt</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">;;</span><span class="w">
  </span><span class="no">x1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">nth_opt</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">;;</span><span class="w">
  </span><span class="no">x2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">nth_opt</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">;;</span><span class="w">
  </span><span class="no">ret</span><span class="w"> </span><span class="o">(</span><span class="no">x0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">x2</span><span class="o">).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="controlling-instantiation">Controlling Instantiation</h2>

<h3 id="defaulting">‚ÄúDefaulting‚Äù</h3>

<p>Would better explicitly typed. searching can be stupid</p>

<h3 id="manipulating-the-hint-database">Manipulating the Hint Database</h3>

<blockquote>
  <p>One of the ways in which Coq‚Äôs typeclasses differ most from Haskell‚Äôs is the lack, in Coq, of an automatic check for ‚Äúoverlapping instances.‚Äù</p>
</blockquote>

<p>Âú® Haskell ‰∏≠‰∏ÄÂ§ß use case ÊòØÂèØ‰ª•ÂÅöÁ±ª‰ºº C++ ÁöÑ partial specificationÔºàÂÅèÁâπÂåñÔºâ</p>

<ul>
  <li>Check out <a href="https://kseo.github.io/posts/2017-02-05-avoid-overlapping-instances-with-closed-type-families.html">this</a> on the pros and cons of overlapping instances in Haskell</li>
  <li>Check out [this] (https://www.ibm.com/developerworks/community/blogs/12bb75c9-dfec-42f5-8b55-b669cc56ad76/entry/c__e6_a8_a1_e6_9d_bf__e7_a9_b6_e7_ab_9f_e4_bb_80_e4_b9_88_e6_98_af_e7_89_b9_e5_8c_96?lang=en) on template partial specification in C++</li>
</ul>

<blockquote>
  <p>That is, it is completely legal to define a given type to be an instance of a given class in two different ways.
When this happens, it is unpredictable which instance will be found first by the instance search process;</p>
</blockquote>

<p>Workarounds in Coq when this happen:</p>
<ol>
  <li>removing instances from hint database</li>
  <li>priorities</li>
</ol>

<h2 id="debugging">Debugging</h2>

<p>TBD.</p>

<ul>
  <li>Instantiation Failures</li>
  <li>Nontermination</li>
</ul>

<h2 id="alternative-structuring-mechanisms">Alternative Structuring Mechanisms</h2>

<p><em>large-scale structuring mechanisms</em></p>

<blockquote>
  <p>Typeclasses are just one of several mechanisms that can be used in Coq for structuring large developments. Others include:</p>

  <ul>
    <li>canonical structures</li>
    <li>bare dependent records</li>
    <li>modules and functors</li>
  </ul>
</blockquote>

<p>Module and functors is very familiar!</p>

<h2 id="further-reading">Further Reading</h2>

<p>On the origins of typeclasses in Haskell:</p>

<ul>
  <li>How to make ad-hoc polymorphism less ad hoc Philip Wadler and Stephen Blott. 16‚Äôth Symposium on Principles of Programming Languages, ACM Press, Austin, Texas, January 1989.
<a href="http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html">http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html</a></li>
</ul>

<p>The original paper on typeclasses In Coq:</p>

<ul>
  <li>Matthieu Sozeau and Nicolas Oury. First-Class Type Classes. TPHOLs 2008.
<a href="https://link.springer.com/chapter/10.1007%2F978-3-540-71067-7_23">https://link.springer.com/chapter/10.1007%2F978-3-540-71067-7_23</a></li>
</ul>

:ET