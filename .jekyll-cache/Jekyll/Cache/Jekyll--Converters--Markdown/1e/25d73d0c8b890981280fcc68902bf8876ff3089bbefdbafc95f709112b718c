I"î~<p>this chapter:</p>
<ul>
  <li>(change to new syntaxâ€¦)</li>
  <li>function abstraction</li>
  <li>variable binding  â€“ å˜é‡ç»‘å®š</li>
  <li>substitution      â€“ æ›¿æ¢</li>
</ul>

<h2 id="overview">Overview</h2>

<p>â€œBase Typesâ€, only <code class="language-plaintext highlighter-rouge">Bool</code> for now.   â€“ åŸºç±»å‹
â€¦again, exactly following TAPL.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="no">t</span><span class="w"> </span><span class="p">::</span><span class="o">=</span><span class="w"> 
    </span><span class="o">|</span><span class="w"> </span><span class="no">x</span><span class="w">                         </span><span class="no">variable</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="err">\</span><span class="no">x</span><span class="p">:</span><span class="nn">T1</span><span class="p">.</span><span class="no">t2</span><span class="w">                  </span><span class="no">abstraction</span><span class="w">       </span><span class="o">--</span><span class="w"> </span><span class="no">haskell</span><span class="o">-</span><span class="no">ish</span><span class="w"> </span><span class="no">lambda</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="w">                     </span><span class="no">application</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">tru</span><span class="w">                       </span><span class="no">constant</span><span class="w"> </span><span class="no">true</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">fls</span><span class="w">                       </span><span class="no">constant</span><span class="w"> </span><span class="no">false</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">test</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">t3</span><span class="w">   </span><span class="no">conditional</span><span class="w">

</span><span class="no">T</span><span class="w"> </span><span class="p">::</span><span class="o">=</span><span class="w"> 
    </span><span class="o">|</span><span class="w"> </span><span class="no">Bool</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">T</span><span class="w">                     </span><span class="no">arrow</span><span class="w"> </span><span class="no">type</span><span class="w">

</span><span class="o">--</span><span class="w"> </span><span class="no">example</span><span class="w">
</span><span class="err">\</span><span class="no">x</span><span class="p">:</span><span class="no">Bool</span><span class="pi">.</span><span class="w"> </span><span class="err">\</span><span class="no">y</span><span class="p">:</span><span class="no">Bool</span><span class="pi">.</span><span class="w"> </span><span class="no">x</span><span class="w">
</span><span class="o">(</span><span class="err">\</span><span class="no">x</span><span class="p">:</span><span class="no">Bool</span><span class="pi">.</span><span class="w"> </span><span class="err">\</span><span class="no">y</span><span class="p">:</span><span class="no">Bool</span><span class="pi">.</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="no">fls</span><span class="w"> </span><span class="no">tru</span><span class="w">
</span><span class="err">\</span><span class="no">f</span><span class="p">:</span><span class="no">Bool</span><span class="p">â†’</span><span class="no">Bool</span><span class="pi">.</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="no">tru</span><span class="o">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Some known Î»-idioms:</p>
<blockquote>
  <p>two-arg functions are higher-order one-arg fun, i.e. curried
no named functions yet, all â€œanonymousâ€  â€“ åŒ¿åå‡½æ•°</p>
</blockquote>

<h2 id="slide-qa-1">Slide QA 1</h2>

<ol>
  <li>2</li>
  <li><code class="language-plaintext highlighter-rouge">Bool</code>, <code class="language-plaintext highlighter-rouge">fls</code></li>
</ol>

<h2 id="syntax">Syntax</h2>

<p>Formalize syntax.
things are, as usual, in the <code class="language-plaintext highlighter-rouge">Type</code> level, so we can â€œcheckâ€ them w/ dependent type.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">ty</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Bool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">ty</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Arrow</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">ty</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">ty</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">ty</span><span class="pi">.</span><span class="w">

</span><span class="k">Inductive</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">tm</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">tm</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">abs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">ty</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">tm</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">tru</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">fls</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">test</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">tm</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Noted that, <code class="language-plaintext highlighter-rouge">\x:T.t</code> (formally, <code class="language-plaintext highlighter-rouge">abs x T t</code>), the argument type is explicitly annotated (not inferred.)</p>
</blockquote>

<p>å¦å¤–ï¼Œè¿™é‡Œä»‹ç»äº†ä¸€ä¸ªå° trick: ç”¨ <code class="language-plaintext highlighter-rouge">Notation</code> (æ›´æ¥è¿‘ å® ) è€Œé <code class="language-plaintext highlighter-rouge">Defintion</code> ä½¿å¾—æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code class="language-plaintext highlighter-rouge">auto</code>â€¦</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c">(** idB = \x:Bool. x **)</span><span class="w">
</span><span class="k">Notation</span><span class="w"> </span><span class="no">idB</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">abs</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">Bool</span><span class="w"> </span><span class="o">(</span><span class="no">var</span><span class="w"> </span><span class="no">x</span><span class="o">)).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="operational-semantics">Operational Semantics</h2>

<h3 id="values-å€¼">Values å€¼</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tru</code> and <code class="language-plaintext highlighter-rouge">fls</code> are values</li>
  <li>what about function?
    <ol>
      <li><code class="language-plaintext highlighter-rouge">\x:T. t</code> is value iff <code class="language-plaintext highlighter-rouge">t</code> value. â€“ Coq</li>
      <li><code class="language-plaintext highlighter-rouge">\x:T. t</code> is always value         â€“ most FP lang, either CBV or CBN</li>
    </ol>
  </li>
</ul>

<p>Coq è¿™ä¹ˆåšæŒºå¥‡æ€ªçš„ï¼Œä¸è¿‡å¯¹ Coq æ¥è¯´:</p>
<blockquote>
  <p>terms can be considered equiv up to the computation VM (åœ¨å…¶é¡¹åŒ–ç®€å¯ä»¥åšåˆ°çš„èŒƒå›´å†…éƒ½ç®—ç›¸ç­‰)
this rich the notion of Coqâ€™s value (æ‰€ä»¥ Coq çš„å€¼çš„æ¦‚å¿µæ˜¯æ¯”ä¸€èˆ¬è¦å¤§çš„)</p>
</blockquote>

<p>Three ways to construct <code class="language-plaintext highlighter-rouge">value</code> (unary relation = predicate)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">v_abs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">âˆ€</span><span class="no">x</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">t</span><span class="o">,</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="o">(</span><span class="no">abs</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">t</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">v_tru</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="no">tru</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">v_fls</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="no">fls</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="stlc-programs-ç¨‹åºçš„æ¦‚å¿µä¹Ÿæ˜¯è¦å®šä¹‰çš„">STLC Programs ã€Œç¨‹åºã€çš„æ¦‚å¿µä¹Ÿæ˜¯è¦å®šä¹‰çš„</h3>

<ul>
  <li><em>closed</em>    = term not refer any undefined var = <strong>complete program</strong></li>
  <li><em>open term</em> = term with <em>free variable</em></li>
</ul>

<blockquote>
  <p>Having made the choice not to reduce under abstractions, we donâ€™t need to worry about whether variables are values, since weâ€™ll always be reducing programs â€œfrom the outside in,â€ and that means the step relation will always be working with closed terms.</p>
</blockquote>

<p>if we could reduce under abstraction and variables are valuesâ€¦ Whatâ€™s the implication here? å§‹ç»ˆä¸æ‡‚â€¦</p>

<h3 id="substitution-important-æ›¿æ¢">Substitution (IMPORTANT!) æ›¿æ¢</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">[x:=s]t</code> and pronounced â€œsubstitute s for x in t.â€</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>(\x:Bool. test x then tru else x) fls   ==&gt;    test fls then tru else fls
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Important <em>capture</em> example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>[x:=tru] (\x:Bool. x)  ==&gt;  \x:Bool. x     -- x is bound, we need Î±-conversion here
                       !=&gt;  \x:Bool. tru
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Informal definitionâ€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>[x:=s]x               = s
[x:=s]y               = y                     if x â‰  y
[x:=s](\x:T11. t12)   = \x:T11. t12
[x:=s](\y:T11. t12)   = \y:T11. [x:=s]t12     if x â‰  y
[x:=s](t1 t2)         = ([x:=s]t1) ([x:=s]t2)
...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>and formally:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="no">Reserved</span><span class="w"> </span><span class="k">Notation</span><span class="w"> </span><span class="s2">"'[' x ':=' s ']' t"</span><span class="w"> </span><span class="o">(</span><span class="kp">at</span><span class="w"> </span><span class="no">level</span><span class="w"> </span><span class="mi">20</span><span class="o">).</span><span class="w">
</span><span class="k">Fixpoint</span><span class="w"> </span><span class="kp">subst</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">s</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">t</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">var</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="p">â‡’</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">eqb_string</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">t</span><span class="w">    </span><span class="c">(* &lt;-- computational eqb_string *)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">abs</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="p">â‡’</span><span class="w"> </span><span class="no">abs</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="o">(</span><span class="kr">if</span><span class="w"> </span><span class="no">eqb_string</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="o">([</span><span class="no">x</span><span class="p">:</span><span class="o">=</span><span class="no">s</span><span class="o">]</span><span class="w"> </span><span class="no">t1</span><span class="o">))</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">app</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="p">â‡’</span><span class="w"> </span><span class="no">app</span><span class="w"> </span><span class="o">([</span><span class="no">x</span><span class="p">:</span><span class="o">=</span><span class="no">s</span><span class="o">]</span><span class="w"> </span><span class="no">t1</span><span class="o">)</span><span class="w"> </span><span class="o">([</span><span class="no">x</span><span class="p">:</span><span class="o">=</span><span class="no">s</span><span class="o">]</span><span class="w"> </span><span class="no">t2</span><span class="o">)</span><span class="w">
  </span><span class="o">...</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Computable <code class="language-plaintext highlighter-rouge">Fixpoint</code> means <em>meta-function</em>! (in metalanguage, Coq here)</p>
</blockquote>

<h3 id="å¦‚æœæˆ‘ä»¬è€ƒè™‘ç”¨äºæ›¿æ¢æ‰æŸä¸ªå˜é‡çš„é¡¹-s-å…¶æœ¬èº«ä¹Ÿå«æœ‰è‡ªç”±å˜é‡-é‚£ä¹ˆå®šä¹‰æ›¿æ¢å°†ä¼šå˜å¾—å›°éš¾ä¸€ç‚¹">å¦‚æœæˆ‘ä»¬è€ƒè™‘ç”¨äºæ›¿æ¢æ‰æŸä¸ªå˜é‡çš„é¡¹ s å…¶æœ¬èº«ä¹Ÿå«æœ‰è‡ªç”±å˜é‡ï¼Œ é‚£ä¹ˆå®šä¹‰æ›¿æ¢å°†ä¼šå˜å¾—å›°éš¾ä¸€ç‚¹ã€‚</h3>

<p>Is <code class="language-plaintext highlighter-rouge">if x â‰  y</code> for function abstraction one sufficient?  â€“ åœ¨ PLT ä¸­æˆ‘ä»¬é‡‡å–äº†æ›´ä¸¥æ ¼çš„å®šä¹‰</p>
<blockquote>
  <p>Only safe if we only consider <code class="language-plaintext highlighter-rouge">s</code> is closed term.</p>
</blockquote>

<p>Prof.Mtf:</p>
<blockquote>
  <p>hereâ€¦itâ€™s not really â€œ<em>defining</em> on closed termsâ€. Technically, you can still write open terms.
if we want, we could define the real <code class="language-plaintext highlighter-rouge">closed_term</code>â€¦more works to prove things tho.</p>
</blockquote>

<p>Prof.Mtf:</p>
<blockquote>
  <p>In some more rigorous settingâ€¦we might define <code class="language-plaintext highlighter-rouge">well_typed_term</code>
and the definition itself is the proof of <code class="language-plaintext highlighter-rouge">Preservation</code>!</p>
</blockquote>

<h3 id="slide-qa-2">Slide QA 2</h3>

<ol>
  <li>(3)</li>
</ol>

<h3 id="reduction-beta-reduction-beta-å½’çº¦">Reduction ï¼ˆbeta-reductionï¼‰ beta-å½’çº¦</h3>

<p>Should be familar</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>                value v2
      ----------------------------                   (ST_AppAbs)   until value, i.e. function  (Î²-reduction)
      (\x:T.t12) v2 --&gt; [x:=v2]t12

                t1 --&gt; t1'
            ----------------                           (ST_App1)   reduce lhs, Function side
            t1 t2 --&gt; t1' t2

                value v1
                t2 --&gt; t2'
            ----------------                           (ST_App2)   reduce rhs, Arg side 
            v1 t2 --&gt; v1 t2'
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Formally,
(I was expecting they invents some new syntax for this oneâ€¦so we only have AST)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="no">Reserved</span><span class="w"> </span><span class="k">Notation</span><span class="w"> </span><span class="s2">"t1 '--&gt;' t2"</span><span class="w"> </span><span class="o">(</span><span class="kp">at</span><span class="w"> </span><span class="no">level</span><span class="w"> </span><span class="mi">40</span><span class="o">).</span><span class="w">
</span><span class="k">Inductive</span><span class="w"> </span><span class="no">step</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">â†’</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ST_AppAbs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">âˆ€</span><span class="no">x</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">t12</span><span class="w"> </span><span class="no">v2</span><span class="o">,</span><span class="w">
         </span><span class="no">value</span><span class="w"> </span><span class="no">v2</span><span class="w"> </span><span class="p">â†’</span><span class="w">
         </span><span class="o">(</span><span class="no">app</span><span class="w"> </span><span class="o">(</span><span class="no">abs</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">t12</span><span class="o">)</span><span class="w"> </span><span class="no">v2</span><span class="o">)</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">[</span><span class="no">x</span><span class="p">:</span><span class="o">=</span><span class="no">v2</span><span class="o">]</span><span class="no">t12</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ST_App1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">âˆ€</span><span class="no">t1</span><span class="w"> </span><span class="no">t1'</span><span class="w"> </span><span class="no">t2</span><span class="o">,</span><span class="w">
         </span><span class="no">t1</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">t1'</span><span class="w"> </span><span class="p">â†’</span><span class="w">
         </span><span class="no">app</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">app</span><span class="w"> </span><span class="no">t1'</span><span class="w"> </span><span class="no">t2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ST_App2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">âˆ€</span><span class="no">v1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="no">t2'</span><span class="o">,</span><span class="w">
         </span><span class="no">value</span><span class="w"> </span><span class="no">v1</span><span class="w"> </span><span class="p">â†’</span><span class="w">
         </span><span class="no">t2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">t2'</span><span class="w"> </span><span class="p">â†’</span><span class="w">
         </span><span class="no">app</span><span class="w"> </span><span class="no">v1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">app</span><span class="w"> </span><span class="no">v1</span><span class="w"> </span><span class="no">t2'</span><span class="w">
</span><span class="o">...</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="slide-qa-3">Slide QA 3</h3>

<ol>
  <li>(1)  <code class="language-plaintext highlighter-rouge">idBB idB -&gt; idB</code></li>
  <li>(1)  <code class="language-plaintext highlighter-rouge">idBB (idBB idB) -&gt; idB</code></li>
  <li>if () ill-typed <code class="language-plaintext highlighter-rouge">idBB (notB tru) -&gt; idBB fls ....</code>
    <ul>
      <li>we donâ€™t type check in step</li>
    </ul>
  </li>
  <li>(3)  <code class="language-plaintext highlighter-rouge">idB fls</code></li>
  <li>NOTâ€¦ill-typed one &amp; open term</li>
</ol>

<h2 id="typing">Typing</h2>

<h3 id="typing-contexts-ç±»å‹ä¸Šä¸‹æ–‡">Typing Contexts ç±»å‹ä¸Šä¸‹æ–‡</h3>

<p>we need something like environment but for Types.</p>

<blockquote>
  <p>three-place typing judgment, informally written   â€“ ä¸‰å…ƒç±»å‹æ–­è¨€</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Gamma âŠ¢ t âˆˆ T
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>â€œunder the assumptions in Gamma, the term t has the type T.â€</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">context</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">partial_map</span><span class="w"> </span><span class="no">ty</span><span class="pi">.</span><span class="w">
</span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="p">âŠ¢</span><span class="o">&gt;</span><span class="w"> </span><span class="no">T11</span><span class="o">,</span><span class="w"> </span><span class="no">Gamma</span><span class="o">)</span><span class="w"> 
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Why <code class="language-plaintext highlighter-rouge">partial_map</code> here? 
IMP can use <code class="language-plaintext highlighter-rouge">total_map</code> because it gave default value for undefined var.</p>

<h3 id="typing-relations">Typing Relations</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>                          Gamma x = T
                        ----------------                            (T_Var)   look up
                        Gamma |- x \in T

               (x |-&gt; T11 ; Gamma) |- t12 \in T12
               ----------------------------------                   (T_Abs)   type check against context w/ arg
                Gamma |- \x:T11.t12 \in T11-&gt;T12

                    Gamma |- t1 \in T11-&gt;T12
                      Gamma |- t2 \in T11
                     ----------------------                         (T_App)
                     Gamma |- t1 t2 \in T12
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Example</span><span class="w"> </span><span class="no">typing_example_1</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="no">empty</span><span class="w"> </span><span class="p">âŠ¢</span><span class="w"> </span><span class="no">abs</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">Bool</span><span class="w"> </span><span class="o">(</span><span class="no">var</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">âˆˆ</span><span class="w"> </span><span class="no">Arrow</span><span class="w"> </span><span class="no">Bool</span><span class="w"> </span><span class="no">Bool</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">T_Abs</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">T_Var</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">example_2</code></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">eapply</code></li>
  <li><code class="language-plaintext highlighter-rouge">A</code> ?? looks like need need another environment to look up <code class="language-plaintext highlighter-rouge">A</code>â€¦</li>
</ul>

<h3 id="typable--deciable">Typable / Deciable</h3>

<blockquote>
  <p>decidable type system = decide term if typable or not.
done by type checkerâ€¦</p>
</blockquote>

<blockquote>
  <p>can we proveâ€¦?
<code class="language-plaintext highlighter-rouge">âˆ€ Î“ e, âˆƒ Ï„, (Î“ âŠ¢ e : Ï„) âˆ¨ Â¬(Î“ âŠ¢ e : Ï„)</code> â€“ a type inference algorithm!</p>
</blockquote>

<blockquote>
  <p>Provability in Coq witness decidabile operations.</p>
</blockquote>

<h3 id="show-term-is-not-typeable">show term is â€œnot typeableâ€</h3>

<p>Keep inversion till the contradiction.</p>

:ET