{"meta":{"title":"Godvmxi Blog","subtitle":"Ball Virtual Blog | 蛋种的博客","description":"关于程序与设计 | kernel & MCU & ASIC Lover，Software Engineer | 这里是 @蛋种 的个人博客，与你一起发现更大的世界。","author":"Bright Jiang","url":"http://vball.fun","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-12-10T06:23:57.192Z","updated":"2021-12-10T06:23:57.192Z","comments":false,"path":"/404.html","permalink":"http://vball.fun/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-12-10T06:23:57.236Z","updated":"2021-12-10T06:23:57.236Z","comments":false,"path":"about/index.html","permalink":"http://vball.fun/about/index.html","excerpt":"","text":"个人详细介绍知识体系 123456789101112131415161718192021222324252627282930&#123; name: &quot;Ball Virtual&quot; gender: &quot;male&quot;, title: &quot;Senior Firmware Engineer&quot;, experience: 10.5, address: &quot;Shanghai&quot;, education: &quot;Bachelor&quot;, github: &quot;https://github.com/godvmxi&quot;, email: &quot;godvmxi@gmail.com&quot;, description: &quot;Better life, more challenging, more fun&quot;, skills: [ [&quot;VCodec&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;H264&quot;, &quot;HEVC&quot;, &quot;VP9&quot;,&quot;FFmpeg&quot;,&quot;RTP&quot;], [&quot;Linux&quot;, &quot;Kernel&quot; &quot;C&quot;, &quot;Bash&quot;,&quot;Buildroot&quot;,&quot;Uboot&quot;, &quot;Buildroot&quot;], [&quot;Asic&quot;, &quot;RTL&quot;, &quot;Verlog&quot;,&quot;ARM&quot;], [&quot;Router&quot;,&quot;Network&quot;, &quot;CCNA&quot;, &quot;Flask&quot;,&quot;ARM&quot;, &quot;VUE&quot;], [&quot;Git&quot;,&quot;Gerrit&quot;,&quot;Github&quot;], [&quot;PCB&quot;,&quot;MCU&quot;,&quot;BT&quot;,&quot;OBD&quot;,&quot;CAN&quot;,&quot;GPRS&quot;,&quot;Rs232&quot;,&quot;SPI&quot;], [&quot;Unity&quot;,&quot;C#&quot;] ], devTools: [ [&quot;VIM&quot;,&quot;Vscode&quot;,&quot;GCC&quot;,&quot;GDB&quot;], [&quot;Elecard&quot;, &quot;FFmpeg&quot;], [&quot;Source Insight&quot;], [&quot;Unity&quot;], [&quot;Protel&quot;,&quot;Logic Analyzer&quot;,&quot;Oscilloscope&quot;] ]&#125; graph LR IASIC[Asic Verification] ITOOLS[uboot/buildroot] ISDK[Video SDK] CTools[uboot/buildroot/driver] ATools[Diag] CRouter[C,C++] CFlask[Python,Flask] CJS[Javascript,Jquery,CSS] COBD[OBD,CAN,BT] CMCU[MCU,C] IVCodec1[Ffmpeg,H264,H265] IVCodec2[FFmpeg,RTP,H264,H265] PWEB[VUE,Flask] PUnity[Unity,C#] PMusic[DrumSet Tool] PZigbee[Smart Family] PZigbeeL[C,C++,Python,Protel] PZigbeeT[Zigbee,BT,CC2430] School --> Cisco School --> Infotmic School --> AMD School --> Personal Cisco --> Router Cisco --> Car Router --> CRouter Router --> CFlask Router --> CJS Router --> CTools Car --> COBD Car --> CMCU Infotmic --> IASIC Infotmic --> ISDK IASIC --> ITOOLS IASIC -->IVCodec1 ISDK --> IVCodec2 AMD --> GPU GPU --> ATools Personal --> PMusic Personal --> PZigbee PMusic --> PWEB PMusic --> PUnity PZigbee --> PZigbeeL PZigbee --> PZigbeeT"},{"title":"书单","date":"2021-12-10T06:23:57.236Z","updated":"2021-12-10T06:23:57.236Z","comments":false,"path":"books/index.html","permalink":"http://vball.fun/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-12-10T06:23:57.236Z","updated":"2021-12-10T06:23:57.236Z","comments":false,"path":"categories/index.html","permalink":"http://vball.fun/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-10T06:23:57.236Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"links/index.html","permalink":"http://vball.fun/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-12-10T06:23:57.236Z","updated":"2021-12-10T06:23:57.236Z","comments":false,"path":"repository/index.html","permalink":"http://vball.fun/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-10T06:23:57.236Z","updated":"2021-12-10T06:23:57.236Z","comments":false,"path":"tags/index.html","permalink":"http://vball.fun/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Download View Only Video From Microsoft Sharepoint","slug":"download-view-only-video-from-microsoft-sharepoint","date":"2021-12-10T06:06:45.000Z","updated":"2021-12-10T06:23:57.200Z","comments":true,"path":"2021/12/10/download-view-only-video-from-microsoft-sharepoint/","link":"","permalink":"http://vball.fun/2021/12/10/download-view-only-video-from-microsoft-sharepoint/","excerpt":"","text":"BackgroundThere are some many teams meeting records shared by other teams, but only be available for 21 days, view only but no download. Hate it. &#x1F643;&#x1F928; Talk is cheap, show me the code.Chrome/Edge(F12) -&gt; Inspector -&gt; Network -&gt; videomanifest?privode Open the Sharepoint page with the video you want to download Press F12 or Ctrl + Shift + C on your keyboard to open the browser inspector. (Cmd + Option + C on Mac OS X) In the top part, click on the Network tab In the top left part - right below the Network tab - you should see a field with the word “Filter” inside it. Click it to gain focus and type: videomanifest Refresh the Sharepoint page After a few seconds you should now see 1 result in the browser inspector’s network part. That should be something looking like:videomanifest?provider=spo… =&gt; that right there is the manifest URL you will need later on. Right-click on it and copy the link address. Use ffmpeg to download the video. 1ffmpeg -i &quot;https://theURLtoTheManifestYouCopiedHere&quot; -codec copy downloadedVideo.mp4 Enjoy it.","categories":[],"tags":[{"name":"Ffmpeg","slug":"Ffmpeg","permalink":"http://vball.fun/tags/Ffmpeg/"},{"name":"Microsoft","slug":"Microsoft","permalink":"http://vball.fun/tags/Microsoft/"},{"name":"Sharepoint","slug":"Sharepoint","permalink":"http://vball.fun/tags/Sharepoint/"}]},{"title":"Best Practice Of Vscode","slug":"best-practice-on-vscode","date":"2021-12-09T03:29:50.000Z","updated":"2021-12-10T06:23:57.196Z","comments":true,"path":"2021/12/09/best-practice-on-vscode/","link":"","permalink":"http://vball.fun/2021/12/09/best-practice-on-vscode/","excerpt":"","text":"PluginEnglish grammar check name description more Grammarly grammar checking Jump Tools name description more Bookmarks easy jump in bookmarks Code Format name description more Trailing Spaces remove space Markdown name description more Markdown Preview Markmap Support markdown preview Markdown Preview Mermaid Support mermaid flow draw Mermaid Export mermaid png export Fun name description more Power Mode Make Screen screaming and set your coding on fire","categories":[],"tags":[{"name":"Vscode","slug":"Vscode","permalink":"http://vball.fun/tags/Vscode/"},{"name":"Plugin","slug":"Plugin","permalink":"http://vball.fun/tags/Plugin/"},{"name":"Grammar","slug":"Grammar","permalink":"http://vball.fun/tags/Grammar/"}]},{"title":"Automatic Release With Github Actions","slug":"auto-release-with-github-actions","date":"2021-12-09T03:12:10.000Z","updated":"2021-12-10T06:23:57.196Z","comments":true,"path":"2021/12/09/auto-release-with-github-actions/","link":"","permalink":"http://vball.fun/2021/12/09/auto-release-with-github-actions/","excerpt":"","text":"BriefBased on my last auto release for my blog, I am considering to release my snap package to the release page automatically. Talk is cheap. Show me the code.1234567891011121314151617181920212223242526272829name: Publish Releaseon: push: tags: - &quot;v*&quot;jobs: build_7yuv_snap: runs-on: ubuntu-18.04 steps: - name: Check out Git repository uses: actions/checkout@v2 - name: Install Snapcraft uses: samuelmeuli/action-snapcraft@v1 with: use_lxd: true - name: Build Snap package run: | sg lxd -c &#x27;snapcraft --use-lxd&#x27; ls -lah - uses: &quot;marvinpinto/action-automatic-releases@latest&quot; with: repo_token: &quot;$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;&quot; automatic_release_tag: &quot;latest&quot; prerelease: true title: &quot;Development Build&quot; files: | *.snap Release contentsIt will package the whole source package based on new tag, and if you want to package other files, use the files flag: 12files: | *.snap GITHUB_TOKENyou can generate it in your personal token page and fill it in the secret pages. so cheap and skip.","categories":[],"tags":[{"name":"Github actions","slug":"Github-actions","permalink":"http://vball.fun/tags/Github-actions/"},{"name":"Yaml","slug":"Yaml","permalink":"http://vball.fun/tags/Yaml/"},{"name":"Automatic","slug":"Automatic","permalink":"http://vball.fun/tags/Automatic/"}]},{"title":"Switch to Github Actions and F Travis CI","slug":"use-github-actions-push-blog","date":"2021-12-08T07:43:07.000Z","updated":"2021-12-10T06:23:57.224Z","comments":true,"path":"2021/12/08/use-github-actions-push-blog/","link":"","permalink":"http://vball.fun/2021/12/08/use-github-actions-push-blog/","excerpt":"","text":"Fxxk Travis Ci stopped generating my pageOne day, After I updated some blog and there was no update on my Github page blog, then I checked the Travis-CI, it showed Builds have been temporarily disabled for public repositoriesThen, whatever, F it. I spent more than 2 hours setting up my Credit Card to activate the Travis-CI service, and now It just down and without any notifications. Back to GitHub actionsLuckily, Github provides the workflows with actions. sequenceDiagram participant LA as Local participant RM as Repo Master Branch participant RP as Repo gh-pages Branch participant GA as Github Actions LA ->> LA: hexo new page LA ->> LA: hexo s, setup preview server LA ->> LA: http://127.0.0.1:4000 preview LA --> LA: add github actions workflow yaml LA ->> RM: Push to Master RM ->> GA: Trigger actions GA ->> GA: Setup node GA ->> GA: Install package GA ->> GA: Generate static blog page GA ->> RP: Push to Repo publish branch Github workflow yaml settingCode talks firstly 123456789101112131415161718192021222324252627282930313233343536# This workflow will do a clean install of# node dependencies, cache/restore them,# build the source code and run tests across different versions of node# For more information see:# https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions---name: Node.js CIon: push: branches: - masterjobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v2 with: node-version: &#x27;14&#x27; - name: Setup Env run: | npm install -g hexo-cli@4.0.0 npm install hexo generate - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125; publish_dir: ./public publish_branch: gh_pages # deploying branch Workflow detailSetup basic Node based on ubuntu123456789101112131415on: push: branches: - masterjobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v2 with: node-version: &#x27;14&#x27; Install hexo to CI system and build123- name: Setup Env run: | npm install -g hexo-cli@4.0.0 if we do not install this version globally, then the CI will not find the hexo command. Install other packages and generate the static page12npm installhexo generate Deploy to Repo gh-pages branch with deploy tools123456- name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125; publish_dir: ./public publish_branch: gh_pages # deploying branch It will deploy your Ci public directory to your repo gh_pages branch. Actions Related ResourceIf you need more help, just peaceiris/actions-gh-pages@v3 pages for more help. This actions support many tokens If you just need https, choose github_token, and if you prefer to ssh, you can use deploy_key(it’s my style) Last, DO NOT forget to update your page setting to your gh-pages branch","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"http://vball.fun/tags/Github/"},{"name":"Actions","slug":"Actions","permalink":"http://vball.fun/tags/Actions/"}]},{"title":"pynput stop key echo in bash","slug":"pynput-stop-echo-in-bash","date":"2021-12-07T09:16:18.000Z","updated":"2021-12-10T06:23:57.224Z","comments":true,"path":"2021/12/07/pynput-stop-echo-in-bash/","link":"","permalink":"http://vball.fun/2021/12/07/pynput-stop-echo-in-bash/","excerpt":"","text":"Optional descriptions optionally block propagation of keyboard events python block key events python listen to keyboards and stop the event message Code talk firstset suppress=True will swallow. ALL keypresses 123456789101112131415#!/usr/bin/env python3from pynput.keyboard import Key, Listenerdef on_press(key): print(&#x27;&#123;0&#125; pressed&#x27;.format( key)) if key == Key.esc: # Stop listener return False# Collect events until releasedwith Listener( on_press=on_press, suppress=True) as listener: listener.join() IssueWhen use pynput to capture keyboard input like this: 123with Listener( on_press=on_press) as listener: listener.join() the terminal will auto echo the key info, even special echo for up/down , such as: 1234567891011$ python3 key_listener.py Key.up pressed^[[AKey.right pressed^[[CKey.left pressed^[[DKey.down pressed^[[BKey.right pressed^[[CKey.left pressed^[[DKey.up pressed^[[A&#x27;a&#x27; presseda&#x27;s&#x27; pressed Now the world is slient and clean. NOTEbut if you forget to exit the app, other apps will never get a valid key input forever. You can also just read input from stdin,use get_char to do it","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://vball.fun/tags/Python/"},{"name":"pynput","slug":"pynput","permalink":"http://vball.fun/tags/pynput/"}]},{"title":"build 7yuv snap package, run 7yuv in no-qt4 system","slug":"build-7yuv-snap-package","date":"2021-11-23T07:00:53.000Z","updated":"2021-12-10T06:23:57.196Z","comments":true,"path":"2021/11/23/build-7yuv-snap-package/","link":"","permalink":"http://vball.fun/2021/11/23/build-7yuv-snap-package/","excerpt":"","text":"7YUV About Snap My snap build file for 7yuv Snap build instructions snap base build plugin add Qt4 runtime to snap Add dbus and slot manual build snap from code I will ignore steps about installing snap and snapcrash build snap package – with lxd Install your snap 7YUVAs a video software developer, 7yuv is a nice YUV sequence analysis tool(Of course, Vooya is another good option), but the developer of 7YUV does not punish the Qt5 version and the latest Linux system has removed the support of Qt4. So I chose to build a snap package for 7yuv to make sure it can works well in any snap supported system. About SnapSnaps are app packages for desktop, cloud and IoT that are easy to install, secure, cross‐platform and dependency‐free. Snaps are discoverable and installable from the Snap Store, the app store for Linux with an audience of millions. My snap build file for 7yuvYou can find my full code in LINK Snap build instructionssnap baseThe qt4 is still support on snap core18, so I choose the core18 as the base system build pluginI have the raw 7yuv binnary, so I choose the dump plugin to install the 7yuv to my snap packge, the plugin will install all source dirtory to the system and keep the origin directory layout. 12345parts: 7yuv: # See &#x27;snapcraft plugins&#x27; plugin: dump source: 7yuv-2.5_x64_pre_build/ add Qt4 runtime to snap123456789101112131415161718192021222324252627parts: 7yuv:------------ stage-packages: - libqtcore4 - libqtgui4 - libstdc++6 - libqt4-opengl - libalglib3.11 - libgcc1 - libgl1 - libgl1-mesa-glx - libgl2ps1.4 - libglu1 - libglu1-mesa - libgsl23 - libgslcblas0 - libmuparser2v5 - libqt4-network - libqt4-qt3support - libqt4-svg - libqt4-xml - libqtassistantclient4 - libqtexengine1 - libtamuanova-0.2 - zlib1g - sip-api-12.3 Add dbus and slotDo not ask why, I do not know, you can check the snap doc for it. 12345678910111213slots: dbus-daemon: interface: dbus bus: session name: de.datahammer.7yuvplugs: config-7yuv: interface: system-files read: - / write: - / manual build snap from codeI will ignore steps about installing snap and snapcrashbuild snap package – with lxdI use the lxd to replace the multpass, the multipass has a lot trouble in ubuntu20, so I give up it. 1snapcraft --debug --use-lxd you will find the target snap file in build directory. Install your snap1snap install --devmode --dangerous 7yuv_0.1_amd64.snap Now you can run 7yuv from any snap system","categories":[],"tags":[{"name":"7yuv","slug":"7yuv","permalink":"http://vball.fun/tags/7yuv/"},{"name":"Snap","slug":"Snap","permalink":"http://vball.fun/tags/Snap/"},{"name":"Qt4","slug":"Qt4","permalink":"http://vball.fun/tags/Qt4/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://vball.fun/tags/Ubuntu/"}]},{"title":"add watermarker to bitstream tool","slug":"add-watermarker-to-h264-tool","date":"2021-11-16T07:58:29.000Z","updated":"2021-12-10T06:23:57.196Z","comments":true,"path":"2021/11/16/add-watermarker-to-h264-tool/","link":"","permalink":"http://vball.fun/2021/11/16/add-watermarker-to-h264-tool/","excerpt":"","text":"Index: Usage read and write bitstream by frames with opencv2 use freetype to render the string and add to frame Show new frame with opencv2 font load note Usage Guide Code Help: Basic Usage: Advanced Usage: Parameters Guide Talk is cheap, show me the code UsageIn daily test, I need to add number watermarker to the bitstream, then dump it to different yuv formats. read and write bitstream by frames with opencv2123456789101112131415161718192021222324252627cap = cv2.VideoCapture(args.input)total_frames = int( cap.get(cv2.CAP_PROP_FRAME_COUNT) )input_width = int(cap.get(3))input_height = int(cap.get(4))video_info = &#x27;video : &#123;0&#125;x&#123;1&#125; frames:&#123;2&#125;&#x27;.format(input_width, input_height, total_frames)print(video_info)print(&quot;total frames :&quot;, total_frames)fourcc = cv2.VideoWriter_fourcc(*&#x27;X264&#x27;)video_output = cv2.VideoWriter(args.output, fourcc, 30.0, (input_width, input_height))if args.frame_number &gt; 0 and args.frame_number &lt; total_frames: total_frames = args.frame_number print(&quot;processing frame number is : &quot;, total_frames)for index in range(total_frames): # set frame position #cap.set(cv2.CAP_PROP_POS_FRAMES,index) ret, frame = cap.read() marker_text = &#x27;&#123;0&#125;&#123;1:0&gt;2&#125;&#x27;.format(args.prefix, index) add_watermark_to_frame(frame, marker_text,args.text_height, (args.offset_x, args.offset_y)) video_output.write(frame) if args.show: cv2.imshow(&quot;Video&quot;, frame) if cv2.waitKey(5000) &amp; 0xFF == ord(&#x27;q&#x27;): breakcap.release()video_output.release()cv2.destroyAllWindows() use freetype to render the string and add to frame12345678910111213141516171819202122232425def add_watermark_to_frame(frame, txt, text_height,offset): ft = cv2.freetype.createFreeType2() ft.loadFontData(fontFileName=&#x27;UbuntuMono-Regular.ttf&#x27;, id=0) ft_size, baseline= ft.getTextSize(txt, text_height, -1) #print(&quot;Msg: &#123;0&#125; &#123;1&#125; dat: &#123;2&#125;&quot;.format(ft_size, baseline, txt)) magin_pixel = 5 rectangle_start = (offset[0] + baseline - magin_pixel, offset[1] - ft_size[1] - baseline - magin_pixel ) rectangle_end = (offset[0] + ft_size[0] + magin_pixel , offset[1] + baseline + magin_pixel) # #print(&quot;start: &#123;0&#125; -&gt; end: &#123;1&#125;&quot;.format(rectangle_start, rectangle_end)) cv2.rectangle(frame, rectangle_start, rectangle_end, (250,240,240), -1 ) ft.putText(img=frame, text=txt, org=(offset[0], offset[1]), fontHeight=text_height, color=(255, 10, 10), thickness=-1, line_type=cv2.LINE_AA, bottomLeftOrigin=True) return frame Show new frame with opencv21cv2.imshow(&quot;Video&quot;, frame) font load note the code will auto load “UbuntuMono-Regular.ttf” to render the picture with freetype, please put this font to the script dir the code need opencv2 support, install it by yourself Usage GuideCode Help: Basic Usage:It will get first 10 frames and add number watermarker in each frame, then save to output.mp4 file. 1python3 cv_watermark.py -i origin.mp4 -o output.mp4 -n 10 Advanced Usage:It will get first 10 frames and add number watermarker in each frame, then save to output.mp4 file. 1python3 ./cv_watermark.py -i Mix_BostonHarbor_MainStreet_GrandBendPatio_1920x1088.mp4 -prefix &quot;AMD is awesome: &quot; -s Parameters Guide parameter description test tset i input bitstream file name n frame number o output bitstream file name ox watermarker offset x in target bitstream oy watermarker offset y in target bitstream prefix prefix info in front of the number watermarker s show the picture frame by frame, q: exit ; space : next frame th watermarker text height Talk is cheap, show me the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/env python3import cv2import numpy as npimport osimport subprocess as spimport argparseargs = Nonedef get_args_parse(): parser = argparse.ArgumentParser(&#x27;传入参数：***.py&#x27;) parser.add_argument(&#x27;-iw&#x27;,&#x27;--width&#x27;, type=int, default=1920, help=&quot;input frame width&quot;) parser.add_argument(&#x27;-ih&#x27;,&#x27;--height&#x27;, type=int, default=1088, help=&quot;input frame height&quot;) parser.add_argument(&#x27;-ox&#x27;,&#x27;--offset_x&#x27;, type=int, default=64, help=&quot;watermark start offset x&quot;) parser.add_argument(&#x27;-oy&#x27;,&#x27;--offset_y&#x27;, type=int, default=128, help=&quot;watermark start offset y&quot;) parser.add_argument(&#x27;-i&#x27;,&#x27;--input&#x27;, default=&quot;input.yuv&quot;) parser.add_argument(&#x27;-o&#x27;,&#x27;--output&#x27;, default=&quot;out.yuv&quot;) parser.add_argument(&#x27;-th&#x27;,&#x27;--text_height&#x27;, type=int, default=100, help=&quot;watermark text height&quot;) parser.add_argument(&#x27;-prefix&#x27;,&#x27;--prefix&#x27;, default=&quot;&quot;, help=&quot;watermarker prefix, such as AMD-0&quot;) parser.add_argument(&#x27;-s&#x27;,&#x27;--show&#x27;,help=&quot;show image one by one&quot;, action=&quot;store_true&quot;) parser.add_argument(&#x27;-n&#x27;,&#x27;--frame_number&#x27;,type=int, default=0,help=&quot;handle n frames&quot;) return parserdef add_watermark_to_frame(frame, txt, text_height,offset): ft = cv2.freetype.createFreeType2() ft.loadFontData(fontFileName=&#x27;UbuntuMono-Regular.ttf&#x27;, id=0) ft_size, baseline= ft.getTextSize(txt, text_height, -1) #print(&quot;Msg: &#123;0&#125; &#123;1&#125; dat: &#123;2&#125;&quot;.format(ft_size, baseline, txt)) magin_pixel = 5 rectangle_start = (offset[0] + baseline - magin_pixel, offset[1] - ft_size[1] - baseline - magin_pixel ) rectangle_end = (offset[0] + ft_size[0] + magin_pixel , offset[1] + baseline + magin_pixel) # #print(&quot;start: &#123;0&#125; -&gt; end: &#123;1&#125;&quot;.format(rectangle_start, rectangle_end)) cv2.rectangle(frame, rectangle_start, rectangle_end, (250,240,240), -1 ) ft.putText(img=frame, text=txt, org=(offset[0], offset[1]), fontHeight=text_height, color=(255, 10, 10), thickness=-1, line_type=cv2.LINE_AA, bottomLeftOrigin=True) return frameif __name__ == &quot;__main__&quot;: args = get_args_parse().parse_args() print(args) print(args.width) #get_watermark(&quot;temp&quot;) cap = cv2.VideoCapture(args.input) total_frames = int( cap.get(cv2.CAP_PROP_FRAME_COUNT) ) input_width = int(cap.get(3)) input_height = int(cap.get(4)) video_info = &#x27;video : &#123;0&#125;x&#123;1&#125; frames:&#123;2&#125;&#x27;.format(input_width, input_height, total_frames) print(video_info) print(&quot;total frames :&quot;, total_frames) fourcc = cv2.VideoWriter_fourcc(*&#x27;X264&#x27;) video_output = cv2.VideoWriter(args.output, fourcc, 30.0, (input_width, input_height)) if args.frame_number &gt; 0 and args.frame_number &lt; total_frames: total_frames = args.frame_number print(&quot;processing frame number is : &quot;, total_frames) for index in range(total_frames): # set frame position #cap.set(cv2.CAP_PROP_POS_FRAMES,index) ret, frame = cap.read() marker_text = &#x27;&#123;0&#125;&#123;1:0&gt;2&#125;&#x27;.format(args.prefix, index) add_watermark_to_frame(frame, marker_text,args.text_height, (args.offset_x, args.offset_y)) video_output.write(frame) if args.show: cv2.imshow(&quot;Video&quot;, frame) if cv2.waitKey(5000) &amp; 0xFF == ord(&#x27;q&#x27;): break cap.release() video_output.release() cv2.destroyAllWindows()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://vball.fun/tags/Python/"},{"name":"Opencv","slug":"Opencv","permalink":"http://vball.fun/tags/Opencv/"},{"name":"Freetype","slug":"Freetype","permalink":"http://vball.fun/tags/Freetype/"},{"name":"Font","slug":"Font","permalink":"http://vball.fun/tags/Font/"}]},{"title":"generate different yuv in different formats","slug":"ffmpeg-generate-yuv-format","date":"2021-11-16T07:44:02.000Z","updated":"2021-12-10T06:23:57.200Z","comments":true,"path":"2021/11/16/ffmpeg-generate-yuv-format/","link":"","permalink":"http://vball.fun/2021/11/16/ffmpeg-generate-yuv-format/","excerpt":"","text":"Index: FFMPEG convet basic usage Show all support formats by ffmpeg FFMPEG convert mp4 to yuv with resolution and format Convert yuv to H264/mp4 How to generate RGB444 FP16 file Install ffmpeg and imagemagick. First convert the image to RGB format from YUV420. Convert more formats Display the RGBA FP16 image My work flow to generate custom yuv formats YUV view tools ffmpeg can be used to generate many kinds of format. just enum it and record it. FFMPEG convet basic usageShow all support formats by ffmpeg1ffmpeg -pix_fmts use “-pix_fmt “ to define the output formats in ffmpeg name format bit depth Note yuv420p YUV420 8 NV12 yuv420p16le YUV420 10 P0101? yuv444p YUV444 8 yuv444p10le YUV444 10 FFMPEG convert mp4 to yuv with resolution and format1ffmpeg -y -i $&#123;file_name&#125;_$&#123;in_res&#125;.mp4 -pix_fmt yuv420p -s $out_res $&#123;file_name&#125;_$&#123;out_res&#125;.yuv Convert yuv to H264/mp41ffmpeg -f rawvideo -pix_fmt yuv420p -s:v 720x480 -r 25 -i Mix_BostonHarbor_MainStreet_GrandBendPatio_720x480.yuv -c:v libx264 output.mp4 How to generate RGB444 FP16 fileHere is the guideline from Osman Install ffmpeg and imagemagick.1sudo apt install imagemagick ffmpeg First convert the image to RGB format from YUV420.1ffmpeg -pix_fmt yuv420p -s 1920x1080 -i BostonHarbor_1920x1080.yuv -frames:v 10 -pix_fmt rgb48le BostonHarbor_1920x1080-rgb48le.rgb Convert more formatsThen use the following imagemagick command to convert from RGB to RGBA FP16 format. 1convert -size 1920x1080 -depth 16 -colorspace rgb rgb:BostonHarbor_1920x1080-rgb48le.rgb -size 1920x1080 -depth 16 -define quantum:format=floating-point -colorspace rgb rgba:BostonHarbor_1920x1080-rgbafp16.rgb Display the RGBA FP16 image1display -size 1920x1080 -depth 16 -define quantum:format=floating-point -endian lsb rgba:BostonHarbor_1920x1080-rgbafp16.rgb My work flow to generate custom yuv formats Get some reference yuv files with ffmpeg or from web Manual split and combine your custom YUV files with split\\cat&gt;&gt; commond. Encode your custom yuv to h264 with FFMPEG Add number watermarker to your custom yuv file Decode your custom bitstreams to different resolutions and formats. YUV view tools vooya7yuv","categories":[],"tags":[{"name":"FFMPEG","slug":"FFMPEG","permalink":"http://vball.fun/tags/FFMPEG/"},{"name":"H264","slug":"H264","permalink":"http://vball.fun/tags/H264/"},{"name":"YUV","slug":"YUV","permalink":"http://vball.fun/tags/YUV/"}]},{"title":"Zhuyin Pinyin 拼音注音編輯器","slug":"toneoz","date":"2021-11-02T08:37:22.000Z","updated":"2021-12-10T06:23:57.224Z","comments":true,"path":"2021/11/02/toneoz/","link":"","permalink":"http://vball.fun/2021/11/02/toneoz/","excerpt":"","text":"好东西记录下来，并且安利一下。如果有人能看到的话。 遇到了一个好东西，刚好给孩子学习拼音使用–toneoz作者实现方法比较有意思，直接使用字体来实现注音标注，于是这个就可以在任意一个编辑器上使用，如果你的应用支持字体更换，那应用范围就更广了。 https://toneoz.com/ 字体安装github上边直接下载安装到系统字体库即可。。。大神，跪了 在线选音编辑器https://toneoz.com/ime 多音字处理考虑到中文存在多音字问题，作者提供了一个选音编辑器，可以非常方便的支持多音字的标注选择，选择完成后可以直接复制到word或者导出成图片。","categories":[],"tags":[{"name":"toneoz","slug":"toneoz","permalink":"http://vball.fun/tags/toneoz/"},{"name":"pinyin","slug":"pinyin","permalink":"http://vball.fun/tags/pinyin/"}]},{"title":"COVID-1984 is ready, will infect all the world, no one can survive","slug":"1984","date":"2021-10-27T07:56:47.000Z","updated":"2021-12-10T06:23:57.192Z","comments":true,"path":"2021/10/27/1984/","link":"","permalink":"http://vball.fun/2021/10/27/1984/","excerpt":"","text":"COVID-1984 is ready, will infect all the world, no one can survive!","categories":[],"tags":[{"name":"1984","slug":"1984","permalink":"http://vball.fun/tags/1984/"},{"name":"Shit","slug":"Shit","permalink":"http://vball.fun/tags/Shit/"}]},{"title":"csdn blog export / 博客导出","slug":"csdn-export","date":"2021-10-27T06:46:42.000Z","updated":"2021-12-10T06:23:57.196Z","comments":true,"path":"2021/10/27/csdn-export/","link":"","permalink":"http://vball.fun/2021/10/27/csdn-export/","excerpt":"","text":"CSDN垃圾CSDN 垃圾不用多说了，以前只是看不到别人的博客，不过还有谷歌可以弥补，不过最近朋友和我说你的几个文章怎么变成vip独享了。。。我突然发现我的烂文字竟然还被CSDN偷偷摸摸对部分用户VIP，汗颜。。导出来算了 导出到hexo考虑导出到hexo，搜罗了半天，没有合适的工具和代码，就自己写一个吧，需要解决三个问题 博客列表获取 博客文章内容转换成markdown 导出配套的图片数据 博客列表获取CSDN 文章列表接口： 获得后从html中提取对应的xpath节点，使用lxml提取出来博客的目录link id.然后拼接文章接口获取到文章链接： https://blog.csdn.net/godvmxi/article/details/{link id}二话不说贴代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/bin/env python3import sysimport localeimport requestsfrom lxml import etreeimport pprintimport osimport timeprint(sys.getfilesystemencoding())print(locale.getpreferredencoding())def get_acticle_list(user, page_start, page_end): headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36&quot;&#125; link_list = [] for index in range(int(page_start), int(page_end)+1 ): print(index) base_url= &quot;https://blog.csdn.net/godvmxi/article/list/%s&quot;%index res = requests.get(url = base_url,headers=headers) print(res.url) print(res.status_code) page_html = etree.HTML(res.content) article_list = page_html.xpath(&#x27;//*[@id=&quot;articleMeList-blog&quot;]/div[2]&#x27;)[0] print(len(article_list)) for obj in article_list: id = obj.attrib[&quot;data-articleid&quot;] link = &quot;https://blog.csdn.net/godvmxi/article/details/%s\\n&quot;%id link_list.append(link) pprint.pprint(link_list) with open(&quot;link.txt&quot;,&quot;w&quot;) as fd: fd.writelines(link_list) #print(len(link_list)) return link_listdef down_load_articals(link_list): for link in link_list: link = link.replace(&quot;\\n&quot;, &quot;&quot;) print(&quot;Download : %s&quot;%link) file_name = link.split(&quot;/&quot;)[-1] print(&quot;target file name-&gt;%s&quot;%file_name) cmd = &quot;clean-mark %s -o download/%s&quot;%(link,file_name) print(&quot;cmd-&gt; %s&quot;%cmd) os.system(cmd) time.sleep(5) #breakif __name__ == &quot;__main__&quot; : user= sys.argv[1] page_start = sys.argv[2] page_end = sys.argv[3] link_list = get_acticle_list(user, page_start, page_end) down_load_articals(link_list) 使用clean-mark 将网页转换成markdown 安装clean-mark1npm install -g clean-mark 2: 网页转换1clean-mark $&#123;link&#125; -o download/target.md&quot; 处理markdown中的图片因为图片都在csdn服务器或者其他第三方服务器，这里需要处理脚本，把对应的图片下载下来。 解析，上代码了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/bin/env python3import sysimport localeimport requestsfrom lxml import etreeimport pprintimport osimport timeimport shutildef handle_image_line(line, img_dir, index): line = line.replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot;![](&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;).replace(&quot; &quot;, &quot;&quot;) print(&quot;will handle line -&gt; &quot; + line) link_name = line file_name = line.split(&quot;/&quot;)[-1] post_fix = file_name.split(&quot;.&quot;)[-1] if len(post_fix) &gt; 0: post_fix = post_fix.lower() final_file_name = None print(&quot;link file_name -&gt; &quot; + file_name + &quot; post-&gt;&quot; + post_fix + &quot;&lt;-&quot;) cmd = None if line.find(&quot;img-blog&quot;) &gt; 0: link_name = link_name.split(&quot;?&quot;)[0] file_name = link_name.split(&quot;/&quot;)[-1] target_file_name = img_dir + &quot;/&quot; + file_name print(&quot;csdn img link name:&quot; + link_name) print(&quot;csdn file name : &quot; + file_name) print(&quot;target_file_name: &quot; + target_file_name) cmd=&quot;wget %s -O %s&quot;%(link_name, target_file_name) elif post_fix in [&quot;png&quot;, &#x27;jpg&#x27;, &#x27;jpeg&#x27;, &quot;gif&quot;]: target_file_name = img_dir + &quot;/&quot; + file_name print(&quot;##normal target file : &quot;+ target_file_name) cmd = &quot;wget %s -O %s&quot;%(link_name, target_file_name) else: print(&quot;downlink is not support&quot;) sys.exit(0) print(&quot;will run cmd: &quot; + cmd) os.system(cmd) line = &quot;![](%s)\\n&quot;%file_name time.sleep(2) return line passdef process_origin_markdown(source_dir, file_name, target_dir, index): #img_dir = target_dir + &quot;/csdn_&quot; + file_name.replace(&quot;.md&quot;, &quot;&quot;) #target_file = target_dir + &quot;/csdn_&quot; + file_name img_dir = &quot;%s/z_csdn_%03d_%s&quot;%(target_dir, index, file_name.replace(&quot;.md&quot;, &quot;&quot;)) target_file = &quot;%s/z_csdn_%03d_%s&quot;%(target_dir, index, file_name) print(&quot;target file -&gt; &quot; + target_file) print(&quot;target img dir-&gt; &quot; + img_dir) #os.remove(target_file) shutil.rmtree(path = img_dir,ignore_errors=True) os.mkdir(img_dir) out_lines = [] with open(source_dir + &quot;/&quot; +file_name, &quot;r&quot;) as fd: lines = fd.readlines() for line in lines: if line.startswith(&quot;link&quot;): continue if line.startswith(&quot;keywords:&quot;): line = &quot;tags: CSDN\\n&quot; if line.startswith(&quot;![]&quot;) : line = handle_image_line(line, img_dir, index) + &quot;\\n&quot; print(&quot;img line : &quot; + line) out_lines.append(line) if len(out_lines) &gt; 0 : with open(target_file, &quot;w+&quot;) as fd: fd.writelines(out_lines) if __name__ == &quot;__main__&quot;: source_dir = sys.argv[1] target_dir = sys.argv[2] start_files = int(sys.argv[3]) end_files = int(sys.argv[4]) source_file_list = os.listdir(source_dir) #pprint.pprint(source_file_list) index = 1 for file in source_file_list : if index &gt; end_files: break print(&quot;########################## handle file -&gt; start: %3d end:%3d index:%3d file: %s&quot;%(start_files,end_files, index, file)) if index &gt;= start_files: process_origin_markdown(source_dir, file, target_dir,index) index = index + 1 手动处理部分冲突问题因为hexo对部分的关键词不好，这里需要对部分关键词进行修改，比如： link 删掉即可description , 手动截断或者删除特殊字符 脚本提供了调试方法： 123456python3 get_img.py download/ /srv/chia/disk/1/work/code/github/blog/source/_posts/ 74 90arg1： 原始markdown文件位置arg2： hexo博客陌路arg3： 起始文件indexarg4： 结束文件index","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://vball.fun/tags/Python/"},{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-25T12:46:25.000Z","updated":"2021-12-10T06:23:57.220Z","comments":true,"path":"2021/10/25/hello-world/","link":"","permalink":"http://vball.fun/2021/10/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Mount samba with current user","slug":"mount-samba-with-user","date":"2021-10-25T07:35:08.000Z","updated":"2021-12-10T06:23:57.224Z","comments":true,"path":"2021/10/25/mount-samba-with-user/","link":"","permalink":"http://vball.fun/2021/10/25/mount-samba-with-user/","excerpt":"","text":"When you want to mount a samba to modify the file , there are always some issues : all kind of file permission issues how to auto mount samba Samba server setting file permissiongid=1000,uid=1000,you can use id command to find your current user info 1234$ iduid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),112(lpadmin),128(sambashare) how to auto mount sambahere is my /etc/fstab 12//dbs-04/data /nfs/data/ cifs credentials=/home/.smbcredentials,uid=1000,gid=1000 0 0//dbs-04/home /nfs/home/ cifs credentials=/home/.smbcredentials,uid=1000,gid=1000 0 0 the client user info is in /home/user/.smbcredentials, 1234$ cat /home/user/.smbcredentialsusername=smbuserpassword=smbuserpasswd my server setting1234567[data] comment = user path = /data/user browseable = yes writeable = yes guest ok = yes force user = jbright remember add your samba user into your server","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://vball.fun/tags/Linux/"},{"name":"Samba","slug":"Samba","permalink":"http://vball.fun/tags/Samba/"}],"author":"Godvmxi"},{"title":"老头乐 Batocera plus 2.0 精美界面-中文64G复古游戏包-by游戏方块 + 飞行模拟器","slug":"game/betocera_all_pc","date":"2021-10-25T02:44:42.000Z","updated":"2021-12-10T06:23:57.200Z","comments":true,"path":"2021/10/25/game/betocera_all_pc/","link":"","permalink":"http://vball.fun/2021/10/25/game/betocera_all_pc/","excerpt":"","text":"最近又燃起了玩老头乐的想法于是就有了这篇垃圾 Batocera plus 2.0 精美界面-中文64G复古游戏包-by游戏方块（64位电脑）Batocera plus 2.0 精美界面-中文64G复古游戏包-by游戏方块（64位电脑)–游戏方块About Batocera.linux 凤凰模拟器 无聊就玩老头乐既然是老头乐，伴随了童年的接机+小霸王肯定是必须，之前用了905机顶盒改装的游戏盒子（各种坑，什么tf卡丢失，数据丢失，无法启动各种问题），但是麻，又想玩飞行模拟器，干脆二合一算了，果断换回了Batocera这款神器，但是你让我重新从零开始搭建一套游戏包，还是不符合老头乐的风格。 Batocera飞行模拟器硬件方案 设备 来源 价格 是否必须 H61主板 海鲜市场 80 是 i3 3220 海鲜市场 60 是 DDR3 4G 主板赠送 0 是 风扇 主办赠送 0 是 游戏硬盘 海鲜市场 20 是 VGA转HDMI 海鲜市场 20 非 以下是飞行模拟器，非必须 —- —- —- 模拟器硬盘 海鲜市场 20 是 模拟器手柄MC6C 海鲜市场 80 是 USB加密狗 海鲜市场 20 是 Batocera 下载1magnet:?xt=urn:btih:CE3792AEED1D44CA57897C8AAC86883A6A42345B= 55寸大屏玩游戏真爽","categories":[{"name":"game","slug":"game","permalink":"http://vball.fun/categories/game/"}],"tags":[{"name":"game","slug":"game","permalink":"http://vball.fun/tags/game/"},{"name":"daily","slug":"daily","permalink":"http://vball.fun/tags/daily/"}]},{"title":"How to view STL under GDB","slug":"view-stl-under-gdb","date":"2020-08-13T12:46:25.000Z","updated":"2021-12-10T06:23:57.228Z","comments":true,"path":"2020/08/13/view-stl-under-gdb/","link":"","permalink":"http://vball.fun/2020/08/13/view-stl-under-gdb/","excerpt":"","text":"There are two methods to view STL types under GDB.From Zhangxu Method 1: gdb-stl-viewsgdb-stl-views is a set of GDB macros that can display the contents of many STL containers: list, vector, map, multimap, set, multiset, dequeue, stack, queue, priority_queue, bitset, string, and widestring. You can download it LINK1 LINK2 or at end of file LINK Tutorials and an alternative download are hosted at here. Enable MarcoTwo ways to enable this Marco: copy the content in stl-views-1.0.3.gdb to to ~/.gdbinit source path/to/stl-views-1.0.3.gdb in gdb anytime before you want to use it. In this way you will need to source it every time after open gdb Here is an example after Macro is loaded: Method 2: Python printerGDB7.0 or higer version include support for writing pretty-printers in Python. Check-out the latest Python libstdc++ printers to a place on your machineIn a local directory, clone gcc code, Then you can find SomeLocalDir/gcc/libstdc++-v3/python/libstdcxx/v6/printers.py 1git clone https://gcc.gnu.org/git/gcc.git SomeLocalDir Add the following to your ~/.gdbinit.The path needs to match where the python module above was checked-out. So if checked out to: SomeLocalDir, the path would be as written in the example: 123456pythonimport syssys.path.insert(0, &#x27;SomeLocalDir/gcc/libstdc++-v3/python&#x27;)from libstdcxx.v6.printers import register_libstdcxx_printersregister_libstdcxx_printers (None)end Once loaded, STL classes that the printers support should printed in a more human-readable format. To print the classes in the old style, use the /r (raw) switch in the print command (i.e., print /r foo). This will print the classes as if the Python pretty-printers were not loaded. Here is an example after the Python printer is loaded: Reference Linkshttps://sourceware.org/gdb/wiki/STLSupport https://gcc.gnu.org/git.html some links in Chinese(mainly translation of above link): https://www.xuebuyuan.com/817423.html https://www.cnblogs.com/yylingyao/p/6747589.html db_init_stl_view123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696# # STL GDB evaluators/views/utilities - 1.03## The new GDB commands: # are entirely non instrumental # do not depend on any &quot;inline&quot;(s) - e.g. size(), [], etc# are extremely tolerant to debugger settings# # This file should be &quot;included&quot; in .gdbinit as following:# source stl-views.gdb or just paste it into your .gdbinit file## The following STL containers are currently supported:## std::vector&lt;T&gt; -- via pvector command# std::list&lt;T&gt; -- via plist or plist_member command# std::map&lt;T,T&gt; -- via pmap or pmap_member command# std::multimap&lt;T,T&gt; -- via pmap or pmap_member command# std::set&lt;T&gt; -- via pset command# std::multiset&lt;T&gt; -- via pset command# std::deque&lt;T&gt; -- via pdequeue command# std::stack&lt;T&gt; -- via pstack command# std::queue&lt;T&gt; -- via pqueue command# std::priority_queue&lt;T&gt; -- via ppqueue command# std::bitset&lt;n&gt; -- via pbitset command# std::string -- via pstring command# std::widestring -- via pwstring command## The end of this file contains (optional) C++ beautifiers# Make sure your debugger supports $argc## Simple GDB Macros writen by Dan Marinescu (H-PhD) - License GPL# Inspired by intial work of Tom Malnar, # Tony Novac (PhD) / Cornell / Stanford,# Gilad Mishne (PhD) and Many Many Others.# Contact: dan_c_marinescu@yahoo.com (Subject: STL)## Modified to work with g++ 4.3 by Anders Elton# Also added _member functions, that instead of printing the entire class in map, prints a member.## std::vector&lt;&gt;#define pvector if $argc == 0 help pvector else set $size = $arg0._M_impl._M_finish - $arg0._M_impl._M_start set $capacity = $arg0._M_impl._M_end_of_storage - $arg0._M_impl._M_start set $size_max = $size - 1 end if $argc == 1 set $i = 0 while $i &lt; $size printf &quot;elem[%u]: &quot;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end if $argc == 2 set $idx = $arg1 if $idx &lt; 0 || $idx &gt; $size_max printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\\n&quot;, $size_max else printf &quot;elem[%u]: &quot;, $idx p *($arg0._M_impl._M_start + $idx) end end if $argc == 3 set $start_idx = $arg1 set $stop_idx = $arg2 if $start_idx &gt; $stop_idx set $tmp_idx = $start_idx set $start_idx = $stop_idx set $stop_idx = $tmp_idx end if $start_idx &lt; 0 || $stop_idx &lt; 0 || $start_idx &gt; $size_max || $stop_idx &gt; $size_max printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\\n&quot;, $size_max else set $i = $start_idx while $i &lt;= $stop_idx printf &quot;elem[%u]: &quot;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end end if $argc &gt; 0 printf &quot;Vector size = %u\\n&quot;, $size printf &quot;Vector capacity = %u\\n&quot;, $capacity printf &quot;Element &quot; whatis $arg0._M_impl._M_start endenddocument pvector Prints std::vector&lt;T&gt; information. Syntax: pvector &lt;vector&gt; &lt;idx1&gt; &lt;idx2&gt; Note: idx, idx1 and idx2 must be in acceptable range [0..&lt;vector&gt;.size()-1]. Examples: pvector v - Prints vector content, size, capacity and T typedef pvector v 0 - Prints element[idx] from vector pvector v 1 2 - Prints elements in range [idx1..idx2] from vectorend ## std::list&lt;&gt;#define plist if $argc == 0 help plist else set $head = &amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 2 printf &quot;elem[%u]: &quot;, $size p *($arg1*)($current + 1) end if $argc == 3 if $size == $arg2 printf &quot;elem[%u]: &quot;, $size p *($arg1*)($current + 1) end end set $current = $current._M_next set $size++ end printf &quot;List size = %u \\n&quot;, $size if $argc == 1 printf &quot;List &quot; whatis $arg0 printf &quot;Use plist &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the list.\\n&quot; end endenddocument plist Prints std::list&lt;T&gt; information. Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx Examples: plist l - prints list size and definition plist l int - prints all elements and list size plist l int 2 - prints the third element in the list (if exists) and list sizeenddefine plist_member if $argc == 0 help plist_member else set $head = &amp;$arg0._M_impl._M_node set $current = $arg0._M_impl._M_node._M_next set $size = 0 while $current != $head if $argc == 3 printf &quot;elem[%u]: &quot;, $size p (*($arg1*)($current + 1)).$arg2 end if $argc == 4 if $size == $arg3 printf &quot;elem[%u]: &quot;, $size p (*($arg1*)($current + 1)).$arg2 end end set $current = $current._M_next set $size++ end printf &quot;List size = %u \\n&quot;, $size if $argc == 1 printf &quot;List &quot; whatis $arg0 printf &quot;Use plist_member &lt;variable_name&gt; &lt;element_type&gt; &lt;member&gt; to see the elements in the list.\\n&quot; end endenddocument plist_member Prints std::list&lt;T&gt; information. Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx Examples: plist_member l int member - prints all elements and list size plist_member l int member 2 - prints the third element in the list (if exists) and list sizeend## std::map and std::multimap#define pmap if $argc == 0 help pmap else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf &quot;Map &quot; whatis $tree printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\\n&quot; end if $argc == 3 while $i &lt; $tree_size set $value = (void *)($node + 1) printf &quot;elem[%u].left: &quot;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p *($arg2*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 4 set $idx = $arg3 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &quot;elem[%u].left: &quot;, $i p *($arg1*)$value set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p *($arg2*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\\n&quot;, $ElementsFound end if $argc == 5 set $idx1 = $arg3 set $idx2 = $arg4 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) set $valueLeft = *($arg1*)$value set $valueRight = *($arg2*)($value + sizeof($arg1)) if $valueLeft == $idx1 &amp;&amp; $valueRight == $idx2 printf &quot;elem[%u].left: &quot;, $i p $valueLeft printf &quot;elem[%u].right: &quot;, $i p $valueRight set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\\n&quot;, $ElementsFound end printf &quot;Map size = %u\\n&quot;, $tree_size endenddocument pmap Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well. Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap m - prints map size and definition pmap m int int - prints all elements and map size pmap m int int 20 - prints the element(s) with left-value = 20 (if any) and map size pmap m int int 20 200 - prints the element(s) with left-value = 20 and right-value = 200 (if any) and map sizeenddefine pmap_member if $argc == 0 help pmap_member else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf &quot;Map &quot; whatis $tree printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\\n&quot; end if $argc == 5 while $i &lt; $tree_size set $value = (void *)($node + 1) printf &quot;elem[%u].left: &quot;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p (*($arg3*)$value).$arg4 if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 6 set $idx = $arg5 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &quot;elem[%u].left: &quot;, $i p (*($arg1*)$value).$arg2 set $value = $value + sizeof($arg1) printf &quot;elem[%u].right: &quot;, $i p (*($arg3*)$value).$arg4 set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\\n&quot;, $ElementsFound end printf &quot;Map size = %u\\n&quot;, $tree_size endenddocument pmap_member Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well. Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s) Examples: pmap_member m class1 member1 class2 member2 - prints class1.member1 : class2.member2 pmap_member m class1 member1 class2 member2 lvalue - prints class1.member1 : class2.member2 where class1 == lvalueend## std::set and std::multiset#define pset if $argc == 0 help pset else set $tree = $arg0 set $i = 0 set $node = $tree._M_t._M_impl._M_header._M_left set $end = $tree._M_t._M_impl._M_header set $tree_size = $tree._M_t._M_impl._M_node_count if $argc == 1 printf &quot;Set &quot; whatis $tree printf &quot;Use pset &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the set.\\n&quot; end if $argc == 2 while $i &lt; $tree_size set $value = (void *)($node + 1) printf &quot;elem[%u]: &quot;, $i p *($arg1*)$value if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end end if $argc == 3 set $idx = $arg2 set $ElementsFound = 0 while $i &lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &quot;elem[%u]: &quot;, $i p *($arg1*)$value set $ElementsFound++ end if $node._M_right != 0 set $node = $node._M_right while $node._M_left != 0 set $node = $node._M_left end else set $tmp_node = $node._M_parent while $node == $tmp_node._M_right set $node = $tmp_node set $tmp_node = $tmp_node._M_parent end if $node._M_right != $tmp_node set $node = $tmp_node end end set $i++ end printf &quot;Number of elements found = %u\\n&quot;, $ElementsFound end printf &quot;Set size = %u\\n&quot;, $tree_size endenddocument pset Prints std::set&lt;T&gt; or std::multiset&lt;T&gt; information. Works for std::multiset as well. Syntax: pset &lt;set&gt; &lt;T&gt; &lt;val&gt;: Prints set size, if T defined all elements or just element(s) having val Examples: pset s - prints set size and definition pset s int - prints all elements and the size of s pset s int 20 - prints the element(s) with value = 20 (if any) and the size of send## std::dequeue#define pdequeue if $argc == 0 help pdequeue else set $size = 0 set $start_cur = $arg0._M_impl._M_start._M_cur set $start_last = $arg0._M_impl._M_start._M_last set $start_stop = $start_last while $start_cur != $start_stop p *$start_cur set $start_cur++ set $size++ end set $finish_first = $arg0._M_impl._M_finish._M_first set $finish_cur = $arg0._M_impl._M_finish._M_cur set $finish_last = $arg0._M_impl._M_finish._M_last if $finish_cur &lt; $finish_last set $finish_stop = $finish_cur else set $finish_stop = $finish_last end while $finish_first != $finish_stop p *$finish_first set $finish_first++ set $size++ end printf &quot;Dequeue size = %u\\n&quot;, $size endenddocument pdequeue Prints std::dequeue&lt;T&gt; information. Syntax: pdequeue &lt;dequeue&gt;: Prints dequeue size, if T defined all elements Deque elements are listed &quot;left to right&quot; (left-most stands for front and right-most stands for back) Example: pdequeue d - prints all elements and size of dend## std::stack#define pstack if $argc == 0 help pstack else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = $size - 1 while $i &gt;= 0 p *($start_cur + $i) set $i-- end printf &quot;Stack size = %u\\n&quot;, $size endenddocument pstack Prints std::stack&lt;T&gt; information. Syntax: pstack &lt;stack&gt;: Prints all elements and size of the stack Stack elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop) Example: pstack s - prints all elements and the size of send## std::queue#define pqueue if $argc == 0 help pqueue else set $start_cur = $arg0.c._M_impl._M_start._M_cur set $finish_cur = $arg0.c._M_impl._M_finish._M_cur set $size = $finish_cur - $start_cur set $i = 0 while $i &lt; $size p *($start_cur + $i) set $i++ end printf &quot;Queue size = %u\\n&quot;, $size endenddocument pqueue Prints std::queue&lt;T&gt; information. Syntax: pqueue &lt;queue&gt;: Prints all elements and the size of the queue Queue elements are listed &quot;top to bottom&quot; (top-most element is the first to come on pop) Example: pqueue q - prints all elements and the size of qend## std::priority_queue#define ppqueue if $argc == 0 help ppqueue else set $size = $arg0.c._M_impl._M_finish - $arg0.c._M_impl._M_start set $capacity = $arg0.c._M_impl._M_end_of_storage - $arg0.c._M_impl._M_start set $i = $size - 1 while $i &gt;= 0 p *($arg0.c._M_impl._M_start + $i) set $i-- end printf &quot;Priority queue size = %u\\n&quot;, $size printf &quot;Priority queue capacity = %u\\n&quot;, $capacity endenddocument ppqueue Prints std::priority_queue&lt;T&gt; information. Syntax: ppqueue &lt;priority_queue&gt;: Prints all elements, size and capacity of the priority_queue Priority_queue elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop) Example: ppqueue pq - prints all elements, size and capacity of pqend## std::bitset#define pbitset if $argc == 0 help pbitset else p /t $arg0._M_w endenddocument pbitset Prints std::bitset&lt;n&gt; information. Syntax: pbitset &lt;bitset&gt;: Prints all bits in bitset Example: pbitset b - prints all bits in bend## std::string#define pstring if $argc == 0 help pstring else printf &quot;String \\t\\t\\t= \\&quot;%s\\&quot;\\n&quot;, $arg0._M_data() printf &quot;String size/length \\t= %u\\n&quot;, $arg0._M_rep()._M_length printf &quot;String capacity \\t= %u\\n&quot;, $arg0._M_rep()._M_capacity printf &quot;String ref-count \\t= %d\\n&quot;, $arg0._M_rep()._M_refcount endenddocument pstring Prints std::string information. Syntax: pstring &lt;string&gt; Example: pstring s - Prints content, size/length, capacity and ref-count of string send ## std::wstring#define pwstring if $argc == 0 help pwstring else call printf(&quot;WString \\t\\t= \\&quot;%ls\\&quot;\\n&quot;, $arg0._M_data()) printf &quot;WString size/length \\t= %u\\n&quot;, $arg0._M_rep()._M_length printf &quot;WString capacity \\t= %u\\n&quot;, $arg0._M_rep()._M_capacity printf &quot;WString ref-count \\t= %d\\n&quot;, $arg0._M_rep()._M_refcount endenddocument pwstring Prints std::wstring information. Syntax: pwstring &lt;wstring&gt; Example: pwstring s - Prints content, size/length, capacity and ref-count of wstring send ## C++ related beautifiers (optional)#set print pretty onset print object onset print static-members onset print vtbl onset print demangle onset demangle-style gnu-v3set print sevenbit-strings off","categories":[{"name":"gnu","slug":"gnu","permalink":"http://vball.fun/categories/gnu/"}],"tags":[{"name":"gdb","slug":"gdb","permalink":"http://vball.fun/tags/gdb/"},{"name":"linux","slug":"linux","permalink":"http://vball.fun/tags/linux/"},{"name":"stl","slug":"stl","permalink":"http://vball.fun/tags/stl/"},{"name":"gnu","slug":"gnu","permalink":"http://vball.fun/tags/gnu/"}],"author":"Godvmxi"},{"title":"强大的.NET加壳工具——ILProtector","slug":"z_csdn_035_106739661","date":"2020-06-13T06:53:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2020/06/13/z_csdn_035_106739661/","link":"","permalink":"http://vball.fun/2020/06/13/z_csdn_035_106739661/","excerpt":"","text":"ILProtector是一个你的.NET应用的程序，为了保护您的软件的知识产权。 ILProtector保护你的.NET应用不被逆向工程、反编译和修改的网络代码。ILProtector将中间语言(MSIL)代码转换为一种特定的形式，它将不会被反汇编器或反编译器如IL DASM, .NET Reflector, ILSpy, dotPeek等识别。 （以上文字翻译自官方网站，emmmm，第一次人工翻译） 主要特性： Main Features Software code protection String encryption Integrity checking High performance Full reflection support for protected assemblies Supports .NET Framework 2.0/3.0/3.5/4.0/4.5/4.6/4.7 Supports Windows x32/x64 desktop applications Command-Line support Does not use undocumented features 官方提供了最新版的30天试用版供大家体验 如果你想使用注册版，你可以像我一样通过为Vgrsoft（该软件开发者）打广告的方式获得正式版的许可证 如何使用呢，很简单，官网都有详细的介绍 经过加壳后将会获得一个加过壳的exe程序和两个dll文件，如何整合起来可以参考这篇文章： 进我测试，主流的破壳软件都不能将它破解，真的很强大！！！","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"Hexo pure theme add mermaid support","slug":"hexo-pure-theme-add-mermaid-support","date":"2019-11-12T01:55:37.000Z","updated":"2021-12-10T06:23:57.220Z","comments":true,"path":"2019/11/12/hexo-pure-theme-add-mermaid-support/","link":"","permalink":"http://vball.fun/2019/11/12/hexo-pure-theme-add-mermaid-support/","excerpt":"","text":"一、说明开启 安装hexo插件1npm install hexo-filter-mermaid-diagrams -s 修改themes/pure/_config.yml 的 mermaid.on，开启主题支持1234567891011# Mermaid 支持mermaid: on: true cdn: //cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.3.1/mermaid.min.js options: # 更多配置信息可以参考 https://mermaidjs.github.io/#/mermaidAPI theme: &#x27;default&#x27; startOnLoad: true flowchart: useMaxWidth: false htmlLabels: true 添加主题渲染支持 themes/pure/layout/_common/head.ejs12345678&lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;forest&#x27;&#125;); &#125; &lt;/script&gt;&lt;% &#125; %&gt; 在markdown中，像写代码块一样写图表 二、示例以下示例源码可以在这边查看 本文源码更多示例可以查看官网：https://mermaidjs.github.io 1. flowchartgraph TD; A-->B; A-->C; B-->D; C-->D; graph TB c1-->a2 subgraph one a1-->a2 end subgraph two b1-->b2 end subgraph three c1-->c2 end 2.Sequence diagramssequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts prevail! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! 3.Class diagramsclassDiagram Animal NumLockOff NumLockOff --> NumLockOn : EvNumLockPressed NumLockOn --> NumLockOff : EvNumLockPressed -- [*] --> CapsLockOff CapsLockOff --> CapsLockOn : EvCapsLockPressed CapsLockOn --> CapsLockOff : EvCapsLockPressed -- [*] --> ScrollLockOff ScrollLockOff --> ScrollLockOn : EvCapsLockPressed ScrollLockOn --> ScrollLockOff : EvCapsLockPressed } 5.Gantt diagramsgantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h 6.Pie chart diagramspie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15","categories":[{"name":"tools","slug":"tools","permalink":"http://vball.fun/categories/tools/"},{"name":"hexo","slug":"tools/hexo","permalink":"http://vball.fun/categories/tools/hexo/"}],"tags":[{"name":"mermaid","slug":"mermaid","permalink":"http://vball.fun/tags/mermaid/"},{"name":"hexo","slug":"hexo","permalink":"http://vball.fun/tags/hexo/"}]},{"title":"C# 调用dll以及内置dll到exe内部","slug":"z_csdn_064_86572103","date":"2019-01-20T21:39:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2019/01/20/z_csdn_064_86572103/","link":"","permalink":"http://vball.fun/2019/01/20/z_csdn_064_86572103/","excerpt":"","text":"包含以下几块，如果没你需要的东西，可以继续赶路了 1： C# 对的dll的两种调用 2： dll包含到exe中 3：dll的函数原型获取 最近听闻人到中年的比尔盖茨收购了github并免费了私有的代码仓库，不由的给他点了一波赞，然后嘛就顺手把一个小项目用C#重写了一下，毕竟自从net开源了mono和.net core后，以后做gui也可以用C#这种快速预言了。哈哈，不用整天纠结在C++（QT）的各种内存泄漏等问题了。 额外吐槽一下C#反编译的问题，就你麻麻的没有加密，反编译出来就是源码。。。几个意思啊 现在开始正题， Part 1： C# call dll （这里的库没有广泛测试，各位DIY一下）。 Method 1： DLLimport 12345678910111213[DllImport(&quot;kernel32&quot;, CharSet = CharSet.Unicode, SetLastError = true)]internal static extern void FreeLibrary(IntPtr hModule);[DllImport(&quot;kernel32&quot;, CharSet = CharSet.Unicode, SetLastError = true)]internal static extern IntPtr LoadLibrary(string lpFileName);[DllImport(&quot;kernel32&quot;, CharSet = CharSet.Unicode, SetLastError = true)]internal static extern IntPtr GetProcAddress(IntPtr hModule, string lpFileName);//static load dll[DllImport(&quot;test.dll&quot;, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode, EntryPoint = &quot;MemPreAlloc&quot;)]public static extern int MemPreAlloc(byte[] plaintext, int plaintext_length, byte[] ciphertext, int ciphertext_length); 然后就这么简单。。哈哈 Method 2： 动态导入 有时需要动态调用dll中的函数，比如我，为了避免神奇的乙方多次搞丢dll的问题，需要把dll内嵌到exe的资源区段中，需要的时候释放出来（这个是改日聊内容）。 这里需要用到 IntPtr GetProcAddress(IntPtr hModule, string lpFileName)函数获取对应函数的地址，然后再使用C#的delegate委托方法调用。。其实感觉委托就是C语言中的函数申明。。。(C#高手放过不专业的描述) 实现逻辑如下： 1： 声明待导出函数的原型（C#变量对应问题，请自行百度） 2：打开dll (LoadLibrary) 3: 获取函数地址，通过Marshal.GetDelegateForFunctionPointer 函数对函数进行类型转换到目标的委托方法 4： 自己调用了。。 上代码： 12345678910//1：委托函数的类型声明，感觉等同于C语言函数指针的声明delegate int _DeleGateMemPreAlloc(byte[] plaintext, int plaintext_length, byte[]);/:委托函数的实例化_DeleGateMemPreAlloc MemPreAlloc;//委托函数的赋值DllInvoke dllInvoke = new DllInvoke(SECUREDLL);//这个类看下边哈。。。包含打开dll,获取函数MemPreAlloc = (_DeleGateMemPreAlloc)dllInvoke.Invoke(&quot;MemPreAlloc&quot;, typeof(_DeleGateMemPreAlloc)); 这里有两个大坑导致 C# 不能导出dll中的函数地址，没经验没办法，记录下来给大家分享： 1： 调用目标程序的类型需要和dll一致，如x86，x64必须一致，至于x64能不能call x86，你们自己测试吧，理论应该可以的 2：LoadLibrary 功能不能和调用函数在同一个文件中。。原因母鸡，解决方法就是对LoadLibrary 进行一层包装，说白了定时定义一个类包起来。。。上代码不BB DllInvoke.cs： 然后就德芙巧克力一样的丝滑了。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Runtime.InteropServices;namespace DMT_AES_TOOL&#123; public class DllInvoke &#123; #region Win API [DllImport(&quot;kernel32.dll&quot;)] private extern static IntPtr LoadLibrary(string path); [DllImport(&quot;kernel32.dll&quot;)] private extern static IntPtr GetProcAddress(IntPtr lib, string funcName); [DllImport(&quot;kernel32.dll&quot;)] private extern static bool FreeLibrary(IntPtr lib); #endregion private IntPtr hLib; public DllInvoke(String DLLPath) &#123; hLib = LoadLibrary(DLLPath); &#125; ~DllInvoke() &#123; FreeLibrary(hLib); &#125; //将要执行的函数转换为委托 public Delegate Invoke(string APIName, Type t) &#123; IntPtr api = GetProcAddress(hLib, APIName); if (api == IntPtr.Zero) throw new ArgumentNullException(&quot;找不到img资源入口&quot;); else return (Delegate)Marshal.GetDelegateForFunctionPointer(api, t); &#125; &#125;&#125; 最后贴一个内置dll文件到exe内，并悄悄释放，然后调用的实现。 1： 我这里dll改名成test.img， 然后在C#工程中添加一个资源文件Resource1.resx 2： 释放dll资源到临时文件，这里直接上代码 LoadResource.cs 12345678910111213141516171819202122232425262728293031323334353637using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Reflection;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace DMT_AES_TOOL&#123; class LoadResource &#123; LoadResource() &#123; &#125; public static string Load() &#123; string tempFile = Path.GetTempFileName();//临时文件准尉 byte[] byDll = Resource1.test;//看这里看这里。我之前的文件是test.img这里直接就能获取到目标的byte[]数据了 File.WriteAllBytes(tempFile, byDll);//释放了dll到临时文件// Clipboard.SetDataObject(tempFile, true);// MessageBox.Show(&quot;temp resource file -&gt; &quot; + tempFile + &quot; size -&gt;&quot; + byDll.GetLength(0).ToString()); return tempFile;//文件释放出来给DllInvoke导出函数哈哈哈 &#125; ~LoadResource() &#123; &#125; &#125;&#125; 最后获取扒拉一下dll中函数名字的获取和原型的获取 名字比较简单： dll export viewer 原型获取，就需要动用大名鼎鼎的IDA了，这里安利一下看雪学院，工具都可以下载，也建议多看看。 打开dll，然后找找目标函数，然后双击进入，按一下F5 。。。不上图了。。自己看吧","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"VP9编解码标准知识总结－转载收集","slug":"z_csdn_040_81707199","date":"2018-08-15T01:39:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2018/08/15/z_csdn_040_81707199/","link":"","permalink":"http://vball.fun/2018/08/15/z_csdn_040_81707199/","excerpt":"","text":". How VP9 works, technical details &amp; diagrams Doom9 论坛关于VP9的讨论（链接） 技术书籍 《VP9 Bitstream ­ superframe and uncompressed header DRAFT 》 《VP9 Bitstream &amp; Decoding Process Specification》 vp9于vp8一样，最多支持3个参考帧：last frame(时间上前一帧) golden frame(时间上任一帧，用于视频背景的更新，可以用来克服帧丢失) altref frame(只用于参考，不显示，质量高于普通帧)。vp9中关键帧常用作 golden frame， golden frame质量较高，QP较小。vp9有两种类型的 altref frame：第一种是通过普通编码方式得到的；第二种是由多个未编码帧拼凑而成的，它的块可能来自不同的帧。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"ssh tunnel , ssh reverse proxy, ssh over ssh , ssh tunnel proxy 特殊网络打洞大法，突破变态网管审核","slug":"z_csdn_019_81019585","date":"2018-07-12T02:38:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2018/07/12/z_csdn_019_81019585/","link":"","permalink":"http://vball.fun/2018/07/12/z_csdn_019_81019585/","excerpt":"","text":"修改备注： config文件中的ProxyCommand中不需要= 大致起源是公司的网络审核超级严格，本地access美国server只能先使用link到审核服务器，然后vnc到中间服务器，然后再bbb。。。。总不能这边修改一行代码再去vnc上重新敲一遍吧。。。于是萌生了打洞的想法（操作完全违规，请参考员工离职手册，做好被fire的准备） 先描述几个概念： ssh tunnel ，简单来说就是利用ssh通讯协议做一个隧道，或者是洞让你进行数据通讯 ssh tunnel proxy 在ssh打开的洞里进行socks 5代理 ssh reverse proxy ，和第一个差不多，是从a–&gt;b 开洞，然后使用者从b-&gt;a 发起应用。 ssh over ssh , ssh 通讯是建立在另外一条ssh tunnel基础 网络环境嘛。。。很常见，我从A发起对B只能绕道C，还是VNC，可以想象跨洋访问的恐怖，画面刷新感人。 me -&gt; client A (ssh 443)—-X—-firewall | | |–&gt;C—-vnc————————————&gt;| public C (因为我们这里B能发起对A的连接（其实也有限制，22端口屏蔽。但是80和443开放，我就把A的ssh server端口改443了）， 我不再使用公网的C作为跳转，其实也就是多了一步而已) 下边开始干活： 第一步： 打通B-&gt;A的隧道（注意A的ssh server 端口是443，有意绕过监控为之）,通过在B上执行如下命令： 1ssh -p 443 -NR 0.0.0.0:2222:127.0.0.1:22 user_A@A 成功打通了B-&gt;A的连接，同时在A上监听端口2222，所有连接A:2222的连接都会转发到B:22 ,这时核心步骤已经完成。 为了避免连接挂掉，结合autossh自动重连： 1autossh -p 443 -M 2223 -NR 0.0.0.0:2222:127.0.0.1:22 user_A@A 第二步：A ssh 到 B, 注意此时地址是A的本机地址。 1ssh -P 2222 user_B@127.0.0.1 此刻你就可以用B做跳板access C,D,E ，然后在反复不断敲ssh命令中，手指开始生疼，在A的~/.ssh/config中添加一行： 1234host B hostname 127.0.0.1 port 2222 user user_B 每次只要ssh B,就可以登录B了。（什么密钥登录或者sshpass登录自己的百度。懒人一个） 另外数据复制蛋疼。。。于是需要扩大战果，实现更多好处 战果1： 利用B做代理给A上网（因为B是国外服务器，然后youtube什么的404有很多红利了） 1ssh -NfD 0.0.0.0:1080 -P 2222 user_B@127.0.0.1 然后本地打开了1080端口时能socks 5代理，浏览器配置代理什么的，自己百度 这里说明一下，如果不写0.0.0.0 ，1080端口只接受本机发起的连接，如果需要支持局域网其他client访问，可能需要增加一步，在A的/etc/ssh/sshd_config 中添加一句（懒得验证是否需要，大家可以留言告知我）： 1GatewayPorts yes 此刻其实我们的浏览器数据的http/https —&gt; ssh –&gt; ssh –&gt;404 , 简单的就是说socks over ssh 战果2 ： A直接ssh访问C，D, E（好处就是可以使用sftp，scp等命令直接复制数据。。。。我不会告诉你可以使用用mobaxterm和filezilla管理这些东西） 这里有三种思路， 1: ssh1 over ssh2 (此时ssh2已经是ssh over ssh) ，利用第一步打通的ssh隧道过日子， 核心命令 ： 1ProxyCommand=&quot;ssh -W %h:%p -P 2222 user_B@127.0.0.1&quot; 完整的命令是,同样支持sftp,scp： 1ssh -o ProxyCommand=&quot;ssh -W %h:%p -P 2222 user_B@127.0.0.1&quot; user_C@C 简化的用法就是A的~/.ssh/config中添加： 123456host C hostname server_C user user_C ProxyCommand ssh -W %h:%p -P 2222 user_B@127.0.0.1#这里修了一个坑。。。就是PorxyCommand后边不需要= 然后直接ssh C即可 2：ssh over socks ((此时socks已经是sock over ssh))，利用战果1开通的socks过日子，好处是很多第三方软件都支持socks，此时协议就不限于ssh了。 核心命令 ： 1ProxyCommand=&quot;nc -X 5 -x localhost:1080 %h %p&quot; 1完整的命令是,同样支持sftp,scp： 1ssh -o ProxyCommand=&quot;nc -X 5 -x localhost:1080 %h %p&quot; user_C@C 简化的用法就是A的~/.ssh/config中添加： 1234host C hostname server_C user user_C ProxyCommand nc -X 5 -x localhost:1080 %h %p 然后直接ssh C即可 3：监听A的特殊端口，直接转发数据到目标机（麻烦，但是也好用）,实现的效果是当连接到A的20567端口，自动转发到C的22端口。 1ssh -NfL 20567:C:22 -P 2222 user_B@127.0.0.1 此时执行如下命令就可以直接连接到C： 1ssh -P 20567 user_C@127.0.01 简化的用法就是A的~/.ssh/config中添加： 1234host C hostname 127.0.0.1 port 20567 user user_C 然后直接ssh C即可 至于上边提及的public C， 就是多中转一下，隧道套隧道，，俄罗斯套娃娃 今天看到一个居然CSDN乞讨的，也来凑一下热闹。。。看看能不能买包烟。。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"管道日了狗-while read line大坑","slug":"z_csdn_051_70763496","date":"2017-04-25T03:02:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2017/04/25/z_csdn_051_70763496/","link":"","permalink":"http://vball.fun/2017/04/25/z_csdn_051_70763496/","excerpt":"","text":"想着定义个全局变量,用sh 函数修改,结果遇到了管道的坑,先贴错误代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/bin/shHEIGHT=&quot;null&quot;WIDTH=&quot;default&quot;SRC_YUV=DEST_DIR=MAX_QP=MIN_QP=read_para_from_file()&#123; cat $1 | while read line ##划重点---&gt;管道的最后一个命令都是在子Shell中执行的。这意味着在子Shell中赋值的变量对父Shell是无效的。所以当我们将管道输出传送到一个循环结构，填入随后将要使用的变量，那么就会产生很多问题。一旦循环完成，其所依赖的变量就不存在了。 do echo $line t_name=`echo $line |awk -F &#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;` t_value=`echo $line |awk -F &#x27; &#x27; &#x27;&#123;print $2&#125;&#x27;` echo &quot;k-v :$t_name -&gt; $t_value&quot; if [ $t_name = &quot;width&quot; ] ; then echo &quot;1 -&gt;&quot;$WIDTH WIDTH=$t_value echo &quot;1 -&gt;&quot;$WIDTH continue fi if [ $t_name = &quot;height&quot; ] ; then echo &quot;2 -&gt;&quot;$HEIGHT HEIGHT=$t_value echo &quot;2 -&gt;&quot;$HEIGHT continue fi if [ $t_name = &quot;src_yuv&quot; ] ; then SRC_YUV=$t_value echo &quot;3 -&gt;&quot;$SRC_YUV continue fi if [ $t_name = &quot;dest_dir&quot; ] ; then DEST_DIR=$t_value echo &quot;4&quot; continue fi if [ $t_name = &quot;max_qp&quot; ] ; then MIN_QP=$t_value echo &quot;5&quot; continue fi if [ $t_name = &quot;min_qp&quot; ] ; then MAX_QP=$t_value echo &quot;6&quot; continue fi echo &quot;get nothing -&gt; &quot;$line done&#125;show_global_para()&#123; echo &quot;show global var -&gt;&quot; echo &quot;WIDTH -&gt; $WIDTH&quot; echo &quot;HEIGHT -&gt; $HEIGHT&quot; echo &quot;SRC_YUV -&gt; $SRC_YUV&quot; echo &quot;DEST_DIR -&gt; $DEST_DIR&quot; echo &quot;MAX_QP -&gt; $MAX_QP&quot; echo &quot;MIN_QP -&gt; $MIN_QP&quot;&#125;read_para_from_file $1show_global_para 1管道的最后一个命令都是在子Shell中执行的。这意味着在子Shell中赋值的变量对父Shell是无效的。所以当我们将管道输出传送到一个循环结构，填入随后将要使用的变量，那么就会产生很多问题。一旦循环完成，其所依赖的变量就不存在了。 修改后: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/bin/shHEIGHT=&quot;null&quot;WIDTH=&quot;default&quot;SRC_YUV=DEST_DIR=MAX_QP=MIN_QP=read_para_from_file()&#123; #cat $1 | while read line #lines=`cat $1` while read line ##划重点 do echo $line t_name=`echo $line |awk -F &#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;` t_value=`echo $line |awk -F &#x27; &#x27; &#x27;&#123;print $2&#125;&#x27;` echo &quot;k-v :$t_name -&gt; $t_value&quot; if [ $t_name = &quot;width&quot; ] ; then echo &quot;1 -&gt;&quot;$WIDTH WIDTH=$t_value echo &quot;1 -&gt;&quot;$WIDTH continue fi if [ $t_name = &quot;height&quot; ] ; then echo &quot;2 -&gt;&quot;$HEIGHT HEIGHT=$t_value echo &quot;2 -&gt;&quot;$HEIGHT continue fi if [ $t_name = &quot;src_yuv&quot; ] ; then SRC_YUV=$t_value echo &quot;3 -&gt;&quot;$SRC_YUV continue fi if [ $t_name = &quot;dest_dir&quot; ] ; then DEST_DIR=$t_value echo &quot;4&quot; continue fi if [ $t_name = &quot;max_qp&quot; ] ; then MIN_QP=$t_value echo &quot;5&quot; continue fi if [ $t_name = &quot;min_qp&quot; ] ; then MAX_QP=$t_value echo &quot;6&quot; continue fi echo &quot;get nothing -&gt; &quot;$line done &lt; $1 ##重定向&#125;show_global_para()&#123; echo &quot;show global var -&gt;&quot; echo &quot;WIDTH -&gt; $WIDTH&quot; echo &quot;HEIGHT -&gt; $HEIGHT&quot; echo &quot;SRC_YUV -&gt; $SRC_YUV&quot; echo &quot;DEST_DIR -&gt; $DEST_DIR&quot; echo &quot;MAX_QP -&gt; $MAX_QP&quot; echo &quot;MIN_QP -&gt; $MIN_QP&quot;&#125;read_para_from_file $1show_global_para","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"遍历文件和文件夹oswalk","slug":"z_csdn_007_53069881","date":"2016-11-07T04:02:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2016/11/07/z_csdn_007_53069881/","link":"","permalink":"http://vball.fun/2016/11/07/z_csdn_007_53069881/","excerpt":"","text":"懂oswalk的就不要笑我了,我只是随笔记下之前的工作 执行效果类似于linux tree 命令, 遍历所有的文件,按照需求进行处理 12345678910111213141516171819import os, fnmatchdef all_files(root, patterns = &#x27;*&#x27;, single_level = False, yield_folders=False): patterns = patterns.split(&#x27;;&#x27;) for path, subdirs, files in os.walk(root): if yield_folders: files.extend(subdirs) files.sort() for name in files: for pattern in patterns: if fnmatch.fnmatch(name, pattern): yield os.path.join(path,name) break if single_level: breakif __name__ == &#x27;__main__&#x27;: for path in all_files(&#x27;/home/dan/ownCloud/Multimedia/GPU/new/GPU&#x27;,&#x27;*.py;*html;*pdf&#x27;): print path","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"python 发送邮件,支持邮件内容定义","slug":"z_csdn_062_53069439","date":"2016-11-07T03:49:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2016/11/07/z_csdn_062_53069439/","link":"","permalink":"http://vball.fun/2016/11/07/z_csdn_062_53069439/","excerpt":"","text":"很久很久以前的事情了,今天整理发现一团代码,扔生来吧 花了很多搞了gerrit 服务docker化, 账户添加完毕,老大说你给他们每个人发个邮件通知,另外把邮件内容写的漂亮点,格式化一下,顺便把使用向导镐一下,使用向导中直接使用目标的用户名密码…..—囧…..几十号人,挨个发邮件,顺便把用户名密码更新一进去,死人的会. 功能: 1:从邮件用户名列表读取用户名和密码 2: 载入邮件header信息 3: 载入email内容信息,并替换其中的关键字为对应的用户名和密码 so ,写个代码吧, 载入一个邮件模板,然后替换其中的用户名密码标志,按照用户名挨个发呗.. 直接贴代码了 发送代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#!/usr/bin/env python# -*- coding: utf-8 -*-#导入smtplib和MIMETextimport smtplibfrom email.mime.text import MIMETextimport base64import sysfrom optparse import OptionParserimport codecsimport timemailto_list=[&quot;bright.jiang@infotm.com&quot;,&quot;sam.zhou@infotm.com&quot;]########smtp setting#############mail_host=&quot;smtp.exmail.qq.com&quot;mail_user=&quot;xxx@xxx.com&quot;mail_pass=&quot;xxx&quot;mail_postfix=&quot;xxx.com&quot;######################def send_mail(to_list,sub,content,type=&#x27;html&#x27;): &#x27;&#x27;&#x27; to_list:发给谁 sub:主题 content:内容 send_mail(&quot;aaa@126.com&quot;,&quot;sub&quot;,&quot;content&quot;) &#x27;&#x27;&#x27; me=mail_user+&quot;&quot; msg = MIMEText(content,_subtype=type,_charset=&#x27;UTF-8&#x27;) msg[&#x27;Subject&#x27;] = sub msg[&#x27;From&#x27;] = me msg[&#x27;To&#x27;] = &quot;;&quot;.join(to_list) try: s = smtplib.SMTP() print(&quot;@@!@@&quot;) print s.connect(mail_host) print(&quot;@@!@@&quot;) print s.login(mail_user,mail_pass) print(&quot;@@!@@&quot;) s.sendmail(me, to_list, msg.as_string()) s.close() return True except Exception, e: print(&quot;@@!@@&quot;) print str(e) return Falsedef get_email_title(file) : try : fd = codecs.open(file,&#x27;r&#x27;,&#x27;UTF-8&#x27;) data = fd.read() fd.close() except : print(&quot;read mail title error&quot;) sys.exit(0) return datadef get_email_content_template(file) : try : fd = open(file,&#x27;r&#x27;) data = fd.read() fd.close() except : print(&quot;read mail content error&quot;) sys.exit(0) return datadef get_user_list(file): try : fd = open(file,&#x27;r&#x27;) data = fd.readlines() fd.close() print(type(data) ) except : print(&quot;read user list error&quot;) sys.exit(0) userPass = [] for line in data : if len(line) == 0 : break if line[0] in [&#x27;#&#x27;,&#x27; &#x27;,&#x27;\\n&#x27;] : continue userPass.append(line.split() ) return userPassdef update_email_from_template(template,userPass): print(type(userPass[0])) temp= userPass[0].split(&quot;.&quot;) big_name = &quot;&quot;.join([temp[0][0:1].upper(),temp[0][1:],&quot; &quot;,temp[1][0:1].upper(),temp[1][1:] ] ) print(big_name) template = template.replace(&quot;##USER_NAME&quot;,userPass[0]).replace(&quot;##USER_PASS&quot;,userPass[1]).replace(&quot;##USER_FULL&quot;,big_name) return templateif __name__ == &#x27;__main__&#x27;: parser = OptionParser(usage=&quot;usage:%prog [optinos] filepath&quot;) parser.add_option(&quot;-u&quot;, &quot;--userfile&quot;, action = &quot;store&quot;, type = &#x27;str&#x27;, dest = &quot;userFile&quot;, default = &quot;user.lst&quot;, help=&quot;user list file ,will delete all users not include in the file and update the password in the file&quot; ) parser.add_option(&quot;-t&quot;, &quot;--title&quot;, action = &quot;store&quot;, type = &#x27;str&#x27;, dest = &quot;title&quot;, default = &quot;title.t&quot;, help = &quot;email tile template&quot; ) parser.add_option(&quot;-c&quot;, &quot;--content&quot;, action = &quot;store&quot;, type = &#x27;str&#x27;, dest = &quot;content&quot;, default = &quot;mail.t&quot;, help = &quot;mail content template&quot; ) (options, args) = parser.parse_args() userList = get_user_list(options.userFile) print (userList) mail_title = get_email_title(options.title) mail_content = get_email_content_template(options.content) for user in userList : print user send_user = &quot;%s@infotm.com&quot;%(user[0]) content = update_email_from_template(mail_content,user)## break print(&#x27;begin send&#x27;) if send_mail([send_user ],mail_title,content): print &quot;send to %s ok&quot; %(user[0]) else: print &quot;send to %s fail&quot; %(user[0]) 收件人列表: 12345678910111213#user password file ,just edit it ,will update new password to the passwd file#format :user password ,no space in the start char#left password empty ,will generate randon password#tools developed by Bright.Jiang##BSP leader#warits.wang 236890##BSP#bright.jiang 098765#sam.zhou 099032 邮件主题: 1Gerrit服务器升级通知 邮件内容: 1234567891011121314151617181920212223242526272829303132Dear All : 为提升Gerrit服务器稳定性以及满足空间的需求，我们将从11月16日（下周一）开始统一切换到新服务器。新服务器的代码为旧服务器11/14日最新的版本。为保证代码统一，原服务器将同时停用。届时请大家花几分钟时间重新配置自已的Gerrit环境。 1. 使用以下用户名和密码登录新的Gerrit服务器: http://gerrit.in.infotm.com . 新的用户名密码为：##USER_NAME ##USER_PASS 2. 点击右上角Anonymous Coward -&gt; Settings -&gt; Contact Information，添写自己的个人信息，如##USER_FULL，(统一格式：英文名空格姓，首字母大写)。点击Register New Email，添写自己的邮箱：##USER_NAME@infotm.com(注意，请使用公司新邮箱)，最后点击Save Changes 3. 添加SSH Public Key，左边选则SSH Public Keys，执行命令 $cat ~/.ssh/id_rsa.pub 复制全部内容到gerrit ssh key文本框中，点击Add。 如果没有id_rsa.pub，使用以下命令生成： $ ssh-keygen -t rsa -C &quot;##USER_NAME@infotm.com&quot; 4. 修改本地git配置：$ git config --global user.name &quot;##USER_NAME&quot; $ git config --global user.email &quot;##USER_NAME@infotm.com&quot; 5. 更新本地repo，需要使用新的repo地址重新repo init ， 常用的repo地址可以从Wiki上检索：常用Repo地址 6. 常见的repo使用的错误，也会在wiki上不定期更新，欢迎各位参阅和修订，也欢迎 大家把工作中的经验总结更新到Wiki页面。Enjoy It!Gerrit Admin 仅作参考,仅作收藏,不惜勿喷","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"FFMPEG Tips (1) 如何打印日志","slug":"z_csdn_016_52980916","date":"2016-10-30T19:21:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2016/10/30/z_csdn_016_52980916/","link":"","permalink":"http://vball.fun/2016/10/30/z_csdn_016_52980916/","excerpt":"","text":"由于如今的工作比以前忙了，已经有好些日子没有分享技术博文了，还是得继续坚持下去。鉴于如今视频直播如此火爆，那就选个主题，聊聊播放器、聊聊 FFMPEG 那些事吧。 FFMPEG 是个好东西，可以说目前市面上的任何一款”通用型”播放器，都离不开 FFMPEG，因为没有什么其他的库比它支持的格式更加全面了。 这里首先致敬一下雷神，博客地址：《雷霄骅的专栏》，分享了很多音视频方面的技术文章、开源代码以及 FFMPEG 源码的分析，无论对入门者还是资深开发，都有很大的价值。 我要写的主题，与雷神不同，我会测重介绍使用 FFMPEG 开发播放器过程中的一些比较基础的小经验或者说开发笔记，因此，使用 Tips 这个单词，意味小技巧、小帖士，因此，本系列的目标读者是 FFMPEG 的入门者，也欢迎路过的高手们能对分享的内容给出宝贵的建议和意见。 本文则从开发和调试程序最重要的一点：打 LOG 说起，看看基于 FFMPEG 开发，如何打印 LOG，如何设置日志的级别。 FFMPEG 打印日志的函数 FFMPEG 有一套自己的日志系统，它使用 av_log() 函数来打印日志，其声明位于： 它的函数原型如下： 参数含义： avcl：指定一个包含 AVClass 的结构体，指定该 log 所属的结构体，如 AVFormatContext、AVCodecContext 等等，可以设置为 NULL level：log 的级别，下面给出可选的值 fmt：跟 c 语言的 printf() 定义一样 FFMPEG 日志级别 LOG 的级别是一个 int 类型，其可选的数值及其含义如下： FFMPEG 设置和获取当前日志级别 由一个全局的变量来控制哪个级别及以上的日志会打印输出，设置和获取这个全局变量的函数如下： 例如，当全局的日志级别设置为 AV_LOG_ERROR，那么凡是日志级别高于 AV_LOG_ERROR 的日志，都不会被打印出来。 FFMPEG 日志打印函数的使用示例 假设要打印 DEBUG 和 ERROR 级别的日志，用法示例如下： FFMPEG 日志打印函数的封装 当然，如果你觉得 av_log 用起来不是很顺手，你可以定义个宏封装下，例如： Android 中打印 FFMPEG 的日志 由于 FFMPEG 默认使用的是 printf 来打印日志，而 Android 系统有着一套自己的 LOG 系统，因此，需要让 FFMPEG 的日志重定向使用 Android 的日志系统，具体方法描述如下： 通过 FFMPEG 的 av_log_set_callback() 注册一个 LOG callback function，FFMPEG 就会把 LOG 打印功能重定向到 callback function 中，代码示例如下： 在代码初始化的地方调用一下 syslog_init() 后，就可以使用 av_log() 在 Android 平台输出调试日志了。 FFPlay 设置日志级别 平时自己写的播放器播放某些流播放有问题的话，也可以使用 ffplay 来对比调试一下，看看使用 ffplay 是否可以播放，报错信息是什么，ffplay 打开 DEBUG 日志输出的方法示例如下： -v 参数是用于配制 ffplay 的日志级别，其定义如下： 小结","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"android videoview","slug":"z_csdn_032_52919511","date":"2016-10-24T18:56:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2016/10/24/z_csdn_032_52919511/","link":"","permalink":"http://vball.fun/2016/10/24/z_csdn_032_52919511/","excerpt":"","text":"mark一下，免得忘记 项目需要验证android videoview对视频容器的支持，需要一个小demo ， android程序员各种墨迹，算了，自己动手，丰衣足食． 就顺手写了个小demo，遇到一个坑，ｓｄ卡权限，不说了，6.0 搞不定，直接切换sdk到4.0，哈哈，兼容就是好，直接权限就有了，可能需要卸载，不过不是问题 源码位置： https://github.com/godvmxi/VideoTest Android VideoView中getDuration()方法使用问题 调用setVideoPath之后,VideoView里的MediaPlayer还未处于prepared状态,因此得不到duration. 所以只要videoView.setOnPreparedListener()方法在该监听器中去获取值就行了. 功能嘛及其简单，遍历一个目录，选择播放其中的文件． package com.example.dan.videotest; import android.media.MediaPlayer;import android.net.Uri;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.view.textservice.TextInfo;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;import android.widget.VideoView; import org.w3c.dom.Text; import java.io.File; public class MainActivity extends AppCompatActivity { Button buttonList; Button buttonNext; Button buttonPlay; String TAG; int fileIndex; TextView textViewCurFile; TextView textViewFileList; File[] fileList; VideoView videoView; @Override protected void onCreate(Bundle savedInstanceState) &#123; TAG = new String(&amp;quot;VideoTest&amp;quot;); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); buttonList = (Button)findViewById(R.id.buttonList); buttonPlay = (Button)findViewById(R.id.buttonPlay); buttonNext = (Button)findViewById(R.id.buttonNext); textViewCurFile = (TextView)findViewById(R.id.textViewCurFile); textViewFileList = (TextView)findViewById(R.id.textViewFileList); videoView = (VideoView)findViewById(R.id.videoView); videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; Log.d(TAG, &amp;quot;onPrepared: &amp;quot; + mp.getDuration()); Toast.makeText(getApplicationContext(), &amp;quot;video length &amp;quot; +mp.getDuration(),1500).show(); &#125; &#125;); fileIndex = 0; fileList = new File[]&#123;&#125;; textViewCurFile.setText(&amp;quot;Current file -&amp;gt; NULL&amp;quot;); textViewFileList.setText(&amp;quot;File list -&amp;gt; &amp;quot;); buttonList.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d(TAG, &amp;quot;onClick: &amp;quot;); //File fileDir = new File(&amp;quot;/mnt/sdcard/Movies&amp;quot;); File fileDir = new File(&amp;quot;/mnt/sdcard/Movies&amp;quot;); Log.d(TAG, &amp;quot;onClick: read -&amp;gt;&amp;quot;+ fileDir.canRead()); Log.d(TAG, &amp;quot;onClick: write -&amp;gt;&amp;quot;+ fileDir.canWrite()); fileList = fileDir.listFiles(); if(fileList.length &amp;gt; 0 ) &#123; String fileListString = new String(&amp;quot;File list -&amp;gt; &amp;quot;); for (int i = 0; i &amp;lt; fileList.length; i++) &#123; Log.d(TAG, &amp;quot;file list -&amp;gt; : &amp;quot; + fileList[i].toString()); fileListString = fileListString + &amp;quot;\\n&amp;quot; + fileList[i].toString(); &#125; fileIndex = 0; textViewFileList.setText(fileListString); textViewCurFile.setText(fileList.length + &amp;quot;:&amp;quot; + fileIndex + &amp;quot;-&amp;gt;&amp;quot; + fileList[fileIndex].toString()); &#125; else &#123; fileIndex = 0; fileList = new File[]&#123;&#125;; Toast.makeText(getApplicationContext(), &amp;quot;no file in target dir&amp;quot;,500).show(); String fileListString = new String(&amp;quot;File list -&amp;gt; NULL&amp;quot;); textViewFileList.setText(fileListString); textViewCurFile.setText(fileList.length+&amp;quot;:0-&amp;gt; NULL&amp;quot;); &#125; &#125; &#125;); buttonPlay.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //videoView.stopPlayback(); if(fileList.length &amp;gt; 0) &#123; String curFile = fileList[fileIndex].toString(); videoView.setVideoURI(Uri.parse(curFile)); videoView.start(); &#125; else &#123; Toast.makeText(getApplicationContext(), &amp;quot;no file in target dir&amp;quot;,1500).show(); &#125; &#125; &#125;); buttonNext.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if(fileList.length &lt;=&gt; NULL&amp;quot;); &#125; else &#123; fileIndex++; if(fileIndex &amp;gt;= fileList.length )&#123; Toast.makeText(getApplicationContext(), &amp;quot;back to first file&amp;quot;,500).show(); fileIndex = 0; &#125; textViewCurFile.setText(fileList.length+&amp;quot;:&amp;quot;+ (fileIndex+1) +&amp;quot;-&amp;gt;&amp;quot; + fileList[fileIndex].toString()); &#125; &#125; &#125;); &#125; }&lt;/=&gt; 布局如下： 1 权限： 1","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"AAC raw包增加ADTS头","slug":"z_csdn_030_52875107","date":"2016-10-20T01:33:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2016/10/20/z_csdn_030_52875107/","link":"","permalink":"http://vball.fun/2016/10/20/z_csdn_030_52875107/","excerpt":"","text":"AAC原始码流无法直接播放，一般需要封装为ADTS格式才能再次使用，本博主在android中用MediaCodec编码得到的AAC就是raw格式，为了保存为.aac格式，需要增加adts头，这样就可以通过vlc或者windows Media player直接播放了。现在把网上搜集的资料和代码总结一下，以备自己以后参考，也分享给有需要的同仁。 源码来自： http://stackoverflow.com/questions/18862715/how-to-generate-the-aac-adts-elementary-stream-with-android-mediacodec 实现函数： 1234567891011121314151617181920212223242526272829303132333435363738/** * Add ADTS header at the beginning of each and every AAC packet. * This is needed as MediaCodec encoder generates a packet of raw * AAC data. * * Note the packetLen must count in the ADTS header itself !!! . *注意，这里的packetLen参数为raw aac Packet Len + 7; 7 bytes adts header **/ private void addADTStoPacket(byte[] packet, int packetLen) &#123; int profile = 2; //AAC LC，MediaCodecInfo.CodecProfileLevel.AACObjectLC; int freqIdx = 5; //32K, 见后面注释avpriv_mpeg4audio_sample_rates中32000对应的数组下标，来自ffmpeg源码 int chanCfg = 2; //见后面注释channel_configuration，Stero双声道立体声 /*int avpriv_mpeg4audio_sample_rates[] = &#123; 96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350 &#125;; channel_configuration: 表示声道数chanCfg 0: Defined in AOT Specifc Config 1: 1 channel: front-center 2: 2 channels: front-left, front-right 3: 3 channels: front-center, front-left, front-right 4: 4 channels: front-center, front-left, front-right, back-center 5: 5 channels: front-center, front-left, front-right, back-left, back-right 6: 6 channels: front-center, front-left, front-right, back-left, back-right, LFE-channel 7: 8 channels: front-center, front-left, front-right, side-left, side-right, back-left, back-right, LFE-channel 8-15: Reserved */ // fill in ADTS data packet[0] = (byte)0xFF; packet[1] = (byte)0xF9; packet[2] = (byte)(((profile-1)&lt;&gt;2)); packet[3] = (byte)(((chanCfg&amp;3)&lt;&gt;11)); packet[4] = (byte)((packetLen&amp;0x7FF) &gt;&gt; 3); packet[5] = (byte)(((packetLen&amp;7)&lt; 以下理论转载自博客：http://wiki.multimedia.cx/index.php?title=ADTSAudio Data Transport Stream (ADTS) is a format, used by MPEG TS or Shoutcast to stream audio, usually AAC. StructureAAAAAAAA AAAABCCD EEFFFFGH HHIJKLMM MMMMMMMM MMMOOOOO OOOOOOPP (QQQQQQQQ QQQQQQQQ)Header consists of 7 or 9 bytes (without or with CRC). Letter Length (bits) DescriptionA 12 syncword 0xFFF, all bits must be 1B 1 MPEG Version: 0 for MPEG-4, 1 for MPEG-2C 2 Layer: always 0D 1 protection absent, Warning, set to 1 if there is no CRC and 0 if there is CRCE 2 profile, the MPEG-4 Audio Object Type minus 1F 4 MPEG-4 Sampling Frequency Index (15 is forbidden)G 1 private stream, set to 0 when encoding, ignore when decodingH 3 MPEG-4 Channel Configuration (in the case of 0, the channel configuration is sent via an inband PCE)I 1 originality, set to 0 when encoding, ignore when decodingJ 1 home, set to 0 when encoding, ignore when decodingK 1 copyrighted stream, set to 0 when encoding, ignore when decodingL 1 copyright start, set to 0 when encoding, ignore when decodingM 13 frame length, this value must include 7 or 9 bytes of header length: FrameLength = (ProtectionAbsent == 1 ? 7 : 9) + size(AACFrame)O 11 Buffer fullnessP 2 Number of AAC frames (RDBs) in ADTS frame minus 1, for maximum compatibility always use 1 AAC frame per ADTS frameQ 16 CRC if protection absent is 0 Usage in MPEG-TSADTS packet must be a content of PES packet. Pack AAC data inside ADTS frame, than pack inside PES packet, then mux by TS packetizer. Usage in ShoutcastADTS frames goes one by one in TCP stream. Look for syncword, parse header and look for next syncword after.","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"MP4文件两种格式AVC1和H264的区别及利用FFMPEG demux为h264码流事项","slug":"z_csdn_055_52875058","date":"2016-10-20T01:29:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2016/10/20/z_csdn_055_52875058/","link":"","permalink":"http://vball.fun/2016/10/20/z_csdn_055_52875058/","excerpt":"","text":"(一)首先，从原理上了解一下这2种格式的区别：AVC1 描述:H.264 bitstream without start codes.一般通过ffmpeg转码生成的视频，是不带起始码0×00000001的。H264 描述:H.264 bitstream with start codes.一般对于一下HDVD等电影的压制格式，是带有起始码0×00000001的。来源文档：http://msdn.microsoft.com/zh-cn/library/dd757808(v=vs.85).aspx(二)其次，通过VLC播放器，可以查看到具体的格式。打开视频后，通过菜单【工具】/【编解码信息】可以查看到【编解码器】具体格式，举例如下，编解码器信息：编码: H264 – MPEG-4 AVC (part 10) (avc1)编码: H264 – MPEG-4 AVC (part 10) (h264) (三)最后，分享一下ffmpeg demux MP4文件后，转换视频流为live555可直接使用的h264 ES流的经验和方法： 针对（avc1），av_read_frame后，取前四个字节为长度，把前四字节直接替换为0×00,0×00,0×00,0×01即可，但注意每个frame可以有多个NAUL： 123456789101112131415161718192021222324252627282930AVPacket pkt; AVPacket* packet = &amp;pkt; av_init_packet(packet); av_read_frame(ctx, packet); if(packet-&gt;stream_index == 0) &#123;//is video stream const char start_code[4] = &#123; 0, 0, 0, 1 &#125;; if(is_avc_ || memcmp(start_code, packet-&gt;data, 4) != 0) &#123;//is avc1 code, have no start code of H264 int len = 0; uint8_t *p = packet-&gt;data; is_avc_ = True; do &#123;//add start_code for each NAL, one frame may have multi NALs. len = ntohl(*((long*)p)); memcpy(p, start_code, 4); p += 4; p += len; if(p &gt;= packet-&gt;data + packet-&gt;size) &#123; break; &#125; &#125; while (1); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334bsfc_ = av_bitstream_filter_init(&quot;h264_mp4toannexb&quot;); if(pkt-&gt;stream_index == 0) &#123;//is video stream AVBitStreamFilterContext* bsfc = bsfc_; int a; while (bsfc) &#123; AVPacket new_pkt = *pkt; a = av_bitstream_filter_filter(bsfc, encode_ctx_, NULL, &amp;new_pkt.data, &amp;new_pkt.size, pkt-&gt;data, pkt-&gt;size, pkt-&gt;flags &amp; AV_PKT_FLAG_KEY); if(a == 0 &amp;&amp; new_pkt.data != pkt-&gt;data &amp;&amp; new_pkt.destruct) &#123; uint8_t *t = (uint8_t*)(new_pkt.size + FF_INPUT_BUFFER_PADDING_SIZE); //the new should be a subset of the old so cannot overflow if(t) &#123; memcpy(t, new_pkt.data, new_pkt.size); memset(t + new_pkt.size, 0, FF_INPUT_BUFFER_PADDING_SIZE); new_pkt.data = t; a = 1; &#125; else a = AVERROR(ENOMEM); &#125; if (a &gt; 0 &amp;&amp; pkt-&gt;data != new_pkt.data) &#123; av_free_packet(pkt); new_pkt.destruct = av_destruct_packet; &#125; else if (a &lt; 0) &#123; envir() &lt;&lt; &quot;!!!!!!!!!!av_bitstream_filter_filter failed&quot; &lt;&lt; &quot;,res=&quot; &lt;&lt; a &lt;&lt; &quot;\\n&quot;; &#125; *pkt = new_pkt; bsfc = bsfc-&gt;next; &#125; &#125;","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"C++11下编译错误 ISO C++ forbids declaration of ‘typeof’ with no type","slug":"z_csdn_069_52759752","date":"2016-10-08T03:08:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2016/10/08/z_csdn_069_52759752/","link":"","permalink":"http://vball.fun/2016/10/08/z_csdn_069_52759752/","excerpt":"","text":"参考https://code.google.com/p/google-breakpad/issues/detail?id=481 ISO C++ forbids declaration of ‘typeof’ with no type typedef ‘google_breakpad::typeof’ is initialized (use decltype instead) 因为 C++11 把关键字typeof改为decltype 了 so….","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"Mp4编码全介绍","slug":"z_csdn_066_52626641","date":"2016-09-22T04:06:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2016/09/22/z_csdn_066_52626641/","link":"","permalink":"http://vball.fun/2016/09/22/z_csdn_066_52626641/","excerpt":"","text":"容器格式允许你将不同种类的多媒体数据流（多为视频流和音频流）合并在一个单一的文件内。多媒体容器格式，就是我们熟知的AVI(.avi), MPEG(.mpg, .mpeg), Matroska(.mkv, .mka), OGM(.ogm), Quicktime(.mov),或Realmedia(.rm, .rmvb). MP4是遵循MPEG-4（ISO 14496-14）的官方容器格式定义的广义文件扩展名。它可以流媒体化并支持众多多媒体的内容（多音轨(multiple audio)、视频流(video)、字幕(subtitlestreams)、图片(pictures)、可变桢率(variable-framerates)、码率(bitrates)、采样率(samplerates)等）和高级内容(advanced content)（官方称之为”Richmedia”(超媒体)或”BIFS”(Binary Format for Scenes/二进制格式场景），类似2D和3D图形，动画、用户界面、类DVD菜单，上述这些AVI搞不定的东西。 MP4文件的扩展名用什么？ -.mp4：唯一的官方扩展名，支持所有音频和视频以及高级内容（或它们的混合） 其他相关的扩展名： .m4v：是.mp4文件的错误扩展名，由apple提出，支持视频+音频，m4v扩展名可以安全地更名为.mp4 .m4a：是.mp4文件的错误扩展名，由apple提出，只支持音频，m4a扩展名可以安全地更名为.mp4 .m4p：随iTunes发售的DRM(Digital Rights Management/数字版权保护技术)产权保护的文件，使用Apple开发的DRM sheme .m4e：由.sdp修改扩展名的来的文件，Envivio用其于流媒体播放。 .m4v, -.mp4v, -.cmp, -.divx, .-xvid, .264：raw的mpeg-4视频流（并非内含于mp4）。 .3gp, -.3g2：手机中使用的格式，其中储存的内容同样在.mp4未被定义（H.263, AMR(Adaptive Multi Rate/自适应多码率)）。 如何创建标准的MP4文件？简单的回答：参考doom9的MP4指南或NERO Recode2指南。 详细解答： 为了制作MP4文件，你应该优先使用MPEG-4标准下的音频/视频格式： MP4视频格式包括：MPEG-4 SP(Simple Profile/简单类)/ASP(Advanced Simple Profile/高级简单类)：xvid, divx5, 3ivx,ffmpeg/ffdshow, NeroDigital ASP…及MPEG-4 AVC/H.264：x264, NeroDigital AVC, Apple…还有MPEG-2, MPEG-1（不含Divx3/M$ MPEG4, WM9, RV9或VP6）.-doom9的质量比较测评：1 2 MP4音频格式包括：Advanced Audio Coding（AAC FAQ）：Quicktime/iTunes, Nero, Psytel, FAAC（binary）…（rjamorim的质量比较测评：1 2）和mp3, mp2, mp1, celp（语音）, TwinVQ（非常低的码率）, SAOL（midi）, ALS（无损） MP4字幕/文本格式：MPEG-4时标文本（见Q7） MP4图片格式：JPEG, PNG 使用下列的软件可以将遵循MPEG-4的内容Mux进MP4容器： GPAC的MP4box，命令行界面，支持AVC(Advanced Video Coding/进阶视频编码)，packed B-frames(打包B桢)，高级内容/BIFS，TTXT和章节（Doom9指南） MPEG4IP的mp4creator，命令行界面，能够混合AVC，但不要用于AVI及(packed) B-frames！ 3ivx mp4 muxer，dshow滤镜，可以在GraphEdit中使用，支持使用packed B-frames的avi，但不支持AVC（3ivx 指南） mp4UI，操作简单，软件基于MPEG4IP，不支持AVC，AVI及(packed) B-frames！（doom9指南） VideoLAN Client，支持AVC，不能用于packed B-frames ffmpeg，问题多，命令行界面，尤其不能用于AVC，AVI及(packed) B-frames！ IBM的Toolkit for MPEG-4，含基于Java的XMTBatch和/或AVGen（也是一个简易的版本） dvd2mp4GUI，mp4tool的GUI，可以简单的将多音轨及字幕（作为高级内容）混合进MP4 mp4tool/mp4edit，来自于ENST，类似于mp4box。mp4edit是mp4tool命令行软件的简易GUI版本 下面有一些”all-in-one”的MP4编码工具： Nero Recode2，使用ASP、AVC或AAC来编码MP4（Doom9指南），字幕是dvd的vob subs（图形字幕），包含dshow muxer Doom9的MeGUI，支持ASP（xvid, libavcodec）, AVC（xvid）和AAC（Besweet - Nero）编码 HDX4支持ASP和AAC Dicas的mpegable X4 live，操作简单，用dicas的MPEG-4的编码直接编码为mp4 Envivio的4coder支持MPEG-4 AAC, ASP/SP和AVC 以下工具可用来编辑MP4文件（如分割、追加合并）： MP4Box可以按照时间和尺寸分割MP4（AAC, ASP, AVC, TTXT, MPEG-1/2, 专用媒体流），提取部分及合并mp4 ulead的VideoStudio 8+ MPEG-4插件 Quicktime/Pro能够创建（编码，混合）和编辑（分割、合并）mp4文件，支持MPEG-4 Simple Profile, AAC, AVC 有没有可能将非MPEG-4标准的数据流放进MP4？可以，虽然我不认为这是个好主意。MPEG-4标准定义了如何将数据流放入MP4的方式。类似于AVI，数据流根据专用的FourCCs方式被放入AVI中；在MP4中，每一个数据流有一个”专用的轨道ID(private track ID)”。记住，没有一个播放器能够支持MP4中此类的数据流，只会简单地把它们忽略。除非你非常明确地要这样做。以下的数据流，不遵循MPEG-4标准，但已经能够被放入MP4中了。 Ogg Vorbis和Ogg Theora，使用MP4Box Ogg Vorbis，使用修订版的mp4creator Apple 的无损音频（ALAC/ALE - 不兼容MPEG-4 ALS），使用iTunes DVD图形字幕（Vobsubs），使用Nero Recode2 AMR语音，使用NEC e808/e616手机唯有等到了将来，我们才能知道此类的非公开数据流能否被广泛的接受和支持。。。 当我从avi中将MPEG-4视频混合进MP4时，有哪些事项是必须特别注意的？在做AVIs混合至MP4处理时，有一些潜在的问题。特别是编码中使用了B桢(b-frames/B-VOPs/bi-directional)。 “delay frames(桢延迟)”：由于一些编码（Xvid, Divx5）仍然使用旧的VFW界面会导致此问题。只有当使用VirtualDub/Mod编码且用了B桢时，就会自动丢桢。 “packed bitstream(打包的数据流)” ：因旧有容器格式AVI不支持储存B桢而产生。在DivX5中会用到PB（只有在一个连续B桢的设定情况下），以及新版本的XviD默认设置是使用PB的（处理时要确认PB选项没有被勾选），还有使用其他桢来打包B桢（点击这里了解更多关于B桢的详细介绍）。 3)”ctts”atom(节点)：当混合b桢进入MP4中必须写入的信息。4)”vol(音量)”：在avi的每个关键桢(keyframe)中都要写入，但现在在MP4中已和影片数据分离开了。 现在，只有3ivx mp4 muxer和GPAC的MP4Box可以正确的搞定上述问题。推荐只使用它们进行avi的转换，特别是那些使用packed bitstreams或者那种你不能确定是否使用了b桢设定/编码的avi。否则，你很可能不能够得到100%完全遵循标准的MP4文件！ transmux(转换并混合)时是否会对文件内容进行重编码？不会，这是个无损的处理过程，只是将媒体流从一个容器搬到MP4里。 我怎样才能将字幕混合进MP4？这里有三种方法可以实现： 相对于MPEG-1/2，MPEG-4标准定义有自己的文本流/字幕标准（基于ISO14496-17的MPEG-4的时标文本）。MP4的字幕格式是基于文本的（不是像DVD字幕那种基于图形），遵循UTF-8/16标准（含古斯拉夫语、阿拉伯语、中文字符等）。它支持所有的动态效果（滚动、色彩、卡拉ok效果等），且支持附加字体及流媒体化。MPEG-4 TTXT的制作，已被MP4box和Quicktime支持。回放时，可以使用Haali的MP4 dshow Parser, Osmo4, Realplayer和Quicktime（仅当放入.3gp文件中）。同样时VideoLan也支持。 Nero的Recode2可以用来在MP4中储存专用数据流（Q4），且可以轻易的、不加修改的将DVD中的图形字幕（vobsubs）提出并存入MP4中。回放此类的媒体流，可以使用Nero的滤镜、Haali的Parser、VideoLan（问题多）和一些硬件支持MP4的DVD播放器。 另一个基于MPEG-4标准储存字幕进MP4的方法是将字幕转换为XMT/BT文本格式，然后将它们编码为”高级内容”（BIFS binary格式）存入MP4中。这一方法可适用于任何字幕（使用mp4box或dvd2mp4gui，例如转换SRT字幕）。回放这些高级内容，你需要可以支持此类内容的滤镜/播放器（见Q12）。 我如何将章节放入MP4文件中？章节的存储也可以使用高级内容实现（例如创建一个目录菜单），但Nero使用了另一个方法。它使用了MP4中的一个特性：称为”用户空间”(user space/udta atom)。它允许在MP4中附加任何你想的东西。（例如，iTunes使用udta atom在mp4中储存标签和CD/DVD封面（”coverart”））。你可以使用Nero Recode2在编码mp4过程中自动插入章节信息，或者用MP4Box和record2的MP4 directshow muxer filter在已存在的mp4文件中添加章节信息。（例如在GraohEdit中使用此滤镜）。关于播放器，如果不能识别在udta中储存的章节信息，则会简单的忽略掉。你需要一个可以搞定此特殊章节信息的播放器或滤镜。（例如，Gabest, Haali, Nero或3ivx）。 我如何对MP4文件进行编排创作（例如创建类DVD的菜单）？有没有例子？基本上编排创作应”手动”编写一个文本的语言格式，称为XMT或bt（基于VRML(Virtual Reality Modeling Language/虚拟现实建模语言)，就像我们熟知的Flash），一种能够把它作为binary格式（称为BIFS）编码/编译入mp4（免费的编码器为mp4box, mp4tool或XMTBatch）。现在已经有一些面向MP4编排创作的GUI了，使得这一过程变得很方便。例如IBM, AVIPIX, Envivio, Mindego, iVAST, Digimax或Etri，但都未向大众开放。 所以，如果你想亲自编排创作MP4，除了编辑一个BT/XMT的脚本外没有别的办法。感谢GPAC的家伙们，现在已经有了关于这个处理方法的指南（英文版、法文版），这将对你有不小的帮助。为了使这个过程更简单，我创作了一个简单的脚本工具，命名为MP4menu，现在已经支持DVD菜单可以提供的所有特性。你可以按照自己的需求使用（指南）。 如果你想看一下实例以了解有什么别的可以放入MP4中，看一下这个小的含视频的菜单样本。但是MPEG-4系统还能提供2D和3D的动画效果（想一下玩具总动员和海底总动员这些影片），看一下这个小的2d 动画样本（不含视频流）。确认你使用的是MPEG-4系统支持的播放器，如GPAC Osmo4 player，来观看这些样本。 我如何才能在MP4文件中使用可变形重设尺寸(anamorphic resize)？MPEG-4标准崇尚”多才能”，能够满足大众的各种需求。它提供了三种可能性： 码流方面：这可能是最具可行性且最大众化的方法。使用可以设定PAR(pixel aspect ratio/像素宽高比)的编码（例如3ivx, ffmpeg/ffvfw, xvid）。然后使用任一种MP4的Muxer工具（例如3ivx mp4 mixer, MP4Box, mp4UI）将得到的AVI Mux至mp4。对于已存在的码流，你可以使用Moitah的MPEG4 Modifier对MPEG-4 ASP进行修改PAR；使用hhanh的ARChange对AVC进行修改PAR。下列工具可自动在回放中支持可变形重设尺寸：VideoLan, Mplayer或者带有3ivx, nero或haali parser加上XviD（xvid decode设置AR为auto）, 3ivx（打开”force overlay”）, Nero或ffdshow（打开”overlay mixer”）解码滤镜的dshow播放器。 容器方面：MP4提供了一种”合成矩阵(Composition Matrix)”，能够修改AR、画面旋转、支持多层数据、回放时将两条音轨混音（例：将影片的语音和音乐分离）等功能。Quicktime/Pro提供了很好的合成方法，通过：Movie -&gt; Get Movie Properties -&gt; Video/Sound Track -&gt; Size/Layer/Volume/… ，还能够正确回放此类经合成编辑的MP4文件。 BIFS方面：提供了最广泛的编排创作的可能（Q9），同样还能够修改AR（例：通过改变2d缩放(Transform2D.scale)）。你可以使用GPAC的工程软件：MP4box和Osmo4来创建和回放此类BIFS控制的数据流。 有没有可能在MP4中创建VFR(Variable Framerate/可变帧率)内容？可以。察看下面的帖子。 我如何播放MP4文件？由于MP4的互用性这一巨大优势及开源标准（授权免费！）这些特性，现在已有众多工具可以在不同系统包括Mac, Linux, PocketPC当然还有windows中支持MP4。 如果你想用基于dshow的播放器（例如media player classic, bsplayer, zoomplayer或者蹩脚的windows media player）来回放任何此类的媒体文件，首先你需要用到下面两个东西： – 一个分离滤镜(splitter/parser filter)：它能够在回放时将容器中包含的数据流（音频流、视频流、字幕流）分离开。– 一个解码滤镜(decode filter)：它（例如：ffdshow, 3ivx, CoreAAC）能够将编码的数据流解码。顺便说一下，我们在播放AVI时不需要安装分离滤镜的唯一原因是windows系统已经默认安装了这个东西。 这里有一些组件包，包含了这些滤镜：– Gabest’s MP4 Splitter支持AAC, ASP, AVC, MPEG-1/2音频（如MP2/MP3）与视频, 先进TTXT, MP4中的VobSubs和章节, 开源（Gabest的MPC播放器已经内建此滤镜）– Haali’s Media Splitter支持MP4中的AAC, ASP, AVC, MPEG-1/2音频（例：mp2/mp3）和视频，TTXT，vobsubs和章节，并支持地切换音频、视频、字幕，是无限制的，部分开源的，免费的– 3ivx支持MP2, MP3, AAC, ASP, 章节但不支持MP4里的AVC！使用ffdshow或CoreAAC这样的解码器时请确定”allow unsupport decoders” 选项已勾选– Elecard提供了支持AAC, ASP, AVC的MP4 splitter，并附带ASP/AVC解码器– Nero支持AAC, ASP, AVC, vobsubs和章节（Nero7下只限Nero Showtime！Nero6下仅Nero Showtime支持字幕/章节/多音轨！）– HDX4支持MP4中的AAC和ASP– EnvivioTV 支持MP4中的高级内容/BIFS（样本）, AAC, ASP和AVC– Moonlight提供了支持MP3, AAC, ASP, AVC的MP4 splitter，并附带ASP/AVC解码器– Dicas的mpegable，支持RTP(Real-Time Transport Protocol/实时传输协议)流媒体，AAC, ASP和AMR（.3gp音频）的解码– Ligos的LSX-MPEG，仅支持Simple Profile视频，30天预览版本 如果你不能/不想使用基于windows dshow的播放器，你也可以使用下列的播放器来播放MP4： – Apple的Quicktime，广泛使用，支持MPEG-4 SP, AVC和AAC– Realnetworks的RealPlayer10，支持MPEG-4 SP + b桢（仅plus版本）和AAC– GPAC的Osmo4，开源（GPL），支持BIFS（字幕，用户互动，类dvd目录…）和TTXT– MPlayer，开源（GPL），支持ASP和AVC，支持众多系统，象Win, Linux, Mac OS… – Videolan，开源（GPL），支持ASP和AVC，多系统支持– MPEG4IP的WMP4Player，开源（LGPL(Lesser General PublicLicense/GNU较宽松公共许可证)/MPL(Mozilla Public License)），支持ASP和AVC– xine，开源（GPL），多系统支持– TCPMP，用于PalmOS/WindowsCE– Philips的Platform4 Player支持PocketPC– ENST的Osmo4（基于参考源），支持高级内容/BIFS– IBM的M4Play含Toolkit for MPEG-4，基于Java，支持高级内容/BIFS 硬件/独立播放器：由于最流行的MPEG-4 ASP执行者（DivX5/XviD）经常被放入AVI中，那也成为了现在播放器最广泛支持的格式。同样是nero的那些家伙，也是为了满足消费者日益增长的需求，他们尝试将MP4容器格式能够被硬件播放器支持，并逐步取得了成功：支持MP4的硬件播放器如下： – Avayon的DXP-1000支持MP4的AAC, ASP, VobSubs和章节– elta的8815 MP4支持MP4的AAC, ASP, VobSubs和章节– Gowell的AS 602支持MP4的AAC, ASP, VobSubs和章节– Kiss的DP-558支持AAC, ASP（不支持QPel(Quarter-Pixel/1/4象素预测)/GMC(Global Motion Compensation/全局动态补偿)），支持VobSubs和章节（Sigma Designs EM8560）– Packard Bell的DVD-DivX 450 pro支持MP4的AAC, ASP, VobSubs和章节– Philips的DVP630/632/642播放器支持MP4的ASP（不支持QPel/1WP GMC）, MP3（非AAC）（ESS Vibratto-II）– RJTech的RJ 1500DVX II支持MP4的AAC（5.1）, MP3, ASP (QPel/1WP GMC/CQM), VobSubs, 章节（ESS Vibratto-II）– Siemssen的SCO 5000ND支持MP4的AAC（不支持MP3/MP2），ASP (QPel/1WP GMC), VobSubs, 章节（Zoran Vaddis 776）。– Targa的DR-5200x支持MP4的AAC, ASP, VobSubs和章节– Tevion DR 2004，支持MP4的AAC, ASP (QPel/1WP GMC?)和VobSubs。– Tevion DVD-4000，最新的固件(firmware)支持MP4的ASP（不支持QPel/1WP GMC？）和MP3（非AAC）（ESS Vibratto-II）– Xoro的HSD 415/310播放器支持MP4的AAC, ASP（不支持QPel/1WP GMC？）, VobSubs, 章节（ESS Vibratto-II）。– M$的Xbox的Xbox Media Center支持MP4的MP2, MP3, AAC和AVC。– Sony的Playstation Portable（PSP）支持MP4的AAC, SP和AVC，保存在记忆棒(Memory Stick)中– Apple的iPod支持MP4的AAC，iPod video还支持AVC– Sigma Designs的Xcard支持在PC上硬体解码MPEG-4包括MP4容器 如何直播/收看实时（live-）的MP4流媒体？Apple和MPEG4IP提供了不错的、免费的工具以将MP4流媒体化：想要做流媒体服务器，你可以使用Apple’s Darwin Streaming Server，这是everwiked与linuxjornal里提供的操作指南。要直播流媒体你可以使用MPEG4IP的mp4live（仅Linux支持），这是everwiked及MPEG4IP的指南；在Windows系统中，你可以使用MPEGRecorder（看上去像mp4live的一个端口）。同样，你可以看一下ViTooKi的工具包（开源的流媒体服务器、播放器和其他相关工具）。另一个免费、开源的mp4流媒体服务器是Cata提供的。如果是MAC系统，你可以看一下Live Channel。 要播放广播/直播式的流媒体，你可以用Apple的Quicktime, Real的RealPlayer 10, MPEG4IP的WMP4Player, Dica的mpegable和EnvivioTV（都运作在dshow播放器下）和GPAC的Osmo4（最后两个也可以支持高级内容/用户互动）（Envivio的互动演示）。通过MediaFrame（演示）和IBM（互动演示）的java applets你也可以在不支持安装播放器情况下来播放流媒体的MP4。 流媒体样本：1 2 那里可以找到mp4码率计算工具？为什么由源AVI制作得到的MP4文件体积要比源AVI文件体积小一点？MP4需要的overhead的容量远小于AVI容器（特别是VBR-mp3音轨）。勿需质疑，与AVI容器相反，MP4容器就是为MPEG-4视频和MP3设计的。这里有一个计算式，你可以这样说：AVI中的视频流文件体积=最终输出的含视频音频的MP4文件体积（像700MB） - MP4的音频体积 + 3MB。3ivx在它的主页上也提供了一个MP4码率计算工具，但它看上去不是十分精确。 MP4支持CRC(Cyclic Redundancy Check)/循环冗余码校验)/EDC(Error Detection Code/错误校验)或ECC(Error Correction Code/自纠错)吗？不支持。MP4容器本身，乃至MPEG-4标准都不希望支持码流中的错误检测/纠正(Error Detection/Correction)（它们该用在该用的地方）。点击这里，了解更多有关MPEG-4码流中的差错恢复(Error Resilience)。 有没有可能得知一个MP4文件是用何种编码创建的？是的。对于MPEG-4 ASP的视频流和MP3音频流（现在还没有一个真正的方法来确认是否用了AAC音频编码）来说，是可以的。点击这里，了解更多。 MP4是MP3的继承者吗？是，也不是。说它不是，因为MP3是一种特别的音频格式，而MP4是一种容器格式并非是音频编码。说它是的，因为MP4是MPEG-4标准的一部分，MPEG-4标准是MPEG-1/2的继承者，而mp3亦是它的一部分。MPEG-4还包括AAC，一种比MP3更好的音频编码，也被用于MP4中。 MP4和MOV/3GP是一样的吗？Apple的MOV容器格式确实与MP4的出发点相同（主要在moov atom方面），但它们之间还是有不少区别的。从另一方面来说，MP4的出发点是3GP格式（通常用于手机中）的开发。3GP格式普遍用于MP4中，就像用于MOV中一样。然而，这仍是另一种格式。 我还想了解更多关于MP4！在哪里能够找到更多信息？在网络上有不少此类的信息：MP4的说明文件可在这里找到。MPEG-4系统标准的草案可在这里找到。有一些关于MP4的文档：1 2 3。MPEG Industry Forum或Motion Picture Experts Group（MPEG）的主页上也有许多信息。关于MPEG-4标准和MPEG-4系统（非常有技术价值）的FAQs是很有用的。另外可以在audiocoding wiki找到许多信息（也有许多关于AAC的信息）。关于MP4的创建, 编译成果MPEG4IP有不少指南，同样他们的CVS服务器和everwicked.com上也有指南。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"openstack 安装踏过的坑","slug":"z_csdn_053_48713829","date":"2015-09-24T01:26:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2015/09/24/z_csdn_053_48713829/","link":"","permalink":"http://vball.fun/2015/09/24/z_csdn_053_48713829/","excerpt":"","text":"最近i尝试对公司的u服务器架构使用openstack，测试ng啊传中a茫茫多的坑，这里记录一下 错误信息稀奇百怪： InstanceDeployFailure: Cannot create containerInstance DeployFailure: Cannot setup network: Unexpected vif_type=binding_failed nova-docker 在各版本openstack上的安装注意事项，注意事项，注意事项－－－－重要的话说三次，后边好多坑都是这么来的． 检查nova-docker代码目录中的requirements.txt 的软件包依赖，依次修正 pip install xxx=1.0.x 认真检查 pip search xxxx 确保版本正确．","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"python udp 广播","slug":"z_csdn_070_47340817","date":"2015-08-07T00:07:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2015/08/07/z_csdn_070_47340817/","link":"","permalink":"http://vball.fun/2015/08/07/z_csdn_070_47340817/","excerpt":"","text":"最近有需求写了个udp 广播的工具，百度了半天，发现满地坑，wireshark 抓了半天包，发现都是只能localhost收发。这里就记录一下吧 listener.py 1234567891011121314151617181920#!/usr/bin/env python# -*- coding:UTF-8 -*-from socket import *from time import ctimeHOST = &#x27;127.0.0.1&#x27;PORT = 21567BUFSIZE = 1024ADDR = (HOST,PORT)udpSerSock = socket(AF_INET, SOCK_DGRAM)udpSerSock.bind((&#x27;&#x27;,PORT))print &#x27;wating for message...&#x27;while True: data, addr = udpSerSock.recvfrom(BUFSIZE) print(&#x27;...received -&gt;%s %s&#x27;%(addr,data) )udpSerSock.close() brocaster.py 1234567891011121314151617181920212223from socket import *HOST = &#x27;&#x27;PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)udpCliSock = socket(AF_INET, SOCK_DGRAM)udpCliSock.bind((&#x27;&#x27;, 0))udpCliSock.setsockopt(SOL_SOCKET, SO_BROADCAST, 1)while True: data = raw_input(&#x27;&gt;&#x27;) if not data: break print &quot;sending -&gt; %s&quot;%data udpCliSock.sendto(data,ADDR)## data,ADDR = udpCliSock.recvfrom(BUFSIZE)## if not data:## break## print dataudpCliSock.close() 核心i就是bind和 以后类似的代码就直接找python的 参考代码吧，为什么手欠用百度。。。。少了谷歌没法活了 http://svn.python.org/projects/python/trunk/Demo/","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"virtualbox headless 安装使用 后台运行","slug":"z_csdn_058_41774851","date":"2014-12-05T21:10:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2014/12/05/z_csdn_058_41774851/","link":"","permalink":"http://vball.fun/2014/12/05/z_csdn_058_41774851/","excerpt":"","text":"公司配备的电脑太烂了，DDR2的主机简直没法说，安装好mint，再启动eclipse基本什么其他想法都不要有了，只好想办法扩展计算机的能力了，还好手头有个测试server可以使用，只好他扩展一下主机的能力了。 想法是安装一个win 7 ，然后使用terminal server 登录上去，后来发现virtualbox就有非常方便terminal service并且结合后台运行virtualbox headless模式，简直爽爆了。 环境简介： 123server : RHEL6.5 + virtualbox （win7 or other OS） IP: 192.168.0.121client : mint17 IP:192.168.0.119 至于天朝把virtualbox官网墙了的问题，我觉得你们能自己解决。 1：RHEL 6.5 virtualbox 安装 ： 从virtualbox官网获取virtualbox的repo源，放置到/etc/yum.repo.d/下边，然后执行命令安装virtualbox ： 1sudo yum updatesudo yum install -y virtualbox* 当然你也可以从http://download.virtualbox.org/virtualbox/挑选你的下载文件 2： 安装win7 我就不说了（虚拟机名字不建议使用汉字命名，后边后台启动需要用命令行，汉字你懂的），这里因为要适应3389 terminal service登陆到虚拟机，需要做如下设置 如果你需要在Headless模式，需要禁用3D加速（必要时禁用2D加速）： 3：远程连接该虚拟机 重启该虚拟机后，你就可以使用3389 client连接上该虚拟机了，链接的ip地址为RHEL的主机IP linux 下可以使用rdesktop ,windows下不多说了，安装完成后请安装virtualbox增强功能，这个不多说。 后边简要说一下，中间可能出现的问题及解决方案： 1：虚拟机没有声音 另外，win7安装后可能没有声音，需要将声音设备选择为ICH AC97 ,并且在win7中安装AC97驱动，我下载到的realtek_ac97_6016302_win7.zip ,反正很难找，我上传到csdn或者百度网盘分享给大家。 2：虚拟机声卡传送到本机 ： rdesktop -r sound:local 192.168.0.240 具体参数不解释了，你可以使用–help参看更多参数。 windows直接有相关选项，主机测试。 3：虚拟机分辨率自定义问题： 首先，增强扩展包是必须的，其次，如果虚拟机中没有出现你满意的分辨率，可以使用virtualbox提供的工具进行设置： VBoxManage setextradata global GUI/MaxGuestResolution 1272,920 （设置最大分辨率，同样你就有了自定义分辨率的方法，请在虚拟机关闭的时候使用） 4：virtualbox后台运行的方法： nohup VBoxHeadless -s win7 &amp; //(win7是你的虚拟机的名字，不用汉字的原因) 如果提示错误，一般都是你声卡启动了3D或者2D，按照上边的说明关闭即可。 来自为知笔记(Wiz)","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"qt 调试语句的处理 禁用和重定向到文件","slug":"z_csdn_023_41774815","date":"2014-12-05T21:03:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2014/12/05/z_csdn_023_41774815/","link":"","permalink":"http://vball.fun/2014/12/05/z_csdn_023_41774815/","excerpt":"","text":"&lt;span class=&quot;com&quot;&gt;#include&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QtDebug&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;com&quot;&gt;#include&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QFile&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;com&quot;&gt;#include&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QTextStream&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; customMessageHandler&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QtMsgType&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; type&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;pun&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;typ&quot;&gt;QString&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; txt&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QtDebugMsg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pln&quot;&gt; txt &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QString&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;Debug: %1&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QtWarningMsg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pln&quot;&gt; txt &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QString&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;Warning: %1&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QtCriticalMsg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pln&quot;&gt; txt &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QString&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;Critical: %1&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QtFatalMsg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pln&quot;&gt; txt &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QString&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;Fatal: %1&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;pln&quot;&gt; abort&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;pun&quot;&gt;&#125;&lt;/span&gt; &lt;span class=&quot;typ&quot;&gt;QFile&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; outFile&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;debuglog.txt&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;pln&quot;&gt; outFile&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QIODevice&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;WriteOnly&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;QIODevice&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Append&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;typ&quot;&gt;QTextStream&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; ts&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&amp;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;outFile&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;pln&quot;&gt; ts &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&lt;&lt;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; txt &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&lt;&lt;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; endl&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pun&quot;&gt;&#125;&lt;/span&gt; &lt;span class=&quot;typ&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; main&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; argc&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; argv&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;pun&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;typ&quot;&gt;QApplication&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; app&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; argc&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; argv &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;com&quot;&gt;//Lets register our custom handler, before we start &lt;/span&gt; &lt;span class=&quot;pln&quot;&gt; qInstallMsgHandler&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;customMessageHandler&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;pun&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;kwd&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; app&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;pun&quot;&gt;&#125;&lt;/span&gt;","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"android万能服务器支持git，svn，ddns，dns，php 。。。。。怎么都没有图片。。。","slug":"z_csdn_044_11119349","date":"2013-09-04T19:43:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/09/04/z_csdn_044_11119349/","link":"","permalink":"http://vball.fun/2013/09/04/z_csdn_044_11119349/","excerpt":"","text":"公司代码不让外传，自己的代码server又不方便，就找了android下的一个git server –》Gidder 。具体不描述了，自己研究吧，挺好玩，添加个用户名，repo，使用ssh://user@ip/test.git就可以提交代码了。 核心来了，无意中发现了另一个软件Servers Ultimate，可以支持基本上所有的常用服务器，摘一段e文简介： Now you can run a CVS, DC Hub, DHCP, DLNA, DNS, DDNS, eDonkey, Email (POP3 / SMTP), FTP Proxy, FTP, FTPS, Flash Policy, Git, Gopher, HTTP Snoop, ICAP, IRC Bot, IRC, ISCSI, Icecast, LPD, Load Balancer, MQTT, Memcached, MongoDB, MySQL, NFS, NTP, NZB Client, Napster, PHP and Lighttpd, PXE, Port Forwarder, Proxy, RTMP, Remote Control, Rsync, SMB/CIFS, SMPP, SMS, Socks, SFTP, SSH, Server Monitor, Stomp, Styx, Syslog, TFTP, Telnet, Test, Time, Torrent Client, Torrent Tracker, Trigger, UPnP Port Mapper, VNC, Wake On Lan, Web, WebDAV, WebSocket, X11 and/or XMPP server! 看到没有。哈哈，强大的一塌糊涂啊，这里仅仅介绍一下ddns吧（主要是他本身提供的全都是国外的ddns，天朝的网络环境你懂的，这里添加个花生壳吧），毕竟使用随时变化的手机ip还是很不方便的 。 添加一个 进到SPECIFIC ,填写花生壳的ip更新地址 ： http://%username%:%password%@ddns.oray.com/ph/update?hostname=%hostname%&amp;myip=%ip% 点击help可以看到帮助 ： 输入自己在花生壳的申请的免费域名和花生壳账户密码，点击test Now，出现200 信息一般都成功了 windows可以使用ipconfig /flushdns 清空一下dns缓冲，这个时候你就可以ping 你的域名，你的ip就通了。 在上边开通自己的服务吧，你可以拥有移动的万能服务器了，省去折腾服务器了，当然是临时的 想想下边的组合： android + cvs git android + dns android +ftp sftp tftp android + mysql android + MongoDb android +nfs 。。。。。。。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"VIM插件大全，另外附VIM IDE 一键安装包","slug":"z_csdn_021_9949869","date":"2013-08-13T00:11:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2013/08/13/z_csdn_021_9949869/","link":"","permalink":"http://vball.fun/2013/08/13/z_csdn_021_9949869/","excerpt":"","text":"忽略这个文章吧，现在转向 https://github.com/chxuan/vimplus 之前发现没图片，常言道，没图说个JB，发一下： 这个是在xshell的效果，YY一下，在github上放置了vimide所需的一键安装的插件和一键安装包，移除了导致卡死的vjde，在ubuntu，fedora，miint上测试通过，需要安装vim-scripts 软件包才能使上边的文件栏显示。 https://github.com/godvmxi/tools 欢迎fork push request提出你的修改。 F6 F7开启关闭两边栏目，鼠标默认开启，需要复制，请按住shift选择。 话说在刚学linux的时候测试了很多人的配置方法，只能说痛苦，后来干脆自己来了买，多年实践结果。呵呵。 使用vim开发软件是每一个linux工作人员的梦想，这里转载了常用的vim插件， 另外我也把的的vim ide的配置文件共享一下了，放在github上了，使用其中install脚本可以安装到当前用户的根目录，F6，F7启动两边的文件浏览和代码块分析，ctrl+w+方向，切换窗口 附截图一张吧： ctags （http://ctags.sourceforge.net） 对浏览代码非常的方便, 可以在函数, 变量之间跳转，写程序必备 #============================================================================= TagList 插件（http://www.vim.org/scripts/script.php?script_id=273 ） 高效地浏览源码, 其功能就像vc中的workpace, 那里面列出了当前文件中的所有宏,全局变量, 函数名等. #============================================================================= 3.BufExplorer(http://vim.sourceforge.net/scripts/script.php?script_id=42) 缓冲区浏览 #============================================================================= WinManager 插件（http://vim.sourceforge.net/scripts/script.php?script_id=95 ） 管理各个窗口, 或者说整合各个窗口.[more] #============================================================================= cscope(http://cscope.sourceforge.net/) 用Cscope自己的话说 – “你可以把它当做是超过频的ctags”, 其功能和强大程度可见 一斑吧, 关于它的介绍我就不详细说了, 如果你安装好了前文介绍的帮助手册. #============================================================================= c.vim 插件(http://www.vim.org/scripts/script.php?script_id=213) C/C++-IDE for Vim/gVim. 简单的说, 就是如果安装配置好后, vim/gvim就是一个 c/c++编程的一个IDE, 其功能堪比windows 里常用的vc. #============================================================================= omnicppcoplete 插件(http://www.vim.org/scripts/script.php?script_id=1520) 实现像vc那样的代码自动补全功能, 比如 this-&gt; 后, 将出现一个 提示框, 其中包含了this指针所有可以接收的函数或数据成员等. #============================================================================= a.vim插件(http://www.vim.org/scripts/script.php?script_id=31) 在 .h 和 .c/.cpp 文件中切换. (英文原句 “A few of quick commands to swtich between source files and header files quickly.”) #============================================================================= VisualMark.vim插件(http://www.vim.org/scripts/script.php?script_id=1026) 高亮书签. #============================================================================= Mark.vim插件(http://www.vim.org/scripts/script.php?script_id=1238) 这个插件与vim中自带的’‘与’#’非常相像. 不同之处是: vim中的’‘与’#’命令只能同时高亮一个同类词组(或正则表达式的搜索结果), 而Mark.vim插件可以同时高亮多个. #============================================================================= code_complete.vim插件(http://www.vim.org/scripts/script.php?script_id=1764) 函数参数提示. #============================================================================= autoproto.vim(http://www.vim.org/scripts/script.php?script_id=1553) Using this script, typing “(“ will result in (|), where | is the cursor position and the double backticks are just marking input. Typing a “)” will move the cursor outside the parens. This moving outside works even in nested scenarios. Typing “if(my_array[‘key`` results in if(my_array[‘key|’]) and “)” gets you if(my_array[‘key’])|. The paired characters are: [, (, ｛, “, ‘; // “ If you like this script, you should also check out surround.vim #============================================================================= 13. pyclewn ( http://pyclewn.sourceforge.net/) 更方便地使用gdb调试 #============================================================================= project.vim(http://www.vim.org/scripts/script.php?script_id=69) 组织管理工程, 方便于浏览, 打开, 查找文件等. #============================================================================= NERD_tree.vim(http://www.vim.org/scripts/script.php?script_id=1658) 目录树, 同时还可以对文件进行打开操作等. #============================================================================= NERD_commenter.vim(http://www.vim.org/scripts/script.php?script_id=1218) 源码文档注释. #============================================================================= DoxygenToolkit.vim(http://www.vim.org/scripts/script.php?script_id=987) 方便生成代码文档 #============================================================================= cpp.vim（http://www.vim.org/scripts/script.php?script_id=1640) 加强c/c++类名, 函数等高亮 #============================================================================= javacomplete.vim（http://www.vim.org/scripts/script.php?script_id=1785) 进行java 类, 包, 方法等补全. #============================================================================= JumpInCode_Plus.vim(http://www.vim.org/scripts/script.php?script_id=2862 ） 生成tags和 cscope #============================================================================= txtbrowser.zip（http://www.vim.org/scripts/script.php?script_id=2899） 在普通txt文本显示语法高亮 #============================================================================= FindMate.vim（http://www.vim.org/scripts/script.php?script_id=2871） 快速查找文件 #============================================================================= grep.vim The grep plugin integrates the grep, fgrep, egrep, and agrep tools with Vim and allows you to search for a pattern in one or more files and jump to them. #============================================================================= autocomplpop.zip（http://www.vim.org/scripts/script.php?script_id=1879） With this plugin, your vim comes to automatically opens popup menu for completions when you enter characters or move the cursor in Insert mode. It won’t prevent you continuing entering characters. #=============================================================================http://vimcdoc.sourceforge.net/ vim中文文档 http://www.vim.org/scripts/script.php?script_id=1638 “ SourceCodeObedience http://www.vim.org/scripts/script.php?script_id=1581 “ lookupfile http://insenvim.sourceforge.net/index.php “ Vim Intellisense #=============================================================================http://blog.csdn.net/tge7618291/archive/2009/05/26/4216977.aspx 较详细的介绍vim插件","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"一些强大的命令","slug":"z_csdn_061_9949779","date":"2013-08-13T00:00:26.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/13/z_csdn_061_9949779/","link":"","permalink":"http://vball.fun/2013/08/13/z_csdn_061_9949779/","excerpt":"","text":"一些强大的命令再分享一些可能你不知道的shell用法和脚本，简单&amp;强大！ 在阅读以下部分前，强烈建议读者打开一个shell实验，这些都不是shell教科书里的大路货哦：） &lt;span&gt;!$&lt;/span&gt;&lt;br&gt; &lt;code&gt;!$&amp;#x662F;&amp;#x4E00;&amp;#x4E2A;&amp;#x7279;&amp;#x6B8A;&amp;#x7684;&amp;#x73AF;&amp;#x5883;&amp;#x53D8;&amp;#x91CF;&amp;#xFF0C;&amp;#x5B83;&amp;#x4EE3;&amp;#x8868;&amp;#x4E86;&amp;#x4E0A;&amp;#x4E00;&amp;#x4E2A;&amp;#x547D;&amp;#x4EE4;&amp;#x7684;&amp;#x6700;&amp;#x540E;&amp;#x4E00;&amp;#x4E2A;&amp;#x5B57;&amp;#x7B26;&amp;#x4E32;&amp;#x3002;&amp;#x5982;&amp;#xFF1A;&amp;#x4F60;&amp;#x53EF;&amp;#x80FD;&amp;#x4F1A;&amp;#x8FD9;&amp;#x6837;&amp;#xFF1A;&lt;br&gt; $mkdir mydir&lt;br&gt; $mv mydir yourdir&lt;/code&gt;&lt;br&gt; $cd yourdir&lt;br&gt; &amp;#x53EF;&amp;#x4EE5;&amp;#x6539;&amp;#x6210;&amp;#xFF1A;&lt;br&gt; $mkdir mydir&lt;br&gt; $mv !$ yourdir&lt;br&gt; $cd !$ sudo !!以root的身份执行上一条命令 。场景举例：比如Ubuntu里用 apt-get安装软件包的时候是需要root身份的，我们经常会忘记在 apt-get前加 sudo。每次不得不加上 sudo再重新键入这行命令，这时可以很方便的用 sudo !!完事。（陈皓注：在shell下，有时候你会输入很长的命令，你可以使用!xxx来重复最近的一次命令，比如，你以前输入过，vi /where/the/file/is, 下次你可以使用 !vi 重得上次最近一次的vi命令。） cd &amp;#x2013;回到上一次的目录 。场景举例：当前目录为 /home/a，用 cd ../b切换到 /home/b。这时可以通过反复执行 cd &amp;#x2013;命令在 /home/a和 /home/b之间来回方便的切换。（陈皓注：cd ~ 是回到自己的Home目录，cd ~user，是进入某个用户的Home目录） ‘ALT+.’ or ‘ .’热建alt+. 或 esc+. 可以把上次命令行的参数给重复出来。 ^old^new替换前一条命令里的部分字符串。场景： echo &quot;wanderful&quot;，其实是想输出 echo &quot;wonderful&quot;。只需要 ^a^o就行了，对很长的命令的错误拼写有很大的帮助。（陈皓注：也可以使用!!:gs/old/new） du -s * | sort -n | tail列出当前目录里最大的10个文件。 :w !sudo tee %在vi中保存一个只有root可以写的文件 date -d@1234567890时间截转时间 file.txt创建一个空文件，比touch短。 mtr coolshell.cnmtr命令比traceroute要好。 在命令行前加空格，该命令不会进入history里。 echo “ls -l” | at midnight在某个时间运行某个命令。 curl -u user:pass -d status=”Tweeting from the shell” http://twitter.com/statuses/update.xml命令行的方式更新twitter。 curl -u username –silent “https://mail.google.com/mail/feed/atom&quot; | perl -ne ‘print “\\t” if //; print “$2\\n” if /&lt; titlename&gt;(.*)&lt; &gt;/;’检查你的gmail未读邮件 ps aux | sort -nk +4 | tail列出头十个最耗内存的进程 man ascii显示ascii码表。场景：忘记ascii码表的时候还需要google么?尤其在天朝网络如此”顺畅”的情况下，就更麻烦在GWF多应用一次规则了，直接用本地的 man ascii吧。 ctrl-x e快速启动你的默认编辑器（由变量$EDITOR设置）。 netstat &amp;#x2013;tlnp列出本机进程监听的端口号。（陈皓注：netstat -anop 可以显示侦听在这个端口号的进程） tail -f /path/to/file.log | sed &#39;/^Finished: SUCCESS$/ q&#39;当file.log里出现Finished: SUCCESS时候就退出tail，这个命令用于实时监控并过滤log是否出现了某条记录。 ssh user@server bash &lt; /path tolocalscriptshcode&gt; &lt;br&gt; &amp;#x5728;&amp;#x8FDC;&amp;#x7A0B;&amp;#x673A;&amp;#x5668;&amp;#x4E0A;&amp;#x8FD0;&amp;#x884C;&amp;#x4E00;&amp;#x6BB5;&amp;#x811A;&amp;#x672C;&amp;#x3002;&amp;#x8FD9;&amp;#x6761;&amp;#x547D;&amp;#x4EE4;&amp;#x6700;&amp;#x5927;&amp;#x7684;&amp;#x597D;&amp;#x5904;&amp;#x5C31;&amp;#x662F;&amp;#x4E0D;&amp;#x7528;&amp;#x628A;&amp;#x811A;&amp;#x672C;&amp;#x62F7;&amp;#x5230;&amp;#x8FDC;&amp;#x7A0B;&amp;#x673A;&amp;#x5668;&amp;#x4E0A;&amp;#x3002; ssh user@host cat /path/to/remotefile | diff /path/to/localfile -&lt;br&gt; &amp;#x6BD4;&amp;#x8F83;&amp;#x4E00;&amp;#x4E2A;&amp;#x8FDC;&amp;#x7A0B;&amp;#x6587;&amp;#x4EF6;&amp;#x548C;&amp;#x4E00;&amp;#x4E2A;&amp;#x672C;&amp;#x5730;&amp;#x6587;&amp;#x4EF6; net rpc shutdown -I ipAddressOfWindowsPC -U username%password&lt;br&gt; &amp;#x8FDC;&amp;#x7A0B;&amp;#x5173;&amp;#x95ED;&amp;#x4E00;&amp;#x53F0;Windows&amp;#x7684;&amp;#x673A;&amp;#x5668; &lt;code&gt;screen -d -m -S some_name ping my_router&lt;/code&gt;&lt;br&gt; &amp;#x540E;&amp;#x53F0;&amp;#x8FD0;&amp;#x884C;&amp;#x4E00;&amp;#x6BB5;&amp;#x4E0D;&amp;#x7EC8;&amp;#x6B62;&amp;#x7684;&amp;#x7A0B;&amp;#x5E8F;&amp;#xFF0C;&amp;#x5E76;&amp;#x53EF;&amp;#x4EE5;&amp;#x968F;&amp;#x65F6;&amp;#x67E5;&amp;#x770B;&amp;#x5B83;&amp;#x7684;&amp;#x72B6;&amp;#x6001;&amp;#x3002;&lt;code&gt;-d -m&lt;/code&gt;&amp;#x53C2;&amp;#x6570;&amp;#x542F;&amp;#x52A8;&amp;#x201C;&amp;#x5206;&amp;#x79BB;&amp;#x201D;&amp;#x6A21;&amp;#x5F0F;&amp;#xFF0C;&lt;code&gt;-S&lt;/code&gt;&amp;#x6307;&amp;#x5B9A;&amp;#x4E86;&amp;#x4E00;&amp;#x4E2A;session&amp;#x7684;&amp;#x6807;&amp;#x8BC6;&amp;#x3002;&amp;#x53EF;&amp;#x4EE5;&amp;#x901A;&amp;#x8FC7;&lt;code&gt;-R&lt;/code&gt;&amp;#x547D;&amp;#x4EE4;&amp;#x6765;&amp;#x91CD;&amp;#x65B0;&amp;#x201C;&amp;#x6302;&amp;#x8F7D;&amp;#x201D;&amp;#x4E00;&amp;#x4E2A;&amp;#x6807;&amp;#x8BC6;&amp;#x7684;session&amp;#x3002;&amp;#x66F4;&amp;#x591A;&amp;#x7EC6;&amp;#x8282;&amp;#x8BF7;&amp;#x53C2;&amp;#x8003;screen&amp;#x7528;&amp;#x6CD5;&amp;#xA0;&lt;code&gt;man screen&lt;/code&gt;&amp;#x3002; &lt;code&gt;wget --random-wait -r -p -e robots=off -U mozilla&amp;#xA0;http://www.example.com&lt;/code&gt;&lt;br&gt; &amp;#x4E0B;&amp;#x8F7D;&amp;#x6574;&amp;#x4E2A;www.example.com&amp;#x7F51;&amp;#x7AD9;&amp;#x3002;&amp;#xFF08;&amp;#x6CE8;&amp;#xFF1A;&amp;#x522B;&amp;#x592A;&amp;#x8FC7;&amp;#x5206;&amp;#xFF0C;&amp;#x5927;&amp;#x90E8;&amp;#x5206;&amp;#x7F51;&amp;#x7AD9;&amp;#x90FD;&amp;#x6709;&amp;#x9632;&amp;#x722C;&amp;#x529F;&amp;#x80FD;&amp;#x4E86;&amp;#xFF1A;&amp;#xFF09;&amp;#xFF09; &lt;code&gt;curl ifconfig.me&lt;/code&gt;&lt;br&gt; &amp;#x5F53;&amp;#x4F60;&amp;#x7684;&amp;#x673A;&amp;#x5668;&amp;#x5728;&amp;#x5185;&amp;#x7F51;&amp;#x7684;&amp;#x65F6;&amp;#x5019;&amp;#xFF0C;&amp;#x53EF;&amp;#x4EE5;&amp;#x901A;&amp;#x8FC7;&amp;#x8FD9;&amp;#x4E2A;&amp;#x547D;&amp;#x4EE4;&amp;#x67E5;&amp;#x770B;&amp;#x5916;&amp;#x7F51;&amp;#x7684;IP&amp;#x3002; convert input.png -gravity NorthWest -background transparent -extent 720&amp;#xD7;200&amp;#xA0; output.png&lt;br&gt; &amp;#x6539;&amp;#x4E00;&amp;#x4E0B;&amp;#x56FE;&amp;#x7247;&amp;#x7684;&amp;#x5927;&amp;#x5C0F;&amp;#x5C3A;&amp;#x5BF8; &lt;code&gt;lsof &amp;#x2013;i&lt;/code&gt;&lt;br&gt; &amp;#x5B9E;&amp;#x65F6;&amp;#x67E5;&amp;#x770B;&amp;#x672C;&amp;#x673A;&amp;#x7F51;&amp;#x7EDC;&amp;#x670D;&amp;#x52A1;&amp;#x7684;&amp;#x6D3B;&amp;#x52A8;&amp;#x72B6;&amp;#x6001;&amp;#x3002; vim scp://username@host//path/to/somefile&lt;br&gt; vim&amp;#x4E00;&amp;#x4E2A;&amp;#x8FDC;&amp;#x7A0B;&amp;#x6587;&amp;#x4EF6; &lt;code&gt;python -m SimpleHTTPServer&lt;/code&gt;&lt;br&gt; &amp;#x4E00;&amp;#x53E5;&amp;#x8BDD;&amp;#x5B9E;&amp;#x73B0;&amp;#x4E00;&amp;#x4E2A;HTTP&amp;#x670D;&amp;#x52A1;&amp;#xFF0C;&amp;#x628A;&amp;#x5F53;&amp;#x524D;&amp;#x76EE;&amp;#x5F55;&amp;#x8BBE;&amp;#x4E3A;HTTP&amp;#x670D;&amp;#x52A1;&amp;#x76EE;&amp;#x5F55;&amp;#xFF0C;&amp;#x53EF;&amp;#x4EE5;&amp;#x901A;&amp;#x8FC7;&lt;code&gt;http://localhost:8000&lt;/code&gt;&amp;#x8BBF;&amp;#x95EE; &amp;#x8FD9;&amp;#x4E5F;&amp;#x8BB8;&amp;#x662F;&amp;#x8FD9;&amp;#x4E2A;&amp;#x661F;&amp;#x7403;&amp;#x4E0A;&amp;#x6700;&amp;#x7B80;&amp;#x5355;&amp;#x7684;HTTP&amp;#x670D;&amp;#x52A1;&amp;#x5668;&amp;#x7684;&amp;#x5B9E;&amp;#x73B0;&amp;#x4E86;&amp;#x3002; &lt;code&gt;history | awk &#39;&#123;CMD[$2]++;count++;&#125; END &#123; for (a in CMD )print CMD[a] &quot; &quot; CMD[a]/count*100 &quot;% &quot; a &#125;&#39; | grep -v &quot;./&quot; | column -c3 -s &quot; &quot; -t | sort -nr | nl | head -n10&lt;/code&gt;&lt;br&gt; (&amp;#x9648;&amp;#x7693;&amp;#x6CE8;&amp;#xFF1A;&amp;#x6709;&amp;#x70B9;&amp;#x590D;&amp;#x6742;&amp;#x4E86;&amp;#xFF0C;history|awk &amp;#x2018;&#123;print $2&#125;&amp;#x2019;|awk &amp;#x2018;BEGIN &#123;FS=&amp;#x201D;|&amp;#x201D;&#125; &#123;print $1&#125;&amp;#x2019;|sort|uniq -c|sort -rn|head -10)&lt;br&gt; &amp;#x8FD9;&amp;#x884C;&amp;#x811A;&amp;#x672C;&amp;#x80FD;&amp;#x8F93;&amp;#x51FA;&amp;#x4F60;&amp;#x6700;&amp;#x5E38;&amp;#x7528;&amp;#x7684;&amp;#x5341;&amp;#x6761;&amp;#x547D;&amp;#x4EE4;&amp;#xFF0C;&amp;#x7531;&amp;#x6B64;&amp;#x751A;&amp;#x81F3;&amp;#x53EF;&amp;#x4EE5;&amp;#x6D1E;&amp;#x5BDF;&amp;#x4F60;&amp;#x662F;&amp;#x4E00;&amp;#x4E2A;&amp;#x4EC0;&amp;#x4E48;&amp;#x7C7B;&amp;#x578B;&amp;#x7684;&amp;#x7A0B;&amp;#x5E8F;&amp;#x5458;&amp;#x3002; tr -c &amp;#x201C;[:digit:]&amp;#x201D; &amp;#x201D; &amp;#x201D; &lt; /dev urandom dd cbs=&quot;$COLUMNS&quot; conv=&quot;unblock&quot; GREP_COLOR=&quot;&amp;#x201D;1;32&amp;#x2033;&quot; grep color span&gt;&lt;br&gt; &amp;#x60F3;&amp;#x770B;&amp;#x770B;Marix&amp;#x7684;&amp;#x5C4F;&amp;#x5E55;&amp;#x6548;&amp;#x679C;&amp;#x5417;&amp;#xFF1F;&amp;#xFF08;&amp;#x4E0D;&amp;#x662F;&amp;#x5F88;&amp;#x50CF;&amp;#xFF0C;&amp;#x4F46;&amp;#x4E5F;&amp;#x5F88;Cool!&amp;#xFF09; &amp;#x770B;&amp;#x4E0D;&amp;#x61C2;&amp;#x884C;&amp;#x4EE3;&amp;#x7801;&amp;#xFF1F;&amp;#x6CA1;&amp;#x5173;&amp;#x7CFB;&amp;#xFF0C;&amp;#x7CFB;&amp;#x7EDF;&amp;#x7684;&amp;#x5B66;&amp;#x4E60;&amp;#x4E00;&amp;#x4E0B;*nix shell&amp;#x811A;&amp;#x672C;&amp;#x5427;&amp;#xFF0C;&amp;#x529B;&amp;#x8350;&lt;a href=&quot;http://www.ituring.com.cn/book/980&quot; rel=&quot;noopener noreferrer&quot;&gt;&amp;#x300A;Linux&amp;#x547D;&amp;#x4EE4;&amp;#x884C;&amp;#x4E0E;Shell&amp;#x811A;&amp;#x672C;&amp;#x7F16;&amp;#x7A0B;&amp;#x5927;&amp;#x5168;&amp;#x300B;&lt;/a&gt;&amp;#x3002; &amp;#x6700;&amp;#x540E;&amp;#x8FD8;&amp;#x662F;&amp;#x90A3;&amp;#x53E5;Shell&amp;#x7684;&amp;#x81F3;&amp;#x7406;&amp;#x540D;&amp;#x8A00;&amp;#xFF1A;(&amp;#x9648;&amp;#x7693;&amp;#x6CE8;&amp;#xFF1A;&amp;#x4E0B;&amp;#x9762;&amp;#x7684;&amp;#x90A3;&amp;#x4E2A;&amp;#x9A6C;&amp;#x514B;&amp;#x676F;&amp;#x5F88;&amp;#x4E0D;&amp;#x9519;&amp;#x554A;&amp;#xFF0C;&lt;a href=&quot;http://404null.com/&quot; rel=&quot;noopener noreferrer&quot;&gt;404null.com&lt;/a&gt;&amp;#x633A;&amp;#x6709;&amp;#x610F;&amp;#x601D;&amp;#x7684;) &lt;span&gt;&amp;#x201C;Where there is a shell&amp;#xFF0C;there is a way!&amp;#x201D;&lt;/span&gt;","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"类Unix流编辑器sed在线极速入门","slug":"z_csdn_046_9949741","date":"2013-08-12T23:59:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/12/z_csdn_046_9949741/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_046_9949741/","excerpt":"","text":"第一个实际脚本将 UNIX 风格的文本转换成 DOS/Windows 格式。您可能知道，基于 DOS/Windows 的文本文件在每一行末尾有一个 CR（回车）和 LF（换行），而 UNIX 文本只有一个换行。有时可能需要将某些 UNIX 文本移至 Windows 系统，该脚本将为您执行必需的格式转换。 我已记不清有多少次在下载一些示例脚本或 C 代码之后，却发现它是 DOS/Windows 格式。虽然很多程序不在乎 DOS/Windows 格式的 CR/LF 文本文件，但是有几个程序却在乎 – 最著名的是 bash，只要一遇到回车，它就会出问题。以下 sed 调用将把 DOS/Windows 格式的文本转换成可信赖的 UNIX 格式： 下面是另一个方便的小脚本。与大多数 Linux 发行版中包括的 “tac” 命令一样，该脚本将反转文件中行的次序。”tac” 这个名称可能会给人以误导，因为 “tac” 不反转行中字符的位置（左和右），而是反转文件中行的位置（上和下）。用 “tac” 处理以下文件： ….将产生以下输出： 可以用以下 sed 脚本达到相同目的： 在查看 QIF 格式之前，先看一下我的 checkbook.txt 格式： 在我的文件中，所有字段都由一个或多个制表符分开，每个交易占据一行。日期之后的下一个字段列出支出类型（如果是收入项，则为 “-“）。第三个字段列出收入类型（如果是支出项，则为 “-“）。然后，是一个支票号字段（如果为空，则还是 “-“），一个交易完成字段（”Y” 或 “N”），一个注释和一个美元金额字段。现在，让我们看一下 QIF 格式。当用文本查看器查看下载的 QIF 文件时，它看起来如下： 浏览过文件之后，不难猜出其格式 – 忽略第一行，其余的格式如下： 在处理象这样重要的 sed 项目时，不要气馁 – sed 允许您将数据逐渐修改成最终形式。在进行当中，可以继续细化 sed 脚本，直到输出与预期的完全一样为止。无需在试第一次时就保证其完全正确。 要开始，首先创建一个名为 “qiftrans.sed” 的文件，然后开始修改数据： 花括号中的第一个命令将把如下行： 变换成： 当然，现在的格式还不完美，但没关系。我们将在进行过程中逐渐细化模式空间的内容。后面 12 行的最后效果是将数据变换成三个字母的格式，最后一行从数据中除去三个斜杠。最后得到这一行： 现在进一步细化： sed 的模式空间变得很难看 – 需要除去额外的新行，并执行某些附加的格式化。要这样做，将使用替代命令。要匹配的模式为： “NUM” 替换成 。如您所见，用愚蠢的标记括起支票号允许我们在该字段为空时方便地插入一个 “-“。 最后一行除去数字后的逗号。它把如 “3,231.00” 这样的美元金额转换成我使用的格式 “3231.00”。现在，让我们看一下最终脚本： 最终的”QIF 到文本”脚本 附加的十一行使用替代和一些分支功能来美化输出。首先看一下这行： 该行包含一个格式为 “/regexp/b label” 的分支命令。如果模式空间与规则表达式匹配，sed 将分支到 fixnegs 标号。您应该可以轻易找到该标号，它在代码中为 “:fixnegs”。如果规则表达式不匹配，则以常规方式继续处理下一个命令。 既然您理解该命令本身的工作原理，让我们看一下分支。如果看一下分支规则表达式，将看到它与后面依次跟有 ‘-‘、任意数量的数字、一个 ‘.’、任意数量的数字和 ‘AMT’ 的字符串 ‘AMT’ 匹配。就象我确信您已猜到一样，该规则表达式专门处理负的美元金额。在这之前，用 ‘ATM’ 括起美元金额，以便以后可以轻易找到它。因为规则表达式只与以 ‘-‘ 开始的美元金额匹配，所以，该分支只在恰巧处理借款时才发生。如果正处理贷款，应该将 OUTY 设置成 ‘misc’，将 INNY 设置成 ‘-‘，并且应该除去贷款数量前面的负号。如果跟踪代码的流程，将看到实际情况正是这样。如果不执行分支，则用 ‘-‘ 替换 OUTY，用 ‘inco’ 替换 INNY。完成了！现在输出行是完美的： 如您所见，只要循序渐进地解决问题，使用 sed 转换数据就没有那么难。不要试图使用一个 sed 命令或一下子解决所有问题。相反，要朝着目标逐步进行，并不断改进 sed 脚本，直到其输出正如您希望那样为止。sed 有许多功能，希望您已非常熟悉其内部工作原理并继续努力以进一步掌握它！","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"linux软件包使用技巧总结","slug":"z_csdn_003_9949687","date":"2013-08-12T23:54:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2013/08/12/z_csdn_003_9949687/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_003_9949687/","excerpt":"","text":"查找特定文件属于哪个软件包： 显示软件包详细信息 apt-cache show rpm -ql 显示软件包具体内容： 显示系统已有软件包 dpkg -l 显示软件包变化历史 ： apt-listchanges 在每个软件包被安装以后，都会在文档目录( /usr/share/doc/packagename ) 生成一个 changelog.Debian.gz 的文件 “按需”安装软件包1# auto-apt run ./configure 自动安装缺少的软件包 1auto-apt update，auto-apt updatedb和 auto-apt update-local来完成更新。 undefined 1下载源码包编译 1apt-get source packagename 仅下载 1apt-get -b source packagename 下载编译 12通常会下载三个文件：一个.orig.tar.gz、一个.dsc和一个.diff.gz。对于Debian专用的软件包，不会下载最后一个文件，第一个文件的文 件名中没有&quot;orig&quot;项。 dpkg-source通过.dsc文件中的信息，将源码包解包到 packagename-version目录，下载下来的源码包中有一个 debian/目录，里面是创建.deb包所需的文件。想要下载的源码包自动编译成软件包，只需在命令行中加上-b如果你不打算在下载后就立刻创建.deb文件，你可以在之后用下面的命令创建： $ dpkg-buildpackage -rfakeroot -uc -b上述命令应当在下载后为软件包创建的目录中执行。要安装用这种方式构建好的 软件包，只能直接使用软件包管理器，例如： # dpkg -i file.deb 1gmc 1234567891011121314151617发现该软件包既不能重装又不能删除，试试下 面两个命令： # apt-get -f install # dpkg --configure -a当RPM安装好后，因为某些原因损坏了，或者在删除某些软件时候因为依赖性的关系，被删除了一部分，在使用的时候或者安装其他软件的时候，提示依赖性不能被解决。那么就需要重新安装，但是安装的时候提示你已经安装过了。这个时候就需要重新安装，或者强制安装。命令如下：# rpm -ivh --force 名称.rpm# rpm -ivh --force(这里必须是两个-,不是一个) --nodeps 名称.rpm rpm -e --force --nodeps XXXXXXXX 删除 以 snow-1.1.rpm 为例#rpm -ivh snow-1.1.rpm &#123; i：安装、v：详细信息、h：用#表示进度 &#125;#rpm -e snow &#123; 删除 &#125;#rpm -ivh --force snow-1.1.rpm &#123; 强制重装 &#125;#rpm -e --nodeps snow &#123; 去除内部相关性检查删除 snow， 不推荐使用&#125;#rpm -Uvh snow &#123;升级 &#125;#rpm -q snow &#123; 查询 &#125;#rpm -ql snow &#123; 查询 snow所拥有的文件 &#125;#rpm -qlc snow &#123; 查询snow的文档文件 &#125;#rpm -qld snow &#123; 查询snow的配置文件 &#125;#rpm -qp snow-1.1.rpm &#123; 查询文件，但不查询数据库 &#125;#rpm -qa &#123; 查询所有以安装的软件包 &#125;#rpm -qf /usr/X11R6/bin/snow &#123; 查询包的所有者 &#125;#rpm -qR snow-1.1.rpm &#123; 查询 snow包期望系统具有的情况 &#125;#rpm --checksig snow-1.1.rpm &#123; 验证完整性签名 &#125;#rpm -V snow &#123; 验证安装后是否被修改过 &#125; apt-file是一个软件包查找工具，可以查到软件包所含的文件和安装的位置。 apt-file update更新软件包的文件库，第一次使用或apt-get update后都需运行一次。apt-file search file_name查找该文件存在于哪些软件包中。apt-file list package_name显示该软件包的文件。 更新缓冲 yum update yum makecache yum search yum install 下载软件包 yumdownloader ** 下载软件包源码包 yumdownloader –source 重建rpm包 rpmbuild –rebuild 显示配置参数 rpmbuld –showrc 重建deb包","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"LFS经验","slug":"z_csdn_056_9949449","date":"2013-08-12T23:53:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/12/z_csdn_056_9949449/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_056_9949449/","excerpt":"","text":"1：选择比较新的lfs构建，不同的lfs版本发布的时候，对应着当时发行版的工具包版本，比如我做lfs的时候，就遇到了makefile格式新旧版本不兼容的问题 2：目标系统的文件系统使用ext2，否则你的grub就无法识别你的文件系统，找不到kernel文件 3：使用虚拟机做开发是个不错的选择，当你遇到了不懂并且不知道怎么处理的问题，虚拟机可以及时做一个系统快照，即使后边错误了，也可以快速的恢复之前的系统快照 4：虚拟机的好处是可以自定义主机的各种资源，包括串口，显示器等，回头我会尝试做一个lfs的制作专题 5：虚拟机可是使用vmware，virtualbox，qemu等，建议使用vmware和virtualbox，相关资料较多，遇到问题容易解决","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"SIP voip语音资料","slug":"z_csdn_065_9949421","date":"2013-08-12T23:42:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/12/z_csdn_065_9949421/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_065_9949421/","excerpt":"","text":"要在windows或者linux平台下开发基于SIP的软电话，需要以下软件 SIP客户端软件：主要用于测试，可以对别人已经完成的客户端进行抓包，以比对自己程序的发包数据 RTP栈：传输语言或者视频数据的协议栈 抓包测试工具：调试网络程序最有效的办法 以下介绍这些软件主要以开源软件为主 一 服务器端软件 Vocal：Linux系统下开源的SIP服务器端。可以作为IPPBX也可以作为运营系统。很多voip虚拟运营商都用这个作为自己的运营系统。提供BS结构的管理界面。http://www.vovida.org/ YATE：跨平台（Linux，Windows）的开源SIP服务器端。在windows下安装非常简单。其他方面没有进行过测试。http://yate.null.ro/pmwiki/ SER：Linux平台下重量级的SIP服务器断。功能比较丰富，也是很多voip虚拟运营商的系统选择。不过据说配置比较麻烦，具体没有试过。http://www.iptel.org/ser/ sipX：Linux平台下的SIP服务器。这个好像不能作为客户端再次注册到其他SIP服务器上。提供BS结构的管理界面。 http://www.sipfoundry.org 二 SIP客户端软件 Windows Messenger 5.1：微软出的SIP客户端，操作方便。 YATE Client：跨平台（Linux，Windows）的开源SIP客户端软件。安装方便，功能简单。http://yate.null.ro/pmwiki/ xten：windows平台下的SIP软电话。功能齐全，使用方便。http://www.xten.com/ 三 SIP协议栈 osip：跨平台的开源SIP协议栈。用c语言实现，体积小。http://www.gnu.org/software/osip/ exosip：对osip进行封装，使其方便SIP客户端软件开发。同样开源跨平台。http://savannah.nongnu.org/projects/exosip/ sipXtackLib：由SIPfoundry提供的开源跨平台的SIP协议栈，功能齐全。C++开发，已经被用于开发数个商业SIP终端。http://www.sipfoundry.org 四 RTP栈 JRTPLIB: 开源的跨平台rtp栈，用C++语言开发，使用方便。http://research.edm.uhasselt.be/~jori/page/index.php?n=CS.Jrtplib 五 抓包测试工具 Wireshark：非常有名的开源跨平台网络抓包工具，以前叫做Ethereal。http://www.wireshark.org/","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"通知并关闭指定的用户，ssh","slug":"z_csdn_020_9949331","date":"2013-08-12T23:40:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2013/08/12/z_csdn_020_9949331/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_020_9949331/","excerpt":"","text":"查看当前系统的用户，who，w 123456$ w15:05:42 up 4:49, 3 users, load average: 0.02, 0.01, 0.00USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATserver tty7 :0 14:06 4:43m 1:42 0.08s pam: gdm-passwoserver pts/0 :0.0 14:18 0.00s 0.23s 1.65s gnome-terminalserver pts/1 :0.0 14:47 4:43 0.01s 0.01s bash 123$ whobluebird tty1 2013-08-13 14:45 (:0)bluebird pts/0 2013-08-13 14:45 (:0.0) 通知特定用户 通过设备文件通知，设备文件可以通过who命令看到 1echo &quot;I will close your connection&quot; &gt; /dev/pts/2 关闭用户连接 1# fuser -k /dev/pts/2","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"linux软件包重新编译","slug":"z_csdn_017_9948965","date":"2013-08-12T23:32:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2013/08/12/z_csdn_017_9948965/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_017_9948965/","excerpt":"","text":"1这个估计要分成好多次才能写完了，包含rpm和deb两部分 rpm是redhat及类似系统的通用包管理系统，广泛用与各种发行版，feodra，centos等，二进制软件包格式为rpm，源码包围srpm 获取源码包 1yumdownloader --source vim 1yumdownloader --source vim 获取二进制包 1yumdownloader vim 重新编译源码包 1rpmbuild --rebuild vim.srpm 如果编译中提示缺少源码包，自己直接使用yum 安装缺少的库就行了 完整的rpm的构建过程，是基于rpm的一套mock系统，为目标机系统构建一套完整的开发环境，这里有空的话，我会专门分析一下，感谢nb的同事，我只需要分析实现就行了 deb是debian系统的通用包管理系统，mint，ubuutu，debian等多种流行的发行版使用deb 下载deb源码包，确保你的sources.list中包含src，如： 1deb-src http://http.us.debian.org/debian stable main contrib non-free 准备编译环境 1apt-get install dpkg-dev devscripts 获取源码包 1apt-get source less 安装编译依赖 1apt-get build-dep less 12cd less-*debuild -us -uc","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"0欧姆电阻的作用","slug":"z_csdn_072_9948945","date":"2013-08-12T23:19:38.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/12/z_csdn_072_9948945/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_072_9948945/","excerpt":"","text":"0欧姆电阻的作用 模拟地和数字地单点接地只要是地，最终都要接到一起，然后入大地。如果不接在一起就是”浮地”，存在压差，容易积累电荷，造成静电。地是参考0电位，所有电压都是参考地得出的，地的标准要一致，故各种地应短接在一起。人们认为大地能够吸收所有电荷，始终维持稳定，是最终的地参考点。虽然有些板子没有接大地，但发电厂是接大地的，板子上的电源最终还是会返回发电厂入地。如果把模拟地和数字地大面积直接相连，会导致互相干扰。不短接又不妥，理由如上有四种方法解决此问题：1、用磁珠连接； 2、用电容连接；3、用电感连接；4、用0欧姆电阻连接。 磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。电容隔直通交，造成浮地。电感体积大，杂散参数多，不稳定。0欧电阻相当于很窄的电流通路，能够有效地限制环路电流，使噪声得到抑制。电阻在所有频带上都有衰减作用(0欧电阻也有阻抗)，这点比磁珠强。 跨接时用于电流回路当分割电地平面后，造成信号最短回流路径断裂，此时，信号回路不得不绕道，形成很大的环路面积，电场和磁场的影响就变强了，容易干扰/被干扰。在分割区上跨接0欧电阻，可以提供较短的回流路径，减小干扰。 配置电路一般，产品上不要出现跳线和拨码开关。有时用户会乱动设置，易引起误会，为了减少维护费用，应用0欧电阻代替跳线等焊在板子上。 空置跳线在高频时相当于天线，用贴片电阻效果好。 其他用途布线时跨线 调试/测试用 临时取代其他贴片器件 作为温度补偿器件 更多时候是出于EMC对策的需要。另外，0欧姆电阻比过孔的寄生电感小，而且过孔还会影响地平面（因为要挖孔）。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"仿真器件类库归属","slug":"z_csdn_060_9948929","date":"2013-08-12T23:19:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/12/z_csdn_060_9948929/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_060_9948929/","excerpt":"","text":"1。Source库：包括电源、信号电压源、信号电流源、可控电压源、可控电流源、函数控制器件6个类。2。BASIC库：包含基础元件，如电阻、电容、电感、二极管、三极管、开关等；3。Diodes：二极管库，包含普通二极管、齐纳二极管、二极管桥、变容二极管、PIN二极管、发光二极管等。4。Transisitor库：三极管库，包含NPN、PNP、达林顿管、IGBT、MOS管、场效应管、可控硅等；5。Analog库：模拟器件库，包括运放、滤波器、比较器、模拟开关等模拟器件6。TTL库：包含TTL型数字电路 如7400 7404等门BJT电路。7。COMS库：COMS型数字电路 如74HC00 74HC04等MOS管电路。8。MCU Model： MCU模型，Multisim的单片机模型比较少，只有8051 PIC16的少数模型和一些ROM RAM等9。Advance Periphearls库：外围器件库，包含键盘、LCD、和一个显示终端的模型。10。MIXC Digital：混合数字电路库，包含DSP、CPLD、FPGA、PLD、单片机-微控制器、存储器件、一些接口电路等数字器件。11。Mixed：混合库，包含定时器、AC/DA转换芯片、模拟开关、震荡器等；12。Indicators：指示器库，包含电压表、电流表、探针、蜂鸣器、灯、数码管等等显示器件。13。Power：电源库，包含保险丝、稳压器、电压抑制、隔离电源等14。Misc：混合库，包含晶振、电子管、滤波器、MOS驱动、和其他一些器件等15。RF：RF库，包含一些RF器件，如高频电容电感、高频三极管等16。Elector Mechinical：电子机械器件库，包含传感开关、机械开关、继电器、电机等。。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"protel库中英对照","slug":"z_csdn_031_9948889","date":"2013-08-12T23:17:42.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2013/08/12/z_csdn_031_9948889/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_031_9948889/","excerpt":"","text":"protel库中英对照1.电阻固定电阻：RES半导体电阻：RESSEMT电位计；POT变电阻；RVAR可调电阻;res1….. 2.电容定值无极性电容；CAP定值有极性电容;CAP半导体电容：CAPSEMI可调电容：CAPVAR 3.电感：INDUCTOR 4.二极管：DIODE.LIB发光二极管：LED 5.三极管 :NPN1 6.结型场效应管：JFET.lib 7.MOS场效应管 8.MES场效应管 9.继电器：PELAY. LIB 10.灯泡:LAMP 11.运放:OPAMP 12.数码管：DPY_7-SEG_DP (MISCELLANEOUS DEVICES.LIB)13.开关;sw_pb原理图常用库文件：Miscellaneous Devices.ddbDallas Microprocessor.ddbIntel Databooks.ddbProtel DOS Schematic Libraries.ddb PCB元件常用库：Advpcb.ddbGeneral IC.ddbMiscellaneous.ddb 部分 分立元件库元件名称及中英对照AND 与门ANTENNA 天线BATTERY 直流电源BELL 铃,钟BVC 同轴电缆接插件BRIDEG 1 整流桥(二极管)BRIDEG 2 整流桥(集成块)BUFFER 缓冲器BUZZER 蜂鸣器CAP 电容CAPACITOR 电容CAPACITOR POL 有极性电容CAPVAR 可调电容CIRCUIT BREAKER 熔断丝COAX 同轴电缆CON 插口CRYSTAL 晶体整荡器DB 并行插口DIODE 二极管DIODE SCHOTTKY 稳压二极管DIODE VARACTOR 变容二极管DPY_3-SEG 3段LEDDPY_7-SEG 7段LEDDPY_7-SEG_DP 7段LED(带小数点)ELECTRO 电解电容FUSE 熔断器INDUCTOR 电感INDUCTOR IRON 带铁芯电感INDUCTOR3 可调电感JFET N N沟道场效应管JFET P P沟道场效应管LAMP 灯泡LAMP NEDN 起辉器LED 发光二极管METER 仪表MICROPHONE 麦克风MOSFET MOS管MOTOR AC 交流电机MOTOR SERVO 伺服电机NAND 与非门NOR 或非门NOT 非门NPN NPN三极管NPN-PHOTO 感光三极管OPAMP 运放OR 或门PHOTO 感光二极管PNP 三极管NPN DAR NPN三极管PNP DAR PNP三极管POT 滑线变阻器PELAY-DPDT 双刀双掷继电器RES1.2 电阻RES3.4 可变电阻RESISTOR BRIDGE ? 桥式电阻RESPACK ? 电阻SCR 晶闸管PLUG ? 插头PLUG AC FEMALE 三相交流插头SOCKET ? 插座SOURCE CURRENT 电流源SOURCE VOLTAGE 电压源SPEAKER 扬声器SW ? 开关SW-DPDY ? 双刀双掷开关SW-SPST ? 单刀单掷开关SW-PB 按钮THERMISTOR 电热调节器TRANS1 变压器TRANS2 可调变压器TRIAC ? 三端双向可控硅TRIODE ? 三极真空管VARISTOR 变阻器ZENER ? 齐纳二极管DPY_7-SEG_DP 数码管SW-PB 开关 其他元件库Protel Dos Schematic 4000 Cmos .Lib （40.系列CMOS管集成块元件库）4013 D 触发器4027 JK 触发器Protel Dos Schematic Analog Digital.Lib（模拟数字式集成块元件库）AD系列 DAC系列 HD系列 MC系列Protel Dos Schematic Comparator.Lib（比较放大器元件库）Protel Dos Shcematic Intel.Lib（INTEL公司生产的80系列CPU集成块元件库）Protel Dos Schematic Linear.lib（线性元件库）例555Protel Dos Schemattic Memory Devices.Lib（内存存储器元件库）Protel Dos Schematic SYnertek.Lib（SY系列集成块元件库）Protes Dos Schematic Motorlla.Lib（摩托罗拉公司生产的元件库）Protes Dos Schematic NEC.lib（NEC公司生产的集成块元件库）Protes Dos Schematic Operationel Amplifers.lib（运算放大器元件库）Protes Dos Schematic TTL.Lib（晶体管集成块元件库 74系列）Protel Dos Schematic Voltage Regulator.lib（电压调整集成块元件库）Protes Dos Schematic Zilog.Lib（齐格格公司生产的Z80系列CPU集成块元件库） 元件属性对话框中英文对照Lib ref 元件名称Footprint 器件封装Designator 元件称号Part 器件类别或标示值Schematic Tools 主工具栏Writing Tools 连线工具栏Drawing Tools 绘图工具栏 部分分立元件库元件名称及中英对照Power Objects 电源工具栏Digital Objects 数字器件工具栏Simulation Sources 模拟信号源工具栏PLD Toolbars 映象工具栏 原理图常用库文件：Miscellaneous Devices.ddbDallas Microprocessor.ddbIntel Databooks.ddbProtel DOS Schematic Libraries.ddbPCB元件常用库：Advpcb.ddbGeneral IC.ddbMiscellaneous.ddb分立元件库 部分 分立元件库元件名称及中英对照 AND 与门ANTENNA 天线BATTERY 直流电源BELL 铃,钟BVC 同轴电缆接插件BRIDEG 1 整流桥(二极管)BRIDEG 2 整流桥(集成块)BUFFER 缓冲器BUZZER 蜂鸣器CAP 电容CAPACITOR 电容CAPACITOR POL 有极性电容CAPVAR 可调电容CIRCUIT BREAKER 熔断丝COAX 同轴电缆CON 插口CRYSTAL 晶体整荡器DB 并行插口DIODE 二极管DIODE SCHOTTKY 稳压二极管DIODE VARACTOR 变容二极管DPY_3-SEG 3段LEDDPY_7-SEG 7段LEDDPY_7-SEG_DP 7段LED(带小数点)ELECTRO 电解电容FUSE 熔断器INDUCTOR 电感INDUCTOR IRON 带铁芯电感INDUCTOR3 可调电感JFET N N沟道场效应管JFET P P沟道场效应管LAMP 灯泡LAMP NEDN 起辉器LED 发光二极管METER 仪表MICROPHONE 麦克风MOSFET MOS管MOTOR AC 交流电机MOTOR SERVO 伺服电机NAND 与非门NOR 或非门NOT 非门NPN NPN三极管NPN-PHOTO 感光三极管OPAMP 运放OR 或门PHOTO 感光二极管PNP 三极管NPN DAR NPN三极管PNP DAR PNP三极管POT 滑线变阻器PELAY-DPDT 双刀双掷继电器RES1.2 电阻RES3.4 可变电阻RESISTOR BRIDGE ? 桥式电阻RESPACK ? 电阻SCR 晶闸管PLUG ? 插头PLUG AC FEMALE 三相交流插头SOCKET ? 插座SOURCE CURRENT 电流源SOURCE VOLTAGE 电压源SPEAKER 扬声器SW ? 开关SW-DPDY ? 双刀双掷开关SW-SPST ? 单刀单掷开关SW-PB 按钮THERMISTOR 电热调节器TRANS1 变压器TRANS2 可调变压器TRIAC ? 三端双向可控硅TRIODE ? 三极真空管VARISTOR 变阻器ZENER ? 齐纳二极管DPY_7-SEG_DP 数码管SW-PB 开关 其他元件库 Protel Dos Schematic 4000 Cmos .Lib 40.系列CMOS管集成块元件库 4013 D 触发器4027 JK 触发器Protel Dos Schematic Analog Digital.Lib 模拟数字式集成块元件库 AD系列 DAC系列 HD系列 MC系列 Protel Dos Schematic Comparator.Lib 比较放大器元件库Protel Dos Shcematic Intel.Lib INTEL公司生产的80系列CPU集成块元件库Protel Dos Schematic Linear.lib 线性元件库例555Protel Dos Schemattic Memory Devices.Lib 内存存储器元件库Protel Dos Schematic SYnertek.Lib SY系列集成块元件库Protes Dos Schematic Motorlla.Lib 摩托罗拉公司生产的元件库Protes Dos Schematic NEC.lib NEC公司生产的集成块元件库Protes Dos Schematic Operationel Amplifers.lib 运算放大器元件库Protes Dos Schematic TTL.Lib 晶体管集成块元件库 74系列Protel Dos Schematic Voltage Regulator.lib 电压调整集成块元件库Protes Dos Schematic Zilog.Lib 齐格格公司生产的Z80系列CPU集成块元件库 元件属性对话框中英文对照 Lib ref 元件名称Footprint 器件封装Designator 元件称号Part 器件类别或标示值Schematic Tools 主工具栏Writing Tools 连线工具栏Drawing Tools 绘图工具栏Power Objects 电源工具栏Digital Objects 数字器件工具栏Simulation Sources 模拟信号源工具栏PLD Toolbars 映象工具栏","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"protues元件库中英文对照表--数字电路仿真","slug":"z_csdn_005_9948877","date":"2013-08-12T23:17:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2013/08/12/z_csdn_005_9948877/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_005_9948877/","excerpt":"","text":"protues元件库中英文对照表，对初学者找不到元件的很有用 元件名称 中文名 说明 7407 驱动门 1N914 二极管 74Ls00 与非门 74LS04 非门 74LS08 与门 74LS390 TTL 双十进制计数器 7SEG 4针BCD-LED 输出从0-9 对应于4根线的BCD码 7SEG 3-8译码器电路BCD-7SEG转换电路 ALTERNATOR 交流发电机 AMMETER-MILLI mA安培计 AND 与门 BATTERY 电池/电池组 BUS 总线 CAP 电容 CAPACITOR 电容器 CLOCK 时钟信号源 CRYSTAL 晶振 D-FLIPFLOP D触发器 FUSE 保险丝 GROUND 地 LAMP 灯 LED-RED 红色发光二极管 LM016L 2行16列液晶 可显示2行16列英文字符，有8位数据总线D0-D7，RS，R/W，EN三个控制端口（共14线），工作电压为5V。没背光，和常用的1602B功能和引脚一样（除了调背光的二个线脚） LOGIC ANALYSER 逻辑分析器 LOGICPROBE 逻辑探针 LOGICPROBE[BIG] 逻辑探针 用来显示连接位置的逻辑状态 LOGICSTATE 逻辑状态 用鼠标点击,可改变该方框连接位置的逻辑状态 LOGICTOGGLE 逻辑触发 MASTERSWITCH 按钮 手动闭合,立即自动打开 MOTOR 马达 OR 或门 POT-LIN 三引线可变电阻器 POWER 电源 RES 电阻 RESISTOR 电阻器 SWITCH 按钮 手动按一下一个状态 SWITCH-SPDT 二选通一按钮 VOLTMETER 伏特计 VOLTMETER-MILLI mV伏特计 VTERM 串行口终端 Electromechanical 电机 Inductors 变压器 Laplace Primitives 拉普拉斯变换 Memory Ics Microprocessor Ics Miscellaneous 各种器件 AERIAL-天线；ATAHDD；ATMEGA64；BATTERY；CELL；CRYSTAL-晶振；FUSE；METER-仪表； Modelling Primitives 各种仿真器件 是典型的基本元器模拟，不表示具体型号，只用于仿真，没有PCB Optoelectronics 各种发光器件 发光二极管，LED，液晶等等 PLDs &amp; FPGAs Resistors 各种电阻 Simulator Primitives 常用的器件 Speakers &amp; Sounders Switches &amp; Relays 开关，继电器，键盘 Switching Devices 晶阊管 Transistors 晶体管（三极管，场效应管） TTL 74 series TTL 74ALS series TTL 74AS series TTL 74F series TTL 74HC series TTL 74HCT series TTL 74LS series TTL 74S series Analog Ics 模拟电路集成芯片 Capacitors 电容集合 CMOS 4000 series Connectors 排座，排插 Data Converters ADC,DAC Debugging Tools 调试工具 ECL 10000 Series 各种常用集成电路 protues常用器件2007-08-08 14:18分分立元件库元件名称及中英对照 AND 与门 ANTENNA 天线 BATTERY 直流电源 BELL 铃,钟 BVC 同轴电缆接插件 BRIDEG 1 整流桥(二极管) BRIDEG 2 整流桥(集成块) BUFFER 缓冲器 BUZZER 蜂鸣器 CAP 电容 CAPACITOR 电容 CAPACITOR POL 有极性电容 CAPVAR 可调电容 CIRCUIT BREAKER 熔断丝 COAX 同轴电缆 CON 插口 CRYSTAL 晶体整荡器 DB 并行插口 DIODE 二极管 DIODE SCHOTTKY 稳压二极管 DIODE VARACTOR 变容二极管 DPY_3-SEG 3段LED DPY_7-SEG 7段LED DPY_7-SEG_DP 7段LED(带小数点) ELECTRO 电解电容 FUSE 熔断器 INDUCTOR 电感 INDUCTOR IRON 带铁芯电感 INDUCTOR3 可调电感 JFET N N沟道场效应管 JFET P P沟道场效应管 LAMP 灯泡 LAMP NEDN 起辉器 LED 发光二极管 METER 仪表 MICROPHONE 麦克风 MOSFET MOS管 MOTOR AC 交流电机 MOTOR SERVO 伺服电机 NAND 与非门 NOR 或非门 NOT 非门 NPN NPN三极管 NPN-PHOTO 感光三极管 OPAMP 运放 OR 或门 PHOTO 感光二极管 PNP 三极管 NPN DAR NPN三极管 PNP DAR PNP三极管 POT 滑线变阻器 PELAY-DPDT 双刀双掷继电器 RES1.2 电阻 RES3.4 可变电阻 RESISTOR BRIDGE ? 桥式电阻 RESPACK ? 电阻 SCR 晶闸管 PLUG ? 插头 PLUG AC FEMALE 三相交流插头 SOCKET ? 插座 SOURCE CURRENT 电流源 SOURCE VOLTAGE 电压源 SPEAKER 扬声器 SW ? 开关 SW-DPDY ? 双刀双掷开关 SW-SPST ? 单刀单掷开关 SW-PB 按钮 THERMISTOR 电热调节器 TRANS1 变压器 TRANS2 可调变压器 TRIAC ? 三端双向可控硅 TRIODE ? 三极真空管 VARISTOR 变阻器 ZENER ? 齐纳二极管 DPY_7-SEG_DP 数码管 SW-PB 开关","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"电容器单位及电容器单位换算","slug":"z_csdn_045_9948833","date":"2013-08-12T23:15:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/12/z_csdn_045_9948833/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_045_9948833/","excerpt":"","text":"电容器单位，电容器单位换算电容的基本单位是：F （法），此外还有μF（微法）、pF（皮法），另外还有一个用的比较少的单位，那就是：nF（），由于电容 F 的容量非常大，所以我们看到的一般都是μF、nF、pF的单位，而不是F的单位。 1F=10^6uF=10^9nF=10^12pF 电容的基本单位用法拉(F)表示 1F=10^6uF=10^12pF 并联补偿所需电容的计算公式是：C＝P/2πfU2(tgφ1－tgφ) 式中：P－电源向负载供电的有功功率，单位是瓦； U－系统电压，单位是伏； F－系统频率，单位是赫； φ1－并联电容之前，负载的阻抗角； φ－并联电容之后，系统的阻抗角； C－补偿电容，单位是法。 进口电容的标识,基本单位,单位换算关系 例如：6G8=6.8G=6800μF；2P2=2.2pF；M33=0.33μF；68n=0。068μF有的电容器用数码表示，数码前2位为电容两有效数字，第3位有效数字后面”零的”个数。数码后缀J（5%）、K（10%）、M（20%）代表误差等级。如222K=2200PF+10%，应特别注意不要将Ｊ、Ｋ、Ｍ与我国电阻器标志相混，更不要把电容器误为电阻器。 1F＝1000000μF 105= 1 μF =1000nF=1000000pF 104= 0.1 μF 103= 0.01 μF =10000PF 102= 0.001 μF =1000PF 国产电容容量误差用符号F、G、J、K、L、M来表示。 允许误差分别对应为±1%、±2%、±5%、±10%、±15%、±20%。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"电容元件常规用法","slug":"z_csdn_049_9948821","date":"2013-08-12T23:15:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/12/z_csdn_049_9948821/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_049_9948821/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839401、应用于电源电路，实现旁路、去藕、滤波和储能的作用，下面分类详述之：1）旁路旁路电容是为本地器件提供能量的储能器件，它能使稳压器的输出均匀化，降低负载需求。就像小型可充电电池一样，旁路电容能够被充电，并向器件进行放 电。为尽量减少阻抗，旁路电容要尽量靠近负载器件的供电电源管脚和地管脚。这能够很好地防止输入值过大而导致的地电位抬高和噪声。地弹是地连接处在通过大 电流毛刺时的电压降。2）去藕去藕，又称解藕。从电路来说，总是可以区分为驱动的源和被驱动的负载。如果负载电容比较大，驱动电路要把电容充电、放电，才能完成信号的跳变，在上 升沿比较陡峭的时候，电流比较大，这样驱动的电流就会吸收很大的电源电流，由于电路中的电感，电阻（特别是芯片管脚上的电感，会产生反弹），这种电流相对 于正常情况来说实际上就是一种噪声，会影响前级的正常工作。这就是耦合。去藕电容就是起到一个电池的作用，满足驱动电路电流的变化，避免相互间的耦合干扰。将旁路电容和去藕电容结合起来将更容易理解。旁路电容实际也是去藕合的，只是旁路电容一般是指高频旁路，也就是给高频的开关噪声提高一条低阻抗泄防 途径。高频旁路电容一般比较小，根据谐振频率一般是0.1u，0.01u等，而去耦合电容一般比较大，是10uF或者更大，依据电路中分布参数，以及驱动 电流的变化大小来确定。旁路是把输入信号中的干扰作为滤除对象，而去耦是把输出信号的干扰作为滤除对象，防止干扰信号返回电源。这应该是他们的本质区别。3）滤波从理论上（即假设电容为纯电容）说，电容越大，阻抗越小，通过的频率也越高。但实际上超过1uF的电容大多为电解电容，有很大的电感成份，所以频率 高后反而阻抗会增大。有时会看到有一个电容量较大电解电容并联了一个小电容，这时大电容通低频，小电容通高频。电容的作用就是通高阻低，通高频阻低频。电 容越大低频越容易通过，电容越大高频越容易通过。具体用在滤波中,大电容(1000uF)滤低频，小电容(20pF)滤高频。曾有网友将滤波电容 比作&quot;水塘&quot;。由于电容的两端电压不会突变，由此可知，信号频率越高则衰减越大，可很形象的说电容像个水塘，不会因几滴水的加入或蒸发而引起水量的变化。 它把电压的变动转化为电流的变化，频率越高，峰值电流就越大，从而缓冲了电压。滤波就是充电，放电的过程。4）储能储能型电容器通过整流器收集电荷，并将存储的能量通过变换器引线传送至电源的输出端。电压额定值为40～450VDC、电容值在220～150 000uF之间的铝电解电容器（如EPCOS公司的 B43504或B43505）是较为常用的。根据不同的电源要求，器件有时会采用串联、并联或其组合的形式， 对于功率级超过10KW的电源，通常采用体积较大的罐形螺旋端子电容器。2、应用于信号电路，主要完成耦合、振荡/同步及时间常数的作用：1）耦合举个例子来讲，晶体管放大器发射极有一个自给偏压电阻，它同时又使信号产生压降反馈到输入端形成了输入输出信号耦合，这个电阻就是产生了耦合的元 件，如果在这个电阻两端并联一个电容，由于适当容量的电容器对交流信号较小的阻抗,这样就减小了电阻产生的耦合效应，故称此电容为去耦电容。2）振荡/同步包括RC、LC振荡器及晶体的负载电容都属于这一范畴。3）时间常数这就是常见的 R、C 串联构成的积分电路。当输入信号电压加在输入端时，电容（C）上的电压逐渐上升。而其充电电流则随着电压的上升而减小。电流通过电阻（R）、电容（C）的特性通过下面的公式描述： i = (V/R)e-(t/CR)","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"常用无源元件供应商，有点像广告","slug":"z_csdn_037_9948791","date":"2013-08-12T23:14:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2013/08/12/z_csdn_037_9948791/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_037_9948791/","excerpt":"","text":"电容/排容：A ：MURATA（村田）,TDK,TAIYO YUEN （太阳诱电）,KEMET（基美）,SAMSUNG（三星）,PANASONIC（松下）,FH （风华）,YAGEO （国巨）.等品牌全系各体积贴片电容和贴片排容；B ：KEMET,AVX VISHAY,SPRAGUE,等品牌贴片钽电容,直插径向和轴向进口钽电容；C ：进口与国产高压瓷片电容.C BB,涤纶电容；D ：贴片式与直插式红宝石,黑金刚,松下,ELNA 进口与国产品牌电解电容； 电阻/排阻：A ：风华,国巨YAGEO,ROHM,台湾厚声,台湾利智等品牌贴片电阻和排阻；B ：松下,村田等进口品牌可调电阻,BORU NS电位器；C ：锋华,台湾利智等品牌直插式排阻;D,国产及进口各品牌热敏电阻,压敏电阻,色环电阻等； 电感：A ：村田MURATA,TDK,PAN ASONIC,三星,TAIYO YUEN,等品牌贴片铁氧体叠层电感及贴片绕线电感；B ：TDK,村田,及各国产品牌直插式绕线电感,工字型电感,可根据客户特定要求提供样品.确认； 发光二极管LED：A ：台湾EVERLIGHT亿光,CITIZEN,EVERBRIGHT,佰鸿等品牌贴片各体积发光二极管；B ：台湾EVERLIGHT 亿光,,EVERBRIGHT,佰鸿等进口品牌及国产品牌直插式发光二极管全系列各规格； 贴片二.三极管：ON （安森美），NXP（飞利蒲），TOSHIBA（东芝），长电，ST 等品牌：肖特基、稳压、整流、开关、PIN 、发光、振荡、射频、复合、高频、场效应、单.双栅、鉮化镓、低噪音等晶体管； 晶振:村田MURATA 等进口品牌及国产各品牌晶振,49S 系列,49U 系列,圆柱2X6 系列,圆柱3 ＊8 系列,方形5 ＊7 系列,及各OSC 有源系列.型号齐全；","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"稳压二极管型号及国内外类似型号对照变","slug":"z_csdn_048_9948781","date":"2013-08-12T23:13:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/12/z_csdn_048_9948781/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_048_9948781/","excerpt":"","text":"稳压二极管型号 稳压二极管型号大全 稳压二极管型号对照表原型号 国外型号 稳压值 国内替代型号1N746 H23 MA4030 RD417E RD217EB 2.5-3.5 2CW51 1N747 1N748 1N749 HZ4 RD3.9E 3.9-4.5 2CW52 1N750 1N751 HZ5 05Z5.1 RD5A RD5.1E 4-5.8 2CW53 1N752 1N753 HZ6 HZ6.2E 05Z5.6E RD6A 5.5-6.5 2CW54 1N754 HZ6.8E 02Z6。8A RD6.8E RD7A 6.2-7.5 2CW55 1N755 1N756 HZ7 HZ7.5E 05Z7.5 RD7.5 7-8.5 2CW56 1N757 HZ9 RD9A 8.5-9.5 2CW57 1N758 HZ10A RD10E 9.2-10.5 2CW58 1N714 1N962 1S335 HZ11 HZ11E RD11E 10-11.8 2CW59 1N963 HZ12E 05Z12 BZX79C12 RD12E 11.5-12.5 2CW60 1N717 1N964 1S270 HZ12B2 MA1130 12.2-14 2CW61 1N718 1N965 1N966 HZ15-1 05Z15 RD15E 13.5-17 2CW62 1N967 HZ18-1 HZ18-2 05Z18 RD18E 16-19 2CW63 1N968 HZ20-1 RD20E 18-21 2CW64 1N969 HZ24E RD24E 20-24 2CW65 1N970 02Z24 23-26 2CW66 1N971 HZ27 25-28 2CW67 1N972 RD31E 27-32 2CW68 1N973 1N974 HZ733 ZX0249E UPC574J 31-35 2CW69 2CW70","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"PCB板层简介","slug":"z_csdn_050_9948741","date":"2013-08-12T23:11:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2013/08/12/z_csdn_050_9948741/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_050_9948741/","excerpt":"","text":"1PCB绘制电路板的资料了，当做系统备份了 1234567891011121314151617181920212223242526一、Signal Layers(信号层) Protel99提供了16个信号层：Top （顶层）、Bottom（底层）和Mid1-Mid14（14个中间层）。 信号层就是用来完成印制电路板铜箔走线的布线层。在设计双面板时，一般只使用Top（顶层）和Bottom（底层）两层，当印制电路板层数超过4层时，就需要使用Mid（中间布线层）。二、Internal Planes(内部电源/接地层) Protel99提供了Plane1-Plane4（4个内部电源/接地层）。内部电源/接地层主要用于4层以上印制电路板作为电源和接地专用布线层，双面板不需要使用。三、Mechanical Layers(机械层) 机械层一般用来绘制印制电路板的边框（边界），通常只需使用一个机械层。有Mech1-Mech4（4个机械层）。四、Drkll Layers(钻孔位置层) 共有2层：&quot;Drill Drawing&quot;和&quot;Drill Guide&quot;。用于绘制钻孔孔径和孔的定位。五、Solder Mask(阻焊层) 共有2层：Top（顶层）和Bottom（底层）。阻焊层上绘制的时印制电路板上的焊盘和过孔周围的保护区域。六、Paste Mask(锡膏防护层) 共有2层：Top（顶层）和Bottom（底层）。锡膏防护层主要用于有表面贴元器件的印制电路板，这时表帖元器件的安装工艺所需要的，无表帖元器件时不需要使用该层。七、Silkscreen(丝印层) 共有2层：Top（顶层）和Bottom（底层）。丝印层主要用于绘制文字说明和图形说明，如元器件的外形轮廓、标号和参数等。八、Other(其它层) 共有8层：&quot;Keep Out（禁止布线层）&quot;、&quot;Multi Layer（设置多层面）&quot;、&quot;Connect（连接层）&quot;&quot;DRC Error（错误层）&quot;、2个&quot;Visible Grid（可视网格层）&quot;&quot;Pad Holes（焊盘孔层）&quot;和&quot;Via Holes（过孔孔层）&quot;。其中有些层是系统自己使用的如Visible Grid（可视网格层）就是为了设计者在绘图时便于定位。而Keep Put（禁止布线层）是在自动布线时使用，手工布线不需要使用。 对于手工绘制双面印制电路板来说，使用最多的是Top Layers（顶层铜箔布线）、Bottom Layers（底层铜箔布线）和Top Silkscreen（顶层丝引层）。每一个图层都可以选择一个自己习惯的颜色，一般顶层用红色、底层用蓝色、文字及符号用绿色或白色、焊盘和过孔用黄色。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"S3C6410 启动脚本","slug":"z_csdn_024_9948695","date":"2013-08-12T23:10:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2013/08/12/z_csdn_024_9948695/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_024_9948695/","excerpt":"","text":"很久远的东西了，启动命令参数，针对uboot， setenv bootargs console=ttySAC0,115200 root=/dev/nfs nfsroot=10.140.28.13:/nfs/roofs ip= 10.140.28.26 : 10.140.28.10 : 10.140.28.10 :255.255.255.0:mini6410:eth0:off uboot设置参数 bootcmd=nand read.i c0008000 400000 500000;bootm c0008000 bootdelay=1 baudrate=115200 ethaddr=08:90:90:90:90:90 netmask=255.255.255.0 bootargs=console=ttySAC0,115200 stdin=serial stdout=serial stderr=serial ipaddr=10.140.28.26 gatewayip=10.140.28.1 serverip=10.140.28.26","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"整理一下学习的东西了","slug":"z_csdn_002_9948475","date":"2013-08-12T23:06:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2013/08/12/z_csdn_002_9948475/","link":"","permalink":"http://vball.fun/2013/08/12/z_csdn_002_9948475/","excerpt":"","text":"大学四年加上工作三年，觉得好多东西需要整理一下，不然很快就会忘记的的一干二净了。 大学的时候一直使用的一个记事本软件中间经历了一次重装系统，丢了大部分的东西，应该是囊括了互联网的各方各面，包括网站搭建，seo，编程，反汇编，调试什么的，可以随着时间的流逝，都渐渐的忘记的一干二净，只剩下几个核心单词还隐约记得，后来遇到了有道笔记，自己的文章收集才算是有了条理，不会因为某次系统crash丢失了资料，但也因为了工作的缘故，资料的收集上单一了许多，呵呵，有得必有失吧。 资料有收集的，有自己整理的，有摘抄的，如果谁看到了，觉得侵犯了他的版权，和我联系一下吧 代码的管理也是个悲剧，以前写过的很多代码都随着一次次系统更新变得凌乱，知道后来发现github这个网站，代码的整理也算是逐渐稳健了许多，看到国内的开源力量越来越大了，觉得自己也贡献自己的知识吧。 我的代码托管地址为：godvmxi.github.com，有兴趣的可以去看看，代码没多少，多数是clone别人的，也没给别人push request几次。算是个败笔了","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"完整且超简化的linux下stm32开发环境(编译，下载)---测试中","slug":"z_csdn_054_7664082","date":"2012-06-14T02:22:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2012/06/14/z_csdn_054_7664082/","link":"","permalink":"http://vball.fun/2012/06/14/z_csdn_054_7664082/","excerpt":"","text":"最近要用stm32开发产品，考虑到以前作高端arm,or32开发以及低端的avr开发都用gcc，因此为了降低学习难度和省钱，决定继续使用gcc。 经过搜索网络查阅资料，发现stm32的gcc支持虽然没有问题，但是对普通开发者而言，实在过于复杂，至少比avr-gcc复杂太多， 开发者在编写makefile之外，不得不自己搞定启动初始化代码，甚至自己要写ld文件，这实在不是件舒服的事。 因此，在参考网络诸多国内外的大侠提供的资料，综合自己的开发经验，经过一段时间完善，有了这个开发环境(并非集成开发环境IDE)， 实现了普通开发人员无须关心启动初始化代码和ld文件，简化makefile编写，大大降低stm32 gcc入门难度的目的。 详细功能包括： 1&gt;无须为自己的程序编写启动代码和ld描述文件，只需要写一个高度简化的makefile(提供了编写范例) 2&gt;支持最小改动源码情况下，生成可用IAP程序下载的带ROM OFFSET程序(通过makefile控制)，方便用户升级 3&gt;命令行方式下载程序到stm32电路板 4&gt;GUI方式使用IAP下载 注意：所有用到的程序均是开源且可免费获得，这里只是将它们综合起来使用 另：因为本人主要使用Linux环境开发，因此未对win32下进行测试，但是理论上应该是完全和cygwin环境兼容，没有问题。 首先用户自行下载stm32 gcc环境 注意下载EABI版本 SDK环境压缩文件 完整的开发环境设置，包括启动文件，ld文件，makefile模板，st官方fwlib及模板，详细看里面的readme.txt 由于目前手里只有stm32F103，ld文件模板只有这个的ROM(FLASH)方式，其他芯片模板可参考建立(已经进行了简化，很简单)，或者等以后俺添加 IAP示例 针对万利EK-STM32(STM3210B-LK1)的ST官方IAP实例移植及LED测试程序，注意，使用的按键是KEY2，当IAP已装入板子后，启动系统时 如果检测到KEY2为已经按下状态，则进入IAP模式，否则加载0x8002000起的应用程序 其中IAP部分makefile包含了如何使用wine调用win32下的stm32boot下载工具来下载iap.bin到目标板 由于IAP使用了ymodem协议，我使用了linux下可以和这个IAP协同工作的GUI程序cutecom，另还要安装lrzsz，cutecom会自动调用lrzsz， cutecom设置示意图如下： cutecom设置画面 注意IAP要求输入命令1时，移到input区输入键盘按键”1”即可 adc及lcd测试示例 同上，为修改的adc测试程序，额外添加了TIM测试,休眠测试,按键测试及浮点数计算等，默认编译需要使用IAP来下载它。 编程注意事项： 1&gt;makefile中，是通过添加OBJS += xxx.o来添加用户文件的，注意后缀不是.c 2&gt;makefile第一行指定SDK目录位置，自己按自己路径修改 3&gt;为了使同一个程序代码无须修改即可运行于rom offset模式(使用IAP加载) NVIC_Configuration中对应代码需要修改为如下 #ifdef VECT_TAB_RAM /* Set the Vector Table base location at 0x20000000 */ NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); #else /* VECT_TAB_FLASH */ NVIC_SetVectorTable(NVIC_VectTab_FLASH, ROM_OFFSET_SIZE); #endif","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"Ubuntu 10.04 LTS 安装 sun-java6-jdk 错误解决办法","slug":"z_csdn_025_7459764","date":"2012-04-13T09:22:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2012/04/13/z_csdn_025_7459764/","link":"","permalink":"http://vball.fun/2012/04/13/z_csdn_025_7459764/","excerpt":"","text":"最近一直想试着下载个android源码编译玩玩，结果sun-java6-jdk一直安装不上，现在回顾一下解决方法，其实很简单，android官方的编译环境指导有点小错误的（应该是sun-java-jdk的升级服务器变化所致） 官方指导： Java 6: for Gingerbread and newer 123$ sudo add-apt-repository &quot;deb http://archive.canonical.com/ lucid partner&quot;$ sudo apt-get update$ sudo apt-get install sun-java6-jdk Java 5: for Froyo and older 1234$ sudo add-apt-repository &quot;deb http://archive.ubuntu.com/ubuntu hardy main multiverse&quot;$ sudo add-apt-repository &quot;deb http://archive.ubuntu.com/ubuntu hardy-updates main multiverse&quot;$ sudo apt-get update$ sudo apt-get install sun-java5-jdk 结果一直错误。 错误提示还是一样： Reading package lists… DoneBuilding dependency treeReading state information… DonePackage sun-java6-jdk is not available, but is referred to by another package. This may mean that the package is missing, has been obsoleted, oris only available from another sourceE: Package sun-java6-jdk has no installation candidate 谷歌n久得到解决方案 Ubuntu 10.04 LTS 安装sun-java6-jdk ，出现错误。Reading package lists… DoneBuilding dependency treeReading state information… DonePackage sun-java6-jdk is not available, but is referred to by another package. This may mean that the package is missing, has been obsoleted, oris only available from another sourceE: Package sun-java6-jdk has no installation candidate说是Ubuntu 10.04已经去掉sun-java6-jdk 和sun-java6-jre的软件包 sudo add-apt-repository “deb http://archive.canonical.com/ lucid partner”sudo apt-get updatesudo apt-get install sun-java6-jdk 错误提示还是一样： Reading package lists… DoneBuilding dependency treeReading state information… DonePackage sun-java6-jdk is not available, but is referred to by another package. This may mean that the package is missing, has been obsoleted, oris only available from another sourceE: Package sun-java6-jdk has no installation candidate 这些都干过了。也查了源列表。。也有http://archive.canonical.com/ lucid partner，并且有了好几个。 求解。。。。 自己回答：在更新apt源头sudo apt-get update时出现如下提示： Ign http://extras.ubuntu.com oneiric/main Translation-en_USIgn http://archive.canonical.com lucid/partner Translation-en_USIgn http://archive.canonical.com lucid/partner Translation-enIgn http://extras.ubuntu.com oneiric/main Translation-enIgn http://us.archive.ubuntu.com jaunty/multiverse TranslationIndexIgn http://us.archive.ubuntu.com jaunty-updates/multiverse TranslationIndexIgn http://archive.canonical.com natty/partner Translation-en_USIgn http://archive.canonical.com natty/partner Translation-enHit http://us.archive.ubuntu.com oneiric/main Translation-enHit http://us.archive.ubuntu.com oneiric/multiverse Translation-enHit http://us.archive.ubuntu.com oneiric/restricted Translation-enHit http://us.archive.ubuntu.com oneiric/universe Translation-enHit http://us.archive.ubuntu.com oneiric-updates/main Translation-enHit http://us.archive.ubuntu.com oneiric-updates/multiverse Translation-enHit http://us.archive.ubuntu.com oneiric-updates/restricted Translation-enHit http://us.archive.ubuntu.com oneiric-updates/universe Translation-enHit http://us.archive.ubuntu.com oneiric-backports/main Translation-enHit http://us.archive.ubuntu.com oneiric-backports/multiverse Translation-enHit http://us.archive.ubuntu.com oneiric-backports/restricted Translation-enHit http://us.archive.ubuntu.com oneiric-backports/universe Translation-enErr http://us.archive.ubuntu.com jaunty/multiverse Sources404 Not Found [IP: 91.189.92.180 80]Err http://us.archive.ubuntu.com jaunty/multiverse amd64 Packages404 Not Found [IP: 91.189.92.180 80]Err http://us.archive.ubuntu.com jaunty/multiverse i386 Packages404 Not Found [IP: 91.189.92.180 80]Err http://us.archive.ubuntu.com jaunty-updates/multiverse Sources404 Not Found [IP: 91.189.92.180 80]Err http://us.archive.ubuntu.com jaunty-updates/multiverse amd64 Packages404 Not Found [IP: 91.189.92.180 80]Err http://us.archive.ubuntu.com jaunty-updates/multiverse i386 Packages404 Not Found [IP: 91.189.92.180 80]Ign http://us.archive.ubuntu.com jaunty/multiverse Translation-en_USIgn http://us.archive.ubuntu.com jaunty/multiverse Translation-enIgn http://us.archive.ubuntu.com jaunty-updates/multiverse Translation-en_USIgn http://us.archive.ubuntu.com jaunty-updates/multiverse Translation-enW: Failed to fetch http://us.archive.ubuntu.com/ubuntu/dists/jaunty/multiverse/source/Sources 404 Not Found [IP: 91.189.92.180 80] W: Failed to fetch http://us.archive.ubuntu.com/ubuntu/dists/jaunty/multiverse/binary-amd64/Packages 404 Not Found [IP: 91.189.92.180 80] W: Failed to fetch http://us.archive.ubuntu.com/ubuntu/dists/jaunty/multiverse/binary-i386/Packages 404 Not Found [IP: 91.189.92.180 80] W: Failed to fetch http://us.archive.ubuntu.com/ubuntu/dists/jaunty-updates/multiverse/source/Sources 404 Not Found [IP: 91.189.92.180 80] W: Failed to fetch http://us.archive.ubuntu.com/ubuntu/dists/jaunty-updates/multiverse/binary-amd64/Packages 404 Not Found [IP: 91.189.92.180 80] W: Failed to fetch http://us.archive.ubuntu.com/ubuntu/dists/jaunty-updates/multiverse/binary-i386/Packages 404 Not Found [IP: 91.189.92.180 80] E: Some index files failed to download. They have been ignored, or old ones used instead. 但是。。。cc@ubuntu:~$ sudo apt-get install sun-java6-jdkReading package lists… DoneBuilding dependency treeReading state information… DonePackage sun-java6-jdk is not available, but is referred to by another package. This may mean that the package is missing, has been obsoleted, oris only available from another source E: Package ‘sun-java6-jdk’ has no installation candidate？？？ 然后去学习一下下载的是什么东西··JDKJDK 是整个Java的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具和Java基础的类库（rt.jar）。不论什么Java应用服务器实质都是内置了某个版本的JDK.最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了自己的JDK，例如IBM公司开发的JDK，BEA公司的Jrocket，还有GNU组织开发的JDK等等。其中IBM的JDK包含的JVM（Java Virtual Machine）运行效率要比Sun JDK包含的JVM高出许多。而专门运行在x86平台的Jrocket在服务端运行效率也要比Sun JDK好很多。但不管怎么说，我们还是需要先把Sun JDK掌握好。JDK一般有三种版本：SE（J2SE），standard edition，标准版，是我们通常用的一个版本EE（J2EE），enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序，ME（J2ME），micro edtion，主要用于移动设备、嵌入式设备上的java应用程序Java开发工具（JDK）是许多Java专家最初使用的开发环境。尽管许多编程人员已经使用第三方的开发工具，但JDK仍被当作Java开发的重要工具。JDK由一个标准类库和一组建立，测试及建立文档的Java实用程序组成。其核心Java API是一些预定义的类库，开发人员需要用这些类来访问Java语言的功能。Java API包括一些重要的语言结构以及基本图形，网络和文件I/O.一般来说，Java API的非I/O部分对于运行Java的所有平台是相同的，而I/O部分则仅在通用Java环境中实现。作为JDK实用程序，工具库中有七种主要程序。◆Javac：Java编译器，将Java源代码转换成字节码。◆Java：Java解释器，直接从类文件执行Java应用程序字节代码。◆appletviewer：小程序浏览器，一种执行HTML文件上的Java小程序的Java浏览器。◆Javadoc：根据Java 源码及说明语句生成HTML文档。◆Jdb：Java调试器，可以逐行执行程序，设置断点和检查变量。◆Javah：产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件。◆Javap：Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示字节代码含义。JREJRE（Java Runtime Environment，Java运行环境），运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。是Sun的产品，包括两部分：JavaRuntimeEnvironment和JavaPlug-inJavaRuntimeEnvironment（JRE）是可以在其上运行、测试和传输应用程序的Java平台。它包括Java虚拟机、Java平台核心类和支持文件。它不包含开发工具——编译器、调试器和其它工具。JRE需要辅助软件 ——JavaPlug-in——以便在浏览器中运行applet.J2RE是Java2 Runtime Environment，即Java运行环境，有时简称JRE.如果你只需要运行Java程序或Applet，下载并安装它即可。如果你要自行开发Java软件，请下载JDK.在JDK中附带有JRE.注意由于Microsoft对Java的支持不完全，请不要使用IE自带的虚拟机来运行Applet，务必安装一个JRE或JDK. 最后实现办法1、添加这个源：deb http://us.archive.ubuntu.com/ubuntu/ hardy multiverse。2、sudo apt-get update3、sudo apt-get install sun-java6-jdk 最后一切ok，继续源码编译了","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"在Fedora 16上安装Nginx（带PHP-FPM）+PHP5和MySQL支持","slug":"z_csdn_006_8901528","date":"2012-02-21T20:00:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2012/02/21/z_csdn_006_8901528/","link":"","permalink":"http://vball.fun/2012/02/21/z_csdn_006_8901528/","excerpt":"","text":"但是我不发出任何保证，它一定会正常工作！ 1、初步说明在本教程中使用的主机名与IP地址192.168.0.100 server1.example.com。这些设置可能会有所不同，所以你在适当情况下不得不更换他们。 2、安装的MySQL 5首先，我们这样安装MySQL 5，终端输入命令： yum install mysql mysql-server 然后创建MySQL系统启动链接（这样MySQL在系统启动时自动启动）启动MySQL服务器： systemctl enable mysqld.service&lt;br&gt; systemctl start mysqld.service 现在，检查网络启用。运行 netstat -tap | grep mysql 如正常，会现实如下内容： 123[root@server1 ~]# netstat -tap | grep mysqltcp 0 0 *:mysql *:* LISTEN 1116/mysqld[root@server1 ~]# 如果不是这样，编辑/etc/my.cnf文件并注释掉选项skip-networking： 1234vi /etc/my.cnf#skip-networking 并重新启动MySQL服务器： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455systemctl restart mysqld.service`mysql_secure_installation`为根用户设置密码（否则任何人都可以访问你的MySQL数据库！）：[root@server1 ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MySQLSERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MySQL to secure it, we&#x27;ll need the currentpassword for the root user. If you&#x27;ve just installed MySQL, andyou haven&#x27;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none):Setting the root password ensures that nobody can log into the MySQLroot user without the proper authorisation.Set root password? [Y/n]By default, a MySQL installation has an anonymous user, allowing anyoneto log into MySQL without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n]Normally, root should only be allowed to connect from &#x27;localhost&#x27;. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n]By default, MySQL comes with a database named &#x27;test&#x27; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n]Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n]Cleaning up...All done! If you&#x27;ve completed all of the above steps, your MySQLinstallation should now be secure.Thanks for using MySQL![root@server1 ~]# 3、安装Nginx的直接运行如下命令： 12345yum install nginx然后我们创建系统启动nginx的链接，并启动它：`systemctl enable nginx.service&lt;br&gt; systemctl start nginx.service` 在您的Web服务器的IP地址或主机到浏览器（如http://192.168.0.100），你应该看到nginx的欢迎页面类型： 4、安装PHP5需要安装一些列的模块，输入以下命令： 1yum install php-fpm php-cli php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-eaccelerator php-magickwand php-mbstring php-mcrypt php-mssql php-shout php-snmp php-soap php-tidy 然后打开的/etc/php.ini并设定cgi.fix_pathinfo = 0： 123456789101112vi /etc/php.ini; cgi.fix_pathinfo provides *real* PATH_INFO/PATH_TRANSLATED support for CGI. PHP&#x27;s; previous behaviour was to set PATH_TRANSLATED to SCRIPT_FILENAME, and to not grok; what PATH_INFO is. For more information on PATH_INFO, see the cgi specs. Setting; this to 1 will cause PHP CGI to fix its paths to conform to the spec. A setting; of zero causes PHP to behave as before. Default is 1. You should fix your scripts; to use SCRIPT_FILENAME rather than PATH_TRANSLATED.; http://www.php.net/manual/en/ini.core.php#ini.cgi.fix-pathinfocgi.fix_pathinfo=0 此外，以避免类似以下错误 1[13-Nov-2011 22:13:16] PHP Warning: phpinfo(): It is not safe to rely on the system&#x27;s timezone settings. You are *required* to use the date.timezone setting or the date_default_timezone_set() function. In case you used any of those methods and you are still getting this warning, you most likely misspelled the timezone identifier. We selected &#x27;Europe/Berlin&#x27; for &#x27;CET/1.0/no DST&#x27; instead in /usr/share/nginx/html/info.php on line 2 /var/log/php-fpm/www-error.log 中，当你调用一个PHP脚本在您的浏览器，你应该在/etc/php.ini文件中设置date.timezone： 1234[Date]; Defines the default timezone used by the date functions; http://www.php.net/manual/en/datetime.configuration.php#ini.date.timezonedate.timezone = &quot;Europe/Berlin&quot; 你可以找到正确的时区为您的系统，运行命令： 12345cat /etc/sysconfig/clock[root@server1 ~]# cat /etc/sysconfig/clockZONE=&quot;Europe/Berlin&quot;[root@server1 ~]# 下一步创建系统启动或者PHP-FPM并启动它： 1`systemctl enable php-fpm.service&lt;br&gt; systemctl start php-fpm.service` PHP-FPM是一个守护进程运行FastCGI服务器的端口9000。5、nginx设置输入命令： 1vi /etc/nginx/nginx.conf 配置是很容易理解。你可以再以下网址了解更多配置信息： 按照以下配置设置值： 12worker_processes 4;keepalive_timeout 2; 虚拟主机是指在服务器{}容器。默认的虚拟主机是指在该文件 /etc/nginx/conf.d/default.conf -让我们作如下修改： 12345678910111213141516171819202122232425262728293031323334353637383940server &#123;listen 80;server_name _;#charset koi8-r;#access_log logs/host.access.log main;location / &#123;root /usr/share/nginx/html;index index.php index.html index.htm;&#125;error_page 404 /404.html;location = /404.html &#123;root /usr/share/nginx/html;&#125;# redirect server error pages to the static page /50x.html#error_page 500 502 503 504 /50x.html;location = /50x.html &#123;root /usr/share/nginx/html;&#125;# proxy the PHP scripts to Apache listening on 127.0.0.1:80##location ~ \\.php$ &#123;# proxy_pass http://127.0.0.1;#&#125;# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \\.php$ &#123;root /usr/share/nginx/html;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125;# deny access to .htaccess files, if Apache&#x27;s document root# concurs with nginx&#x27;s one#location ~ /\\.ht &#123;deny all;&#125;&#125; 保存和重启服务： systemctl reload nginx.service 现在你可以建立一个探针文件进行测试 6、建立 PHP-FPM 使用一个 Unix Socket vi /etc/php-fpm.d/www.conf 12;listen = 127.0.0.1:9000listen = /tmp/php5-fpm.sock 重启PHP-FPM systemctl restart php-fpm.service 配置文件： vi /etc/nginx/conf.d/default.conf 配置内容如下： 1234567location ~ \\.php$ &#123;root /usr/share/nginx/html;fastcgi_pass unix:/tmp/php5-fpm.sock;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125; 重启Nginx: systemctl reload nginx.service 文章参考：","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"管道 非阻塞 duxie","slug":"z_csdn_012_6942837","date":"2012-01-03T23:51:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2012/01/03/z_csdn_012_6942837/","link":"","permalink":"http://vball.fun/2012/01/03/z_csdn_012_6942837/","excerpt":"","text":"抵扣说明： 1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。2.余额无法直接购买下载，可以购买VIP、C币套餐、付费专栏及课程。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"关于Linux静态库和动态库的分析","slug":"z_csdn_004_7020169","date":"2011-11-27T16:00:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/11/27/z_csdn_004_7020169/","link":"","permalink":"http://vball.fun/2011/11/27/z_csdn_004_7020169/","excerpt":"","text":"关于Linux静态库和动态库的分析来源: ChinaUnix博客 日期： 2009.02.04 11:54 (共有条评论) 我要评论 1.什么是库在windows平台和linux平台下都大量存在着库。本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。由于windows和linux的本质不同，因此二者库的二进制是不兼容的。本文仅限于介绍linux下的库。2.库的种类linux下的库有两种：静态库和共享库（动态库）。二者的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。3.库存在的意义库是别人写好的现有的，成熟的，可以复用的代码，你可以使用但要记得遵守许可协议。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。共享库的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。4.库文件是如何产生的在linux下静态库的后缀是.a，它的产生分两步Step 1.由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表Step 2.ar命令将很多.o转换成.a，成文静态库动态库的后缀是.so，它由gcc加特定参数编译产生。例如: 1$ gcc -fPIC -c *.c $ gcc -shared -Wl,-soname, libfoo.so.1 -o libfoo.so.1.0 *. 5.库文件是如何命名的，有没有什么规范在linux下，库文件一般放在/usr/lib /lib下，静态库的名字一般为libxxxx.a，其中xxxx是该lib的名称动态库的名字一般为libxxxx.so.major.minor，xxxx是该lib的名称，major是主版本号， minor是副版本号6.如何知道一个可执行程序依赖哪些库ldd命令可以查看一个可执行程序依赖的共享库，例如# ldd /bin/lnlibc.so.6=&gt; /lib/libc.so.6 (0×40021000)/lib/ld-linux.so.2=&gt; /lib/ld- linux.so.2 (0×40000000)可以看到ln命令依赖于libc库和ld-linux库7.可执行程序在执行的时候如何定位共享库文件当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径此时就需要系统动态载入器(dynamic linker/loader)对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib目录找到库文件后将其载入内存8.在新安装一个库之后如何让系统能够找到他如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下1.编辑/etc/ld.so.conf文件，加入库文件所在目录的路径2.运行ldconfig，该命令会重建/etc/ld.so.cache文件 我们通常把一些公用函数制作成函数库，供其它程序使用。函数库分为静态库和动态库两种。静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。本文主要通过举例来说明在Linux中如何创建静态库和动态库，以及使用它们。在创建函数库前，我们先来准备举例用的源程序，并将函数库的源程序编译成.o文件。第1步：编辑得到举例的程序–hello.h、hello.c和main.c；hello.h(见程序1)为该函数库的头文件。hello.c(见程序2)是函数库的源程序，其中包含公用函数hello，该函数将在屏幕上输出”Hello XXX!”。main.c(见程序3)为测试库文件的主程序，在主程序中调用了公用函数hello。程序1: hello.h#ifndef HELLO_H#define HELLO_H void hello(const char *name); #endif //HELLO_H程序2: hello.c#include void hello(const char *name){printf(“Hello %s!\\n”, name);}程序3: main.c#include “hello.h” int main(){hello(“everyone”);return 0;}第2步：将hello.c编译成.o文件；无论静态库，还是动态库，都是由.o文件创建的。因此，我们必须将源程序hello.c通过gcc先编译成.o文件。在系统提示符下键入以下命令得到hello.o文件。 gcc -c hello.c(注1：本文不介绍各命令使用和其参数功能，若希望详细了解它们，请参考其他文档。)(注2：首字符”#”是系统提示符，不需要键入，下文相同。)我们运行ls命令看看是否生存了hello.o文件。 lshello.c hello.h hello.o main.c#(注3：首字符不是”#”为系统运行结果，下文相同。)在ls命令结果中，我们看到了hello.o文件，本步操作完成。下面我们先来看看如何创建静态库，以及使用它。第3步：由.o文件创建静态库；静态库文件名的命名规范是以lib为前缀，紧接着跟静态库名，扩展名为.a。例如：我们将创建的静态库名为myhello，则静态库文件名就是libmyhello.a。在创建和使用静态库时，需要注意这点。创建静态库用ar命令。在系统提示符下键入以下命令将创建静态库文件libmyhello.a。 ar cr libmyhello.a hello.o我们同样运行ls命令查看结果： lshello.c hello.h hello.o libmyhello.a main.c#ls命令结果中有libmyhello.a。第4步：在程序中使用静态库；静态库制作完了，如何使用它内部的函数呢？只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明，然后在用gcc命令生成目标文件时指明静态库名，gcc将会从静态库中将公用函数连接到目标文件中。注意，gcc会在静态库名前加上前缀lib，然后追加扩展名.a得到的静态库文件名来查找静态库文件。在程序3:main.c中，我们包含了静态库的头文件hello.h，然后在主程序main中直接调用公用函数hello。下面先生成目标程序hello，然后运行hello程序看看结果如何。 gcc -o hello main.c -L. -lmyhello./helloHello everyone! 我们删除静态库文件试试公用函数hello是否真的连接到目标文件 hello中了。 rm libmyhello.arm: remove regular file `libmyhello.a’? y ./helloHello everyone! 程序照常运行，静态库中的公用函数已经连接到目标文件中了。我们继续看看如何在Linux中创建动态库。我们还是从.o文件开始。第5步：由.o文件创建动态库文件；动态库文件名命名规范和静态库文件名命名规范类似，也是在动态库名增加前缀lib，但其文件扩展名为.so。例如：我们将创建的动态库名为myhello，则动态库文件名就是libmyhello.so。用gcc来创建动态库。在系统提示符下键入以下命令得到动态库文件libmyhello.so。 gcc -shared -fPCI -o libmyhello.so hello.o我们照样使用ls命令看看动态库文件是否生成。 lshello.c hello.h hello.o libmyhello.so main.c#第6步：在程序中使用动态库；在程序中使用动态库和使用静态库完全一样，也是在使用到这些公用函数的源程序中包含这些公用函数的原型声明，然后在用gcc命令生成目标文件时指明动态库名进行编译。我们先运行gcc命令生成目标文件，再运行它看看结果。 gcc -o hello main.c -L. -lmyhello./hello./hello: error while loading shared libraries: libmyhello.so: cannot open shared object file: No such file or directory#哦！出错了。快看看错误提示，原来是找不到动态库文件libmyhello.so。程序在运行时，会在/usr/lib和/lib等目录中查找需要的动态库文件。若找到，则载入动态库，否则将提示类似上述错误而终止程序运行。我们将文件libmyhello.so复制到目录/usr/lib中，再试试。 mv libmyhello.so /usr/lib./hello./hello: error while loading shared libraries: /usr/lib/libhello.so: cannot restore segment prot after reloc: Permission denied由于SELinux引起， chcon -t texrel_shlib_t /usr/lib/libhello.so./helloHello everyone! 成功了。这也进一步说明了动态库在程序运行时是需要的。我们回过头看看，发现使用静态库和使用动态库编译成目标程序使用的gcc命令完全一样，那当静态库和动态库同名时，gcc命令会使用哪个库文件呢？抱着对问题必究到底的心情，来试试看。先删除 除.c和.h外的 所有文件，恢复成我们刚刚编辑完举例程序状态。 rm -f hello hello.o /usr/lib/libmyhello.solshello.c hello.h main.c#在来创建静态库文件libmyhello.a和动态库文件libmyhello.so。 gcc -c hello.car cr libmyhello.a hello.ogcc -shared -fPCI -o libmyhello.so hello.olshello.c hello.h hello.o libmyhello.a libmyhello.so main.c#通过上述最后一条ls命令，可以发现静态库文件libmyhello.a和动态库文件libmyhello.so都已经生成，并都在当前目录中。然后，我们运行gcc命令来使用函数库myhello生成目标文件hello，并运行程序 hello。 gcc -o hello main.c -L. -lmyhello./hello./hello: error while loading shared libraries: libmyhello.so: cannot open shared object file: No such file or directory#从程序hello运行的结果中很容易知道，当静态库和动态库同名时， gcc命令将优先使用动态库。基本概念库有动态与静态两种，动态通常用.so为后缀，静态用.a为后缀。例如：libhello.so libhello.a 为了在同一系统中使用不同版本的库，可以在库文件名后加上版本号为后缀,例如： libhello.so.1.0,由于程序连接默认以.so为文件后缀名。所以为了使用这些库，通常使用建立符号连接的方式。ln -s libhello.so.1.0 libhello.so.1ln -s libhello.so.1 libhello.so1、使用库当要使用静态的程序库时，连接器会找出程序所需的函数，然后将它们拷贝到执行文件，由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。然 而，对动态库而言，就不是这样。动态库会在执行程序内留下一个标记指明当程序执行时，首先必须载入这个库。由于动态库节省空间，linux下进行连接的缺省操作是首先连接动态库，也就是说，如果同时存在静态和动态库，不特别指定的话，将与动态库相连接。 现在假设有一个叫hello的程序开发包，它提供一个静态库libhello.a 一个动态库libhello.so,一个头文件hello.h,头文件中提供sayhello()这个函数 /* hello.h */ void sayhello(); 另外还有一些说明文档。这一个典型的程序开发包结构 与动态库连接 linux默认的就是与动态库连接，下面这段程序testlib.c使用hello库中的sayhello()函数/testlib.c/#include#includeint main(){sayhello();return 0;}使用如下命令进行编译 $gcc -c testlib.c -o testlib.o用如下命令连接： $gcc testlib.o -lhello -o testlib连接时要注意，假设libhello.o 和libhello.a都在缺省的库搜索路径下/usr/lib下，如果在其它位置要加上-L参数 与与静态库连接麻烦一些，主要是参数问题。还是上面的例子：$gcc testlib.o -o testlib -WI,-Bstatic -lhello注：这个特别的”-WI，-Bstatic”参数，实际上是传给了连接器ld。指示它与静态库连接，如果系统中只有静态库当然就不需要这个参数了。 如果要和多个库相连接，而每个库的连接方式不一样，比如上面的程序既要和libhello进行静态连接，又要和libbye进行动态连接，其命令应为：$gcc testlib.o -o testlib -WI,-Bstatic -lhello -WI,-Bdynamic -lbye 2、动态库的路径问题 为了让执行程序顺利找到动态库，有三种方法：(1)把库拷贝到/usr/lib和/lib目录下。(2)在LD_LIBRARY_PATH环境变量中加上库所在路径。例如动态库libhello.so在/home/ting/lib目录下，以bash为例，使用命令：$export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/ting/lib(3) 修改/etc/ld.so.conf文件，把库所在的路径加到文件末尾，并执行ldconfig刷新。这样，加入的目录下的所有库文件都可见。3、查看库中的符号有时候可能需要查看一个库中到底有哪些函数，nm命令可以打印出库中的涉及到的所有符号。库既可以是静态的也可以是动态的。nm列出的符号有很多，常见的有三种：一种是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；一种是库中定义的函数，用T表示，这是最常见的；另外一种是所谓的”弱 态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。例如，假设开发者希望知道上文提到的hello库中是否定义了 printf():$nm libhello.so |grep printf U其中printf U表示符号printf被引用，但是并没有在函数内定义，由此可以推断，要正常使用hello库，必须有其它库支持，再使用ldd命令查看hello依赖于哪些库：$ldd hello libc.so.6=&gt;/lib/libc.so.6(0x400la000) /lib/ld-linux.so.2=&gt;/lib/ld-linux.so.2 (0x40000000)从上面的结果可以继续查看printf最终在哪里被定义，有兴趣可以go on4、生成库第一步要把源代码编绎成目标代码。以下面的代码为例，生成上面用到的hello库： 123456/* hello.c */#includevoid sayhello()&#123;printf(&quot;hello,world &quot;);&#125; 用gcc编绎该文件，在编绎时可以使用任何全法的编绎参数，例如-g加入调试代码等： gcc -c hello.c -o hello.o(1)连接成静态库 连接成静态库使用ar命令，其实ar是archive的意思$ar cqs libhello.a hello.o(2)连接成动态库 生成动态库用gcc来完成，由于可能存在多个版本，因此通常指定版本号：$gcc -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0 hello.o另外再建立两个符号连接：$ln -s libhello.so.1.0 libhello.so.1$ln -s libhello.so.1 libhello.so这样一个libhello的动态连接库就生成了。最重要的是传gcc -shared 参数使其生成是动态库而不是普通执行程序。 -Wl 表示后面的参数也就是-soname,libhello.so.1直接传给连接器ld进行处理。实际上，每一个库都有一个soname，当连接器发现它正在查找的程序库中有这样一个名称，连接器便会将soname嵌入连结中的二进制文件内，而不是它正在运行的实际文件名，在程序执行期间，程序会查找拥有 soname名字的文件，而不是库的文件名，换句话说，soname是库的区分标志。 这样做的目的主要是允许系统中多个版本的库文件共存，习惯上在命名库文件的时候通常与soname相同 libxxxx.so.major.minor 其中，xxxx是库的名字，major是主版本号，minor 是次版本号","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"USB启动 WinPE修改制作十大神器","slug":"z_csdn_022_7009847","date":"2011-11-24T05:42:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/11/24/z_csdn_022_7009847/","link":"","permalink":"http://vball.fun/2011/11/24/z_csdn_022_7009847/","excerpt":"","text":"BOOTICE 是一个启动相关的维护的小工具，主要用于安装、修复、备份和恢复磁盘或磁盘镜像（*.IMG;.IMA;.VHD）的 MBR（Master Boot Record）或分区上的 PBR（Partition Boot Record），以及对 Windows Vista/7/2008 启动配置文件 BCD 的编辑功能。此外还具有磁盘分区管理，对可移动磁盘的重新分区和格式化功能。不多说：绝对的神器啊！！ GRUB4DOS是一个优秀的双(多)系统引导软件，使用GRUB4DOS可以很方便的引导各种操作系统，比如DOS、Windows、 Linux等。因为其很酷很强大又很方便的特点，目前使用的非常广泛。风吟PE系统用的就是它。 message文件的制作工具，，可以很方便简单快捷的制作出自己的启动背景图，而且是目前message制作工具中唯一带有预览功能的工具，很酷，很实用，相信你一定需要它。 又是一款很酷的工具，制作好的启动U盘可以直接用它来测试看效果。不必频繁的一次又一次的重启电脑来测试了，做PE的时候给我省力不少啊！！我的功臣啊，呵呵。 这个东西可能会让你觉得陌生，，做什么用的那？呵呵，用它可以修改PE里面的wim文件，，这样你就可以定义自己的软件包然后放进PE里面，是不是很酷那？ 一个只有10k的小工具，，别看它小，，贵在实用，PE的内核很多都是im_格式的，大家注意没有注意风吟PE的内核文件，文件名：winpe.im_ PE的注册表信息，OEM信息都需要通过内核修改来定义。但是当看到winpe.im_ 这个文件是不是感觉一头雾水，不知道这是个什么东东，，怎么打开都不知道，，又怎么去修改那？拿风吟PE为例，直接修改扩展名为cab然后再用winrar解压，得到的文件是winpe.img，然后就可以用WinImage打开了，，替换OEM信息，或者找到注册表文件挂载修改。而这个工具的作用就是可以把你修改好的winpe.img重新压缩成winpe.im_。 不用多说，你懂的，，呵呵。一款功能强大而又方便实用的光盘映像文件制作/编辑/转换工具，它可以直接编辑ISO文件和从ISO中提取文件和目录，也可以从CD-ROM制作光盘映像或者将硬盘上的文件制作成ISO文件。同时，你也可以处理ISO文件的启动信息，从而制作可引导光盘。使用UltraISO，你可以随心所欲地制作/编辑/转换光盘映像文件，配合光盘刻录软件烧录出自己所需要的光碟。 非常优秀的软盘映像修改工具。它能非常方便的将软盘上的内容以映像文件的形式保存到磁盘上。由于其的压缩比例非常的高，从而能大大节约硬盘的使用空间。其能制作的映像文件的类型有两种，一类是IMA格式的普通映像文件格式，另外一种则是IMZ格式的超压缩文件格式，从字面上的解释我们就知道，IMZ比IMA的格式在压缩比例上更高，但是压缩和解压缩的时间比较长。除了能在硬盘上保存文件的镜像文本以外，它还能轻松的进行软盘之间的拷贝。您只需要插入源盘后单击工具栏上的”Read disks”按钮，Winimage会自动将源盘中的内容读到内存缓冲区中，然后换入目标盘后再单击工具栏上的”Write disk”或”Format and write disk”按钮，将内存缓冲区中的内容写到目标盘上即可实现备份的目的。 别惊讶，之所以放上来是因为在你写启动菜单的时候他可以给你很好的帮助，比你像没头苍蝇一样乱撞的效果要好的多！","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"脚本指南","slug":"z_csdn_057_6989602","date":"2011-11-18T04:16:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2011/11/18/z_csdn_057_6989602/","link":"","permalink":"http://vball.fun/2011/11/18/z_csdn_057_6989602/","excerpt":"","text":"抵扣说明： 1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。2.余额无法直接购买下载，可以购买VIP、C币套餐、付费专栏及课程。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"linux的线程同步机制","slug":"z_csdn_039_6947902","date":"2011-11-07T22:11:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/11/07/z_csdn_039_6947902/","link":"","permalink":"http://vball.fun/2011/11/07/z_csdn_039_6947902/","excerpt":"","text":"尽管在Posix Thread中同样可以使用IPC的信号量机制来实现互斥锁mutex功能，但显然semphore的功能过于强大了，在Posix Thread中定义了另外一套专门用于线程同步的mutex函数。 有两种方法创建互斥锁，静态方式和动态方式。POSIX定义了一个宏PTHREAD_MUTEX_INITIALIZER来静态初始化互斥锁，方法如下： pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER; 在LinuxThreads实现中，pthread_mutex_t是一个结构，而PTHREAD_MUTEX_INITIALIZER则是一个结构常量。 动态方式是采用pthread_mutex_init()函数来初始化互斥锁，API定义如下： int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr) 其中mutexattr用于指定互斥锁属性（见下），如果为NULL则使用缺省属性。 pthread_mutex_destroy()用于注销一个互斥锁，API定义如下： int pthread_mutex_destroy(pthread_mutex_t *mutex) 销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的pthread_mutex_destroy()除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。 互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。当前（glibc2.2.3,linuxthreads0.9）有四个值可供选择： PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。 PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。 PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。 PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。 锁操作主要包括加锁pthread_mutex_lock()、解锁pthread_mutex_unlock()和测试加锁pthread_mutex_trylock()三个，不论哪种类型的锁，都不可能被两个不同的线程同时得到，而必须等待解锁。对于普通锁和适应锁类型，解锁者可以是同进程内任何线程；而检错锁则必须由加锁者解锁才有效，否则返回EPERM；对于嵌套锁，文档和实现要求必须由加锁者解锁，但实验结果表明并没有这种限制，这个不同目前还没有得到解释。在同一进程中的线程，如果加锁后没有解锁，则任何其他线程都无法再获得锁。 123int pthread_mutex_lock(pthread_mutex_t *mutex)int pthread_mutex_unlock(pthread_mutex_t *mutex)int pthread_mutex_trylock(pthread_mutex_t *mutex) pthread_mutex_trylock()语义与pthread_mutex_lock()类似，不同的是在锁已经被占据时返回EBUSY而不是挂起等待。 POSIX线程锁机制的Linux实现都不是取消点，因此，延迟取消类型的线程不会因收到取消信号而离开加锁等待。值得注意的是，如果线程在加锁后解锁前被取消，锁将永远保持锁定状态，因此如果在关键区段内有取消点存在，或者设置了异步取消类型，则必须在退出回调函数中解锁。 这个锁机制同时也不是异步信号安全的，也就是说，不应该在信号处理过程中使用互斥锁，否则容易造成死锁。 条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。 条件变量和互斥锁一样，都有静态动态两种创建方式，静态方式使用PTHREAD_COND_INITIALIZER常量，如下：pthread_cond_t cond=PTHREAD_COND_INITIALIZER 动态方式调用pthread_cond_init()函数，API定义如下：int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr) 尽管POSIX标准中为条件变量定义了属性，但在LinuxThreads中没有实现，因此cond_attr值通常为NULL，且被忽略。 注销一个条件变量需要调用pthread_cond_destroy()，只有在没有线程在该条件变量上等待的时候才能注销这个条件变量，否则返回EBUSY。因为Linux实现的条件变量没有分配什么资源，所以注销动作只包括检查是否有等待线程。API定义如下：int pthread_cond_destroy(pthread_cond_t *cond) 12int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime) 等待条件有两种方式：无条件等待pthread_cond_wait()和计时等待pthread_cond_timedwait()，其中计时等待方式如果在给定时刻前条件没有满足，则返回ETIMEOUT，结束等待，其中abstime以与time()系统调用相同意义的绝对时间形式出现，0表示格林尼治时间1970年1月1日0时0分0秒。 无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。 激发条件有两种形式，pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。 pthread_cond_wait()和pthread_cond_timedwait()都被实现为取消点，因此，在该处等待的线程将立即重新运行，在重新锁定mutex后离开pthread_cond_wait()，然后执行取消动作。也就是说如果pthread_cond_wait()被取消，mutex是保持锁定状态的，因而需要定义退出回调函数来为其解锁。 以下示例集中演示了互斥锁和条件变量的结合使用，以及取消对于条件等待动作的影响。在例子中，有两个线程被启动，并等待同一个条件变量，如果不使用退出回调函数（见范例中的注释部分），则tid2将在pthread_mutex_lock()处永久等待。如果使用回调函数，则tid2的条件等待及主线程的条件激发都能正常工作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include#include#includepthread_mutex_t mutex;pthread_cond_t cond;void * child1(void *arg)&#123; pthread_cleanup_push(pthread_mutex_unlock,&amp;mutex); /* comment 1 */ while(1)&#123; printf(&quot;thread 1 get running \\n&quot;); printf(&quot;thread 1 pthread_mutex_lock returns %d\\n&quot;,pthread_mutex_lock(&amp;mutex)); pthread_cond_wait(&amp;cond,&amp;mutex); printf(&quot;thread 1 condition applied\\n&quot;); pthread_mutex_unlock(&amp;mutex); sleep(5); &#125; pthread_cleanup_pop(0); /* comment 2 */&#125;void *child2(void *arg)&#123; while(1)&#123; sleep(3); /* comment 3 */ printf(&quot;thread 2 get running.\\n&quot;); printf(&quot;thread 2 pthread_mutex_lock returns %d\\n&quot;,pthread_mutex_lock(&amp;mutex)); pthread_cond_wait(&amp;cond,&amp;mutex); printf(&quot;thread 2 condition applied\\n&quot;); pthread_mutex_unlock(&amp;mutex); sleep(1); &#125;&#125;int main(void)&#123; int tid1,tid2; printf(&quot;hello, condition variable test\\n&quot;); pthread_mutex_init(&amp;mutex,NULL); pthread_cond_init(&amp;cond,NULL); pthread_create(&amp;tid1,NULL,child1,NULL); pthread_create(&amp;tid2,NULL,child2,NULL); do&#123; sleep(2); /* comment 4 */ pthread_cancel(tid1); /* comment 5 */ sleep(2); /* comment 6 */ pthread_cond_signal(&amp;cond); &#125;while(1); sleep(100); pthread_exit(0);&#125; 如果不做注释5的pthread_cancel()动作，即使没有那些sleep()延时操作，child1和child2都能正常工作。注释3和注释4的延迟使得child1有时间完成取消动作，从而使child2能在child1退出之后进入请求锁操作。如果没有注释1和注释2的回调函数定义，系统将挂起在child2请求锁的地方；而如果同时也不做注释3和注释4的延时，child2能在child1完成取消动作以前得到控制，从而顺利执行申请锁的操作，但却可能挂起在pthread_cond_wait()中，因为其中也有申请mutex的操作。child1函数给出的是标准的条件变量的使用方式：回调函数保护，等待条件前锁定，pthread_cond_wait()返回后解锁。 条件变量机制不是异步信号安全的，也就是说，在信号处理函数中调用pthread_cond_signal()或者pthread_cond_broadcast()很可能引起死锁。 信号灯与互斥锁和条件变量的主要不同在于”灯”的概念，灯亮则意味着资源可用，灯灭则意味着不可用。如果说后两中同步方式侧重于”等待”操作，即资源不可用的话，信号灯机制则侧重于点灯，即告知资源可用；没有等待线程的解锁或激发条件都是没有意义的，而没有等待灯亮的线程的点灯操作则有效，且能保持灯亮状态。当然，这样的操作原语也意味着更多的开销。 信号灯的应用除了灯亮/灯灭这种二元灯以外，也可以采用大于1的灯数，以表示资源数大于1，这时可以称之为多元灯。 POSIX信号灯标准定义了有名信号灯和无名信号灯两种，但LinuxThreads的实现仅有无名灯，同时有名灯除了总是可用于多进程之间以外，在使用上与无名灯并没有很大的区别，因此下面仅就无名灯进行讨论。 int sem_init(sem_t *sem, int pshared, unsigned int value)这是创建信号灯的API，其中value为信号灯的初值，pshared表示是否为多进程共享而不仅仅是用于一个进程。LinuxThreads没有实现多进程共享信号灯，因此所有非0值的pshared输入都将使sem_init()返回-1，且置errno为ENOSYS。初始化好的信号灯由sem变量表征，用于以下点灯、灭灯操作。 int sem_destroy(sem_t * sem)被注销的信号灯sem要求已没有线程在等待该信号灯，否则返回-1，且置errno为EBUSY。除此之外，LinuxThreads的信号灯注销函数不做其他动作。 1int sem_post(sem_t * sem) 点灯操作将信号灯值原子地加1，表示增加一个可访问的资源。 12int sem_wait(sem_t * sem)int sem_trywait(sem_t * sem) sem_wait()为等待灯亮操作，等待灯亮（信号灯值大于0），然后将信号灯原子地减1，并返回。sem_trywait()为sem_wait()的非阻塞版，如果信号灯计数大于0，则原子地减1并返回0，否则立即返回-1，errno置为EAGAIN。 1int sem_getvalue(sem_t * sem, int * sval) 读取sem中的灯计数，存于*sval中，并返回0。 sem_wait()被实现为取消点，而且在支持原子”比较且交换”指令的体系结构上，sem_post()是唯一能用于异步信号处理函数的POSIX异步信号安全的API。 由于LinuxThreads是在核外使用核内轻量级进程实现的线程，所以基于内核的异步信号操作对于线程也是有效的。但同时，由于异步信号总是实际发往某个进程，所以无法实现POSIX标准所要求的”信号到达某个进程，然后再由该进程将信号分发到所有没有阻塞该信号的线程中”原语，而是只能影响到其中一个线程。 POSIX异步信号同时也是一个标准C库提供的功能，主要包括信号集管理（sigemptyset()、sigfillset()、sigaddset()、sigdelset()、sigismember()等）、信号处理函数安装（sigaction()）、信号阻塞控制（sigprocmask()）、被阻塞信号查询（sigpending()）、信号等待(sigsuspend())等，它们与发送信号的kill()等函数配合就能实现进程间异步信号功能。LinuxThreads围绕线程封装了sigaction()何raise()，本节集中讨论LinuxThreads中扩展的异步信号函数，包括pthread_sigmask()、pthread_kill()和sigwait()三个函数。毫无疑问，所有POSIX异步信号函数对于线程都是可用的。 int pthread_sigmask(int how, const sigset_t *newmask, sigset_t *oldmask)设置线程的信号屏蔽码，语义与sigprocmask()相同，但对不允许屏蔽的Cancel信号和不允许响应的Restart信号进行了保护。被屏蔽的信号保存在信号队列中，可由sigpending()函数取出。 int pthread_kill(pthread_t thread, int signo)向thread号线程发送signo信号。实现中在通过thread线程号定位到对应进程号以后使用kill()系统调用完成发送。 int sigwait(const sigset_t *set, int sig)挂起线程，等待set中指定的信号之一到达，并将到达的信号存入sig中。POSIX标准建议在调用sigwait()等待信号以前，进程中所有线程都应屏蔽该信号，以保证仅有sigwait()的调用者获得该信号，因此，对于需要等待同步的异步信号，总是应该在创建任何线程以前调用pthread_sigmask()屏蔽该信号的处理。而且，调用sigwait()期间，原来附接在该信号上的信号处理函数不会被调用。 如果在等待期间接收到Cancel信号，则立即退出等待，也就是说sigwait()被实现为取消点。 除了上述讨论的同步方式以外，其他很多进程间通信手段对于LinuxThreads也是可用的，比如基于文件系统的IPC（管道、Unix域Socket等）、消息队列（Sys.V或者Posix的）、System V的信号灯等。只有一点需要注意，LinuxThreads在核内是作为共享存储区、共享文件系统属性、共享信号处理、共享文件描述符的独立进程看待的。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"usb 打印机问题","slug":"z_csdn_071_6945231","date":"2011-11-07T04:43:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2011/11/07/z_csdn_071_6945231/","link":"","permalink":"http://vball.fun/2011/11/07/z_csdn_071_6945231/","excerpt":"","text":"1234567891011brian@isaiah:~$ lpinfo -vnetwork socketnetwork behdirect hpfaxdirect usb://HP/LaserJet%201200direct hp:/usb/HP_LaserJet_1200?serial=00CNC6063798network httpnetwork ippnetwork lpddirect scsinetwork smb 12345678910As a general rule for upgrading to cups 1.4 when something regardinglocal usb printers doesn&#x27;t work:1. disable kernel usblp: CONFIG_USB_PRINTER=n2. delete /etc/cups3. (re-)install cups 1.4 with USE=&quot;usb&quot;4. configure printer(s) from scratch via the cups webinterface5. if your printer is a multifunction device, be sure you got the udev rulessetting the device permissions in shape so cups can access the deviceIf for whatever reason (broken/old printer drivers) that doesn&#x27;t workout there&#x27;s still the way to install CUPS 1.4 with USE=&quot;-usb&quot; to getthe old CUPS 1.3 behaviour back.","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"一片丹心育桃李 万般坚强站恶魔 ——挽救恩师生命，师生情搭起爱心桥","slug":"z_csdn_034_6931043","date":"2011-11-02T18:14:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/11/02/z_csdn_034_6931043/","link":"","permalink":"http://vball.fun/2011/11/02/z_csdn_034_6931043/","excerpt":"","text":"一片丹心育桃李 万般坚强站恶魔 ——挽救恩师生命，师生情搭起爱心桥 王在广，卫辉市第一中学英语教师。二十年来，王老师始终在三尺讲坛辛勤的耕耘着，无私的奉献着，成为卫辉一中教育第一线的顶梁柱，就在刘老师的事业如日中天的时刻，残酷的病痛向他袭来。2011年秋，王老师被诊断为食道癌并处于晚期。这黑色的消息如晴天霹雳炸懵了王老师的家族、亲友、同事和学生，大家都忧心如焚、张皇失措。” 作为贫困县城教师，我们改变一个孩子的面貌，就可能会改变一个家庭的面貌。”这就是刘老师的工作信念。他的乐观、坚强与负责着实让人感动。在他身上，我们看到了一个教师人性的光华、人格的魅力。他崇高的人生境界、高尚的师德情操、无私的奉献精神，感人至深，令人深省，催人奋进。 如今，他正在北京”中国人民解放军总医院肿瘤科”治疗。然而，就在治疗的关键时期，我们眼看着恩师将要因资金问题而被病魔夺去可贵的生命。作为他的学生，你愿意看到这样的事情放生吗？作为一中的学生 ，你忍心看到此景出现吗？显然是不愿意、不忍心看到这样的结果。为了避免以上结果，我们特发起以”挽救恩师生命，师生情搭起爱心桥”为主题的募捐活动。 灾祸可以夺去生命，但却不能夺去人间的真情！我们生活在同一个校园。也许你与她还素不相识，但是，爱是没有界限的！老师们，同学们，伸出你的双手，奉献一片爱心，为恩师王在广捐助一点资金吧。捐款无论多少，都是爱心的展示。您所捐助的每一元钱里，都蕴存着用金钱难以衡量的人间真情！尽管金钱有限，但是爱心无价！你的爱心，将化成缕缕阳光，汇成股股甘泉，滋润她们的心田！你的爱心，会让暗淡的生活重新迸发出灿烂的光辉，让希望的光芒重新照亮美好的前程，甚至改变一个人的命运！ 老师们，同学们，让我们行动起来，让他们充分感受校园的温暖，尽快走出生活的阴影吧！ 因广大学生分布在全国各地，并且恩师急需用钱，同时在和恩师家人商量后，为了方便捐钱，特建立一张工商银行卡。 卡号：621226 020000 6037747. 注：1.此卡为恩师所有，仅有此一张捐款卡； 2.以免卡号在传播过程有误，请捐款人联系***核对卡号。 3.为了方便最后核算金额，请各位将姓名和所捐金额发送到***。 4.此次捐款活动全程透明，捐款情况在公共邮箱里公布，希望大家放心献爱心。 师兄、师姐、师弟、师妹，各位好！ 如今，恩师”王在广”患重病在京治疗。因费用过大，老师资金有所不足。同时，全国各地卫辉一中学生听到此消息后，都迫不及待的想进京看望老师。为更好解决以上问题以免给老师带来没有必要的麻烦，经过在京读书和工作的学生商量，特成立工作小组。小组成员有各级代表组成。 小组任务：1.负责募捐活动； 2.合理组织和安排到京看望老师的学生； 3.协助师母照顾老师。 注：1.每级代表两个左右； 2.因时间仓促，缺少哪一级代表，以后可以补充； 3.代表主要任务是负责一些通知、宣传、资金管理工作； 4.具体名单查看公共邮箱，如有更换，请各级内部自由调整并将新代表有关信息发到公共邮箱里； 负责小组 联系方式 侯明涛 289879822 18710037220 吴军营 18210349478 甘新鹏 313970178 15210808923 周文佳 393908940 15210652711 冯青松 523642416 15810740437 381766390 15011085216 李灵利 894414036 15111024205 李少波 523824560 18810536832 陈丽华 812592873 18810537435 董晓龙 10481228603 15120054008 唐启胜 386046568 15901096149 卫辉市第一中学北京市老乡会 2011.11.01","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"LINUX下USB1.1设备学习小记","slug":"z_csdn_068_6927960","date":"2011-11-01T20:11:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2011/11/01/z_csdn_068_6927960/","link":"","permalink":"http://vball.fun/2011/11/01/z_csdn_068_6927960/","excerpt":"","text":"抵扣说明： 1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。2.余额无法直接购买下载，可以购买VIP、C币套餐、付费专栏及课程。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"在linux中使用head命令和tail命令查看文件中的指定行","slug":"z_csdn_009_6925872","date":"2011-11-01T02:27:10.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/11/01/z_csdn_009_6925872/","link":"","permalink":"http://vball.fun/2011/11/01/z_csdn_009_6925872/","excerpt":"","text":"使用head 命令和tail 命令显示指定的行： head -n, –lines=[-]K print the first K lines instead of the first 10; with the leading ‘-‘, print all but the last K lines of each file tail -n, –lines=K output the last K lines, instead of the last 10; or use -n +K to output lines starting with the Kth [root@localhost etc]# pwd /etc [root@localhost etc]# cat yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever keepcache=0 debuglevel=2 logfile=/var/log/yum.log exactarch=1 obsoletes=1 gpgcheck=1 plugins=1 installonly_limit=3 //此处是一空行 This is the default, if you make this bigger yum won’t see if the metadatais newer on the remote and so you’ll “gain” the bandwidth of not having todownload the new metadata and “pay” for it by yum not having correctinformation.It is esp. important, to have correct metadata, for distributions likeFedora which don’t keep old packages around. If you don’t like this checkinginterupting your command line usage, it’s much better to have somethingmanually check the metadata once an hour (yum-updatesd will do this).metadata_expire=90m//此处是一空行 PUT YOUR REPOS HERE OR IN separate files named file.repoin /etc/yum.repos.d[root@localhost etc]# cat yum.conf |wc -l yum.conf 文件共有23 行 [root@localhost etc]# head yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever keepcache=0 debuglevel=2 logfile=/var/log/yum.log exactarch=1 obsoletes=1 gpgcheck=1 plugins=1 installonly_limit=3 显示前10 行，这个是默认值 [root@localhost etc]# head -n 2 yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever 显示前2 行 [root@localhost etc]# head -n -20 yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever keepcache=0 显示除最后20 行以外的所有行 [root@localhost etc]# tail yum.conf download the new metadata and “pay” for it by yum not having correctinformation.It is esp. important, to have correct metadata, for distributions likeFedora which don’t keep old packages around. If you don’t like this checkinginterupting your command line usage, it’s much better to have somethingmanually check the metadata once an hour (yum-updatesd will do this).metadata_expire=90m//此处是一空行 PUT YOUR REPOS HERE OR IN separate files named file.repoin /etc/yum.repos.d显示最后10 行，这是默认值 [root@localhost etc]# tail -n 2 yum.conf PUT YOUR REPOS HERE OR IN separate files named file.repoin /etc/yum.repos.d显示最后2 行 [root@localhost etc]# tail -n +21 yum.conf //此处是一空行 PUT YOUR REPOS HERE OR IN separate files named file.repoin /etc/yum.repos.d从第21 行开始显示后面的所有行，即第21 行到第23 行 显示第11 行到第20 行(总共23 行)： 从第11 行开始显示，但不包括最后3 行 [huage@localhost etc]$ head -n -3 yum.conf |tail -n +11 显示前20 行，但从第11 行开始 [huage@localhost etc]$ head -n 20 yum.conf |tail -n +11 显示除最后3 行以外的所有行，但只显示最后10 行 [huage@localhost etc]$ head -n -3 yum.conf |tail -n 10 显示前20 行中的后10 行 [huage@localhost etc]$ head -n 20 yum.conf |tail -n 10 从第11 行开始显示，但只显示前10 行 [huage@localhost etc]$ tail -n +11 yum.conf |head -n 10 从第11 行开始显示，但不包括最后3 行 [huage@localhost etc]$ tail -n +11 yum.conf |head -n -3 显示最后13 行中的前10 行 [huage@localhost etc]$ tail -n 13 yum.conf |head -n 10 显示最后13 行中除末尾的3 行以外的前10 行 [huage@localhost etc]$ tail -n 13 yum.conf |head -n -3","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"如何架设Linux打印服务器","slug":"z_csdn_059_6908297","date":"2011-10-26T03:29:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2011/10/26/z_csdn_059_6908297/","link":"","permalink":"http://vball.fun/2011/10/26/z_csdn_059_6908297/","excerpt":"","text":"抵扣说明： 1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。2.余额无法直接购买下载，可以购买VIP、C币套餐、付费专栏及课程。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"Linux终端使用技巧","slug":"z_csdn_028_6900257","date":"2011-10-23T20:35:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/10/23/z_csdn_028_6900257/","link":"","permalink":"http://vball.fun/2011/10/23/z_csdn_028_6900257/","excerpt":"","text":"博客分类： Linux Linux C C++ C# 今天才发现Linux下的终端有这么多好用的快捷键。 Shift+Ctrl+T:新建标签页Shift+Ctrl+W:关闭标签页Ctrl+PageUp:前一标签页Ctrl+PageDown:后一标签页Shift+Ctrl+PageUp:标签页左移Shift+Ctrl+PageDown:标签页右移Alt+1:切换到标签页1Alt+2:切换到标签页2Alt+3:切换到标签页3 Shift+Ctrl+N:新建窗口Shift+Ctrl+Q:关闭终端 终端中的复制／粘贴:Shift+Ctrl+C:复制Shift+Ctrl+V:粘贴 终端改变大小：F11：全屏Ctrl+plus:放大Ctrl+minus:减小Ctrl+0:原始大小","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"cups移植","slug":"z_csdn_038_6890879","date":"2011-10-20T01:07:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/10/20/z_csdn_038_6890879/","link":"","permalink":"http://vball.fun/2011/10/20/z_csdn_038_6890879/","excerpt":"","text":"（没有移植foomatic,直接移植gutenprint） cups的Makefile使用如下命令生成 这几项是我还没有移植这几个库，所以先disable了， 各软件交叉编译完成后我download到我的板子上面，准备试试看看效果怎么样 执行cupsd 准备配置cups 可是一点击add printer就出现错误不能继续了。 我通过串口输入 echo 111 &gt; /dev/usb/lp0是可以打印 然后我输入 lpinfo -v lpinfo -m 这俩个命令输入后均返回空，没有任何信息。我觉得最起码我输入lpinfo -m是应该有信息输出才对，但是没有，所以我想是否是我在编译cups的时候出现错误， 或是还差什么组件没有移植的。 盼望移植过cups的大牛们不吝赐教，谢谢。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"自动扫描局域网并且发现指定端口开放的主机ip的shell脚本","slug":"z_csdn_042_6883611","date":"2011-10-17T18:25:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2011/10/17/z_csdn_042_6883611/","link":"","permalink":"http://vball.fun/2011/10/17/z_csdn_042_6883611/","excerpt":"","text":"经过2天研究，学习shell和awk脚本，得到如下功能： 1。扫描局域网主机的端口开放情况 2。获取指定端口开发的主机ip 3。将获取的ip修改有关配置文件 代码如下，有疑问的可以找我探讨，一起学习！ #!/bin/bash echo ‘Start to delete the old configuration file……’ rm -rf scan_result.xmlrm -rf scan_result_ip.xmlrm -rf scan_result_ip.xml.bak for ipv in {195..197} do echo ‘Start to detect the status of port 9035 for host ‘$ipv’……’ nmap -v 10.0.2.$ipv -p 9035 –append-output -oN scan_result.xml done #cho ‘Start to find the ip of the host which’s 9035 port is open……’ awk ‘BEGIN{RS=”Interesting ports on bogon”; FS=”(“; OFS=”)”}{for(j=1;j","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"扫描MAC地址脚本--保存","slug":"z_csdn_041_6883585","date":"2011-10-17T18:24:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/10/17/z_csdn_041_6883585/","link":"","permalink":"http://vball.fun/2011/10/17/z_csdn_041_6883585/","excerpt":"","text":"呵呵，脚本写得不是很好，希望有高手帮我完善，比如使用了外部命令，或语法规范，或更妙的技巧，或更加灵活性…… 123456789101112131415161718192021222324252627282930313233343536#!/bin/bash#author: InBi#date: 2011-08-16#website: http://www.itwhy.org/2011/08-20/939.html########################################################ScanIpMac()&#123; Ip_Bin=$(ifconfig $1|sed -rn &amp;apos;/inet /&#123;s/[^:]*:([^ ]*).*/obase=2;\\1/;s/\\./;/gp&#125;&amp;apos;|bc|xargs printf &amp;quot;%08d&amp;quot;) Mask_Bin=$(ifconfig $1|sed -rn &amp;apos;/inet /&#123;s/.*Mask:([^ ]*).*/obase=2;\\1/;s/\\./;/gp&#125;&amp;apos;|bc|xargs printf &amp;quot;%08d&amp;quot;) #&amp;#x628A;IP&amp;#x548C;netmask&amp;#x6BCF;&amp;#x4E00;&amp;#x6BB5;&amp;#x8F6C;&amp;#x6362;&amp;#x6210;&amp;#x4E8C;&amp;#x8FDB;&amp;#x5236;&amp;#xFF0C;&amp;#x7136;&amp;#x540E;&amp;#x8FDE;&amp;#x63A5;&amp;#x8D77;&amp;#x6765;&amp;#x3002; Mask_Lng=`printf $&#123;Mask_Bin%%0*&#125;|wc -c` #&amp;#x8BA1;&amp;#x7B97;&amp;#x51FA;netmask&amp;#x4E3A;&amp;#x201C;1&amp;#x201D;&amp;#x7684;&amp;#x90E8;&amp;#x4EFD;&amp;#x6709;&amp;#x591A;&amp;#x5C11;&amp;#x4F4D;&amp;#x3002; MyNet=$&#123;Ip_Bin:0:$Mask_Lng&#125;$(printf &amp;quot;%0$((32-$Mask_Lng))d&amp;quot;) MyBro=$&#123;Ip_Bin:0:$Mask_Lng&#125;$(printf &amp;quot;%0$((32-$Mask_Lng))d&amp;quot;|tr 0 1) #&amp;#x8BA1;&amp;#x7B97;&amp;#x51FA;&amp;#x672C;&amp;#x673A;&amp;#x7684;&amp;#x7F51;&amp;#x7EDC;&amp;#x53F7;&amp;#x4E0E;&amp;#x5E7F;&amp;#x64AD;&amp;#x53F7;,&amp;#x7528;&amp;#x4E8E;&amp;#x4E0B;&amp;#x9762;&amp;#x5FAA;&amp;#x73AF;&amp;#x3002; echo -e &amp;quot;\\n---------- &amp;quot;start at $(date +&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;)&amp;quot; ----------\\n&amp;quot;&amp;gt;$HOME/ScanIpMac.lst for (( i=$((2#$MyNet+1)); i&amp;lt; $((2#$MyBro)); i++ )); do Tmp=$(echo &amp;quot;obase=2;$i&amp;quot;|bc) Ip=$(for i in &#123;0..3&#125;;do test $i != 0 &amp;amp;&amp;amp; printf &amp;apos;.&amp;apos;; printf $((2#$&#123;Tmp:$i*8:8&#125;));done) #&amp;#x6BCF;&amp;#x4E00;&amp;#x6B21;&amp;#x5FAA;&amp;#x73AF;&amp;#x6570;&amp;#x6362;&amp;#x6210;&amp;#x4E8C;&amp;#x8FDB;&amp;#x5236;&amp;#xFF0C;&amp;#x7136;&amp;#x540E;8&amp;#x4F4D;&amp;#x5206;&amp;#x4E00;&amp;#x6BB5;&amp;#x6362;&amp;#x6210;&amp;#x5341;&amp;#x5236;&amp;#x5236;&amp;#xFF0C;&amp;#x518D;&amp;#x8FDE;&amp;#x63A5;&amp;#x8D77;&amp;#x6765;&amp;#x3002; arping -w 0.3 -c 1 $Ip &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp; #&amp;#x53D1;&amp;#x9001; ARP &amp;#x5305;&amp;#xFF0C;&amp;#x4E14;&amp;#x4E0D;&amp;#x7B49;&amp;#x5F85;&amp;#x54CD;&amp;#x5E94;&amp;#x5C31;&amp;#x8FDB;&amp;#x884C;&amp;#x4E0B;&amp;#x4E00;&amp;#x6B21;&amp;#x5FAA;&amp;#x73AF;&amp;#x3002; done; sleep 5 #&amp;#x7B49;&amp;#x5F85; 5 &amp;#x79D2;&amp;#x3002; arp -n -i $1 2&amp;gt;/dev/null|grep &amp;apos;:&amp;apos;|sort -n -u -t &amp;quot;.&amp;quot; -k1,1 -k2,2 -k3,3 -k4,4|awk -F &amp;apos; &amp;apos; &amp;apos;&#123;print $1&amp;quot;\\t\\t&amp;quot;$3&#125;&amp;apos;|tee -a $HOME/ScanIpMac.lst #arp -n &amp;#x8F93;&amp;#x51FA;&amp;#x6309; IP &amp;#x6392;&amp;#x5E8F;&amp;#x540E;&amp;#x91CD;&amp;#x5B9A;&amp;#x5411;&amp;#x5230; ScanIpMac.lst &amp;#x6587;&amp;#x4EF6;&amp;#xFF0C;&amp;#x5E76;&amp;#x6253;&amp;#x5370;&amp;#x81F3;&amp;#x6807;&amp;#x51C6;&amp;#x8F93;&amp;#x51FA;&amp;#x3002; echo -e &amp;quot;\\n---------- &amp;quot;End at $(date +&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;)&amp;quot; ------------&amp;quot;&amp;gt;&amp;gt;$HOME/ScanIpMac.lst exit 0&#125;if test -n &amp;quot;$1&amp;quot; &amp;amp;&amp;amp; test $1 != lo &amp;amp;&amp;amp; `ifconfig $1&amp;gt;/dev/null 2&amp;gt;&amp;amp;1`; then ScanIpMac $1;else echo &amp;apos;NOTE: please enter the right parameter.&amp;apos; echo &amp;apos;For example: ScanIpMac eth0.&amp;apos; exit 1fi 2011-08-20 更新了获取IP和MASK的方法。感谢ubuntu论坛的”我就是我2”的帮助。2011-08-21 改进获取字符串长度的方法：printf ${Mask_Bin%%0*}|wc -c，感谢 ubuntu论坛的”fnan”指点2011-08-25 再次改进，哈哈，还是上面两位的指点。2011-08-26 增加参数输入，使脚本更加灵活。并且提高了速度，以前需要20分钟，现在只要20秒就行了。 呵呵，只列图哦，不想费话，因为要睡觉了。 123456192.168.22.1 08:10:17:6d:04:9c192.168.22.5 08:11:17:6d:a4:21192.168.22.6 08:14:17:6d:b0:3e192.168.22.9 08:10:57:6d:aa:0c192.168.22.20 08:10:57:6d:0a:ae192.168.22.21 08:60:15:6d:0e:ac","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"一些收集","slug":"z_csdn_073_6881663","date":"2011-10-17T00:12:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2011/10/17/z_csdn_073_6881663/","link":"","permalink":"http://vball.fun/2011/10/17/z_csdn_073_6881663/","excerpt":"","text":"抵扣说明： 1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。2.余额无法直接购买下载，可以购买VIP、C币套餐、付费专栏及课程。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"循环位移-C","slug":"z_csdn_010_7046188","date":"2011-09-07T05:52:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/09/07/z_csdn_010_7046188/","link":"","permalink":"http://vball.fun/2011/09/07/z_csdn_010_7046188/","excerpt":"","text":"0x20是十进制的32，你是多少位的类型就换成多少就好了，这里是int。原理也很简单，两边一来一去然后或一下把空出来的0补全… 循环左移: #define CROL(value, bits) ((value &lt;&lt; bits) | (value &gt;&gt; (0x20 - bits))) 循环右移: #define CROR(value, bits) ((value &gt;&gt; bits) | (value &lt;&lt; (0x20 - bits)))","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"VC学习资料，","slug":"z_csdn_014_6673901","date":"2011-08-09T05:15:01.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/08/09/z_csdn_014_6673901/","link":"","permalink":"http://vball.fun/2011/08/09/z_csdn_014_6673901/","excerpt":"","text":"vc6.0下载地址2009年02月07日 星期六 10:43 相关资料： 要下载MSDN 2001，请进http://hi.baidu.com/ypxmaomao/blog/item/c1d129b5657794c937d3caf4.html MFC类库详解,中文版：http://hi.baidu.com/ypxmaomao/blog/item/10f17cf4d55d7069dcc4741f.html Visual Studio 6.0 SP6 英文企业版 http://www.rayfile.com/files/6f461678-f66b-11dd-bc62-0014221b798a/ Visual C++ 6.0 简体中文企业版 集成SP6完美版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=176808 Visual C++ 6.0 英文企业版 集成SP6完美版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=177051 Visual Studio 6.0 英文企业版 集成SP6完美版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=177062 钱能 c++程序设计教程 第二版 高清PDF版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=166018 Essential C++ 中文版+英文版 侯捷译 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=167578 编程点金之Visual C++(电子教程) iso http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=181036 C++程序调试实用手册 PDF版下载 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=181037 C++面向对象多线程编程 PDF版下载 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=181038 C++高级编程参考手册 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=145562 C和C++代码精粹 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=184165 C++沉思录 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=184163 C++ Primer 第三版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=145858 C++ Primer 第四版 中文版高清晰 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=177763 高质量C++编程指南 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=177759 C++ 编程思想 第1卷 标准C++导引 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=177774 C++ 编程思想 第2卷 实用编程技术 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=177770 More Effective C++ 简体中文版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=146871 C++ Templates 中文版+英文版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=176004 C++ Coding Standards[Addison Wesley] http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=175999 Absolute C++ 全彩页代码剖析 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=175578 Accelerated C++ - Practical Programming by Example http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=177489 Inside the C++ Object Model http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=175359 More Exceptional C++ [Addison Wesley] http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=175358 Exceptional C++ [Addison Wesley] http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=175357 Sams出版 C++ Unleashed http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=163617 C++ GUI Programming with QT4 http://bbs.topsage.com/dispbbs.asp?boardID=119&amp;ID=146734 VC++深入详解 孙鑫作品系列 高清PDF版下载 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=185201 Visual C++ 6傻瓜书 快速参考 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=173217 Visual C++ 6.0 编程实例与技巧(PDF中文版) http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=173210 Visual C++ 21天自学教程 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=173174 跟我学Visual C++ 6 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=174442 Visual C++ 6 数据库编程 21天自学教程 CHM http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=173173 The C++ Programming Language 第三版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=175018 深度探索C++对象模型 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=176965 Special Edition Using Visual C++ 6 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=173171 Professional MFC with VC 6 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=166005 Practical C++ Programming http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=173744 Cross-Platform Development in C++ http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=174168 Iterative UML Development Using VC++ 6 http://bbs.topsage.com/dispbbs.asp?boardID=124&amp;ID=174831 Ace Programmer’s Guide http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=174449 Visual C++高级界面特效制作百例 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=168630 精通GDI+编程 清华大学出版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=170571 Borland C++ Builder 6 开发指南 CHM http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=184709 孙鑫C++视频教程 rmvb格式 全20CD完整版 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=156290 C++视频教程 边用边学Visual C++ 6 (ASF格式) http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=177500 中山大学蔡培兴 C++语言视频教程 全51讲 精品推荐 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=158073 C++程序设计视频教程 东南大学何洁月主讲 全80讲(上) 48讲 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=181543 C++程序设计视频教程 东南大学何洁月主讲 全80讲(下) 32讲 http://bbs.topsage.com/dispbbs.asp?boardID=121&amp;ID=181546 URL ftp://202.112.84.90/pub2/Development/Microsoft%20Development/Visual%20Studio/MSDN2001_10/msdn200110_1.iso URL ftp://202.112.84.90/pub2/Development/Microsoft%20Development/Visual%20Studio/MSDN2001_10/msdn200110_2.iso ftp://202.112.84.90/pub2/Development/Microsoft%20Development/Visual%20Studio/MSDN2001_10/MSDN200110_3.ISO 1.45G版本： 地址： ftp://211.139.39.1/pub/software/program/MSDN_OCT_2001.ISO 容量1.45GB，DVD版 电驴的： [EMULE]ed2k://|file|%5BMicrosoft.Visual.Studio6.0.MSDN.Library%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%89%88%5D.MSDN60CHSCD1.iso|592472064|E834C35CB1773A7347FFFEDFABC9A236|h=J3RHQELIUZOHWF6UPUHP72KDJERRZE4H|/ ed2k://|file|%5BMicrosoft.Visual.Studio6.0.MSDN.Library%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%89%88%5D.MSDN60CHSCD2.iso|577603584|7D4256487E0CAA59785A5DC5005E518A|h=2PH2UDC55RE35RO2HJFY6DO4MXRCS7VQ|/[/EMULE] vb是中文。vc是英文的： 2CD CD1: ed2k://|file|MSDN60CHSCD1.iso|592472064|E834C35CB1773A7347FFFEDFABC9A236|h=J3RHQELIUZOHWF6UPUHP72KDJERRZE4H|/ CD2: ed2k://|file|MSDN60CHSCD2.iso|577603584|7D4256487E0CAA59785A5DC5005E518A|h=2PH2UDC55RE35RO2HJFY6DO4MXRCS7VQ|/ VS 2008 Team Suit With MSDN (4.34G) 简体中文正式版 下载页面 http://www.microsoft.com/downloads/details.aspx?displaylang=zh-cn&amp;FamilyID=d95598d7-aa6e-4f24-82e3-81570c5384cb http://www.microsoft.com/downloads/details.aspx?familyid=6FF3BC60-32C8-4C22-8591-A20BF8DFF1A2&amp;displaylang=zh-cn 直接下载地址 http://download.microsoft.com/download/0/8/3/0839ce16-0523-4407-9432-01958ee61aff/VS2008TeamSuite90DayTrialCHSX1429243.part7.rar http://download.microsoft.com/download/0/8/3/0839ce16-0523-4407-9432-01958ee61aff/VS2008TeamSuite90DayTrialCHSX1429243.part6.rar http://download.microsoft.com/download/0/8/3/0839ce16-0523-4407-9432-01958ee61aff/VS2008TeamSuite90DayTrialCHSX1429243.part5.rar http://download.microsoft.com/download/0/8/3/0839ce16-0523-4407-9432-01958ee61aff/VS2008TeamSuite90DayTrialCHSX1429243.part4.rar http://download.microsoft.com/download/0/8/3/0839ce16-0523-4407-9432-01958ee61aff/VS2008TeamSuite90DayTrialCHSX1429243.part3.rar http://download.microsoft.com/download/0/8/3/0839ce16-0523-4407-9432-01958ee61aff/VS2008TeamSuite90DayTrialCHSX1429243.part2.rar http://download.microsoft.com/download/0/8/3/0839ce16-0523-4407-9432-01958ee61aff/VS2008TeamSuite90DayTrialCHSX1429243.part1.exe http://download.microsoft.com/download/b/c/7/bc73449c-17e2-4097-ba4b-0095e52f5489/VS2008MSDNLibraryCHSX1433063.iso 用记事本打开 Setup\\setup.sdb 文件，找到 [Product Key]， 将T2CRQGDKBVW7KJR8C6CKXMW3D 修改为 PYHYPWXB3BB2CCMV9DX9VDY8T 就可以变成正式版了~~ VS 2005 Team Suit With MSDN (3.22G) http://www.microsoft.com/downloads/info.aspx?na=90&amp;p=&amp;SrcDisplayLang=zh-cn&amp;SrcCategoryId=&amp;SrcFamilyId=5677ddc4-5035-401f-95c3-cc6f46f6d8f7&amp;u=http%3a%2f%2fdownload.microsoft.com%2fdownload%2fb%2fa%2f6%2fba691c56-8833-446c-82fe-cf94b588a622%2fchs_vs_2005_VSTS_180_Trial.img SP1 http://download.microsoft.com/download/8/0/7/8071514d-9370-45c3-8af1-4ff09a70e59d/VS80sp1-KB926604-X86-CHS.exe SP1 For Vista http://www.microsoft.com/downloads/info.aspx?na=90&amp;p=&amp;SrcDisplayLang=zh-cn&amp;SrcCategoryId=&amp;SrcFamilyId=bb4a75ab-e2d4-4c96-b39d-37baf6b5b1dc&amp;u=http%3a%2f%2fdownload.microsoft.com%2fdownload%2f8%2f0%2f7%2f8071514d-9370-45c3-8af1-4ff09a70e59d%2fVS80sp1-KB926604-X86-CHS.exe PS: 用记事本打开\\vs\\Setup\\setup.sdb 文件，替换最后一行为 KYTYHTQKW6VWPBQDKC8FHWC4J 就可以变成正式版了~~ VS2005专业版，含MSDN，微软直下 (2.55G) http://www.microsoft.com/downloads/info.aspx?na=90&amp;p=&amp;SrcDisplayLang=zh-cn&amp;SrcCategoryId=&amp;SrcFamilyId=b2c27a7f-d875-47d5-b226-e2578a116e12&amp;u=http%3a%2f%2fdownload.microsoft.com%2fdownload%2f5%2fc%2f2%2f5c2840fd-8b03-492e-bd61-6fc2820b8ba3%2fchs_vs_2005_Pro_90_Trial.img http://www.0451f.cn/System/ms_vs_2005_pro_chs.rar VB2005 速成版，微软学生中心直下 (511M) http://www.msuniversity.edu.cn/m_AdvancedMembers/downloadfile.aspx?username=HeTaoOS@Gmail.com&amp;type=2 ftp://www.msuniversity.edu.cn/Express/VB_CHS.iso 雨薇在线 VS_SP6_4IN1_V1.0 (684 MB) 光盘中包含 Visual Basic 6.0 中文企业版+SP6 Visual C++ 6.0 中文企业版+SP6 Visual C++ 6.0 英文企业版+SP6 Visual Foxpro 6.0 中文企业版+SP5 http://it.ngjx.com/sortZ/ProgramerZ/0001/YW_VS60 Visual C++ 6.0 With SP6 (183M) http://shdxxz.52down.com.cn/VC++.6.0.with.SP6.rar http://www.51ct.cn/Download.asp?ID=2047 Visual Basic 6.0 With SP6 (185M) http://1.jiqixi.cn/other/VB6SP6.rar http://www.51ct.cn/Download.asp?ID=2069 http://book.17kb.cn/Download.asp?ID=2045 MSDN For Visual Studio 6.0 http://ftp.sdshiyan.cn/soft/program/DN60ACHS1.rar http://ftp.sdshiyan.cn/soft/program/DN60ACHS2.rar http://down.zomew.com:8080/soft/[MSDN].msdn_oct_2001.iso","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"rfid供应商","slug":"z_csdn_043_6655777","date":"2011-08-02T17:29:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2011/08/02/z_csdn_043_6655777/","link":"","permalink":"http://vball.fun/2011/08/02/z_csdn_043_6655777/","excerpt":"","text":"抵扣说明： 1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。2.余额无法直接购买下载，可以购买VIP、C币套餐、付费专栏及课程。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"PCB设计注意事项","slug":"z_csdn_052_6649998","date":"2011-07-31T21:29:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2011/07/31/z_csdn_052_6649998/","link":"","permalink":"http://vball.fun/2011/07/31/z_csdn_052_6649998/","excerpt":"","text":"1：印制导线拐弯处使用圆弧形 2：避免使用大面积覆铜，否则长时间受热时，易发生铜箔膨胀和脱落的问题，建议栅格状，有利于排出铜箔与板间粘合剂受热产生的挥发性气体。 3：功率线，交流线布置在不同的板上或者分开走线 4：焊点外径&gt;=（d+1.2）,mm，高速数字电路&gt;=(d+1.0)mm 5：电源输入端接上10-100uf的去耦电容，越大越好 6：信号频率 8：将地线做成死循环环路可以明显提高抗高抗噪声能力。环路形成后会缩小电位差值，提高抗干扰能力 去耦电容配置：数字电路中，当电路从一种状态转换到另外一种状态时，就会在电源线上产生一个很大的尖峰电流，形成瞬间的噪声电压。配置旁路电容可以抑制负载变化而产生的噪声，这是印制电路板设计的常规做法 1：电源跨接10~100uf的电解电容，空间允许，大点更好 2：每个集成芯片VCC和GND之间跨接一个0.010.1uf的陶瓷电容。如果空间不允许，没410个芯片配置一个110uf的钽电容或聚碳酸酯电容，这种器件的高频阻抗特别小，在500khz20MHZ范围内内阻抗小于1欧姆，而且漏电流很小（0.5uA以下），最好不用电解电容，卷制的电解电容高频是表现为电感特性。 3：对抗噪声能力弱、关断电流变化大的器件及ROM、RAM，应在VCC和GND间接去耦电容，有两个作用：一，作为集成电路的蓄能电容；二，旁路去掉该器件的高频噪声。去耦电容的选用并不严格，可按C=1/F，即10MHz取0.1uF，100MHz选0.01uf 4：复位电路上0.01uf去耦 5：去耦电容引线尽可能短，高频不能带引线，否则可能是去耦电容本身发生自共振。 6：开关，继电器、按钮操作时易发生电火花，需用RC电路来吸收电流（火花抑制电路）。一般R取12k欧姆，C取2.247uF，晶闸管、继电器增加续流二极管，消除断开线圈时产生的反电动势干扰。 PCB抗干扰设计： 1：抑制干扰源，尽可能减小干扰源的du/dt和di/dt，du/dt方法是并且电容，di/dt是串联电感或电阻及增加续流二极管。 2：切断干扰传播路径：传导干扰和辐射干扰–&gt;增加干扰源与敏感器件距离或者加屏蔽罩。 （1）：电源对MCU的影响，利用磁珠和电容构成π型滤波电路，要求不高时使用100欧姆电容代替。 （2）：IO控制电机等噪声器件，之间需增加隔离电路（π型滤波电路或光电隔离） （3）：使用地线隔离时钟区，并且晶振距离MCU尽可能近 （4）：电路板合理分区，强、弱信号，数字模拟，噪声器件（电机、继电器、晶闸管）等 3：提高敏感器件的抗干扰性：尽量减少回路环的面积、以降低感应噪声；电源线、地线尽可能组，除减小压降外，更重要的是降低耦合噪声；IO空口接地或电源","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"Ubuntu 10.04 下 TFTP设置 及busybox 中tftp使用","slug":"z_csdn_008_6549314","date":"2011-06-17T15:27:02.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/06/17/z_csdn_008_6549314/","link":"","permalink":"http://vball.fun/2011/06/17/z_csdn_008_6549314/","excerpt":"","text":"Ubuntu 下 TFTP设置 [日期：2010-08-18] 来源：Linux社区 作者：Linux1.Ubuntu10.04 下安装TFTP软件 tftp-hpa是客户端,tftpd-hpa是服务器端 sudo aptitude install tftp-hpa tftpd-hpa 2.配置TFTP服务器 sudo gedit /etc/default/tftpd-hpa 将原来的内容改为: /etc/default/tftpd-hpaTFTP_USERNAME=”tftp”#TFTP_DIRECTORY=”/var/lib/tftpboot”TFTP_ADDRESS=”0.0.0.0:69”#TFTP_OPTIONS=”–secure”#服务器目录,需要设置权限为777,chomd 777 #这个目录要改为你自己的TFTP根目录～～～ TFTP_DIRECTORY=”/home/stone/tmp” TFTP_OPTIONS=”-l -c -s” 3.重新启动TFTP服务 sudo service tftpd-hpa restart 4.测试下 cd ~/tftpboot echo “hello tftp service”&gt;&gt;a.txt echo “hello tftp service,put to tftp serive”&gt;&gt;b.txt tftp localhost get a.txt put b.txt 其中get是取得文件,put是将文件上传到TFTP服务器上。 tftp命令在嵌入式环境和linux(windows)环境下的使用 收藏tftp在嵌入式环境和Linux环境下使用的方式不一样： 1、嵌入式环境： 下载：tftp -gr 要下载的远端tftp目录下的文件路径 远端(tftp服务器)IP:PORT； 下载到嵌入式系统的当前目录下。 如：tftp -gr hd4100_app_main 127.0.0.1 上传：tftp -pr 要上传的本地文件的路径 远端(tftp服务器)IP:PORT； 上传到远端tftp目录下。 如：tftp -pr hd4100_app_main 127.0.0.1 2、Linux(Windows)环境，两种方式： (1).直接在命令行下输入tftp命令(提示连接到的服务器)，或者tftp 服务器ip:port； 此时命令提示符变为tftp&gt;，可以输入tftp命令”get 远端tftp目录文件路径”或者”put 本地当前目录下的文件”； 可以通过输入help命令查看支持的命令； (2).”tftp tftp服务器ip:port -c get 远端tftp目录文件路径”； 如：tftp 127.0.0.1 -c get hd4100_app_main “tftp tftp服务器ip:port -c put 本地当前目录文件路径”； 如：tftp 127.0.0.1 -c put hd4100_app_main 下载的文件可能提示没有权限操作，可以输入”chmod 777 文件名”命令。 上传文件时可能提示”ERROR CODE 1: File not found”，因为tftp只能上传 tftproot里面 权限为 可写 的 文件，所以，必须是tftp服务器端的tftproot目录下先 touch 你想上传的文件名（由服务器端的人设置），设置权限为 666，或者别的可写的(否则上传时提示”ERROR CODE 0:Access denied”)。接着远程的方可上传，而且可以多次上传所修改后的文件。而且只能一个一个文件传，文件夹无法上传下载也必须是 单独一个文件一个文件的 get。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"c++库介绍","slug":"z_csdn_011_6371660","date":"2011-04-30T03:20:08.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/04/30/z_csdn_011_6371660/","link":"","permalink":"http://vball.fun/2011/04/30/z_csdn_011_6371660/","excerpt":"","text":"1、C++各大有名库的介绍——C++标准库 2、C++各大有名库的介绍——准标准库Boost 3、C++各大有名库的介绍——GUI 4、C++各大有名库的介绍——网络通信 5、C++各大有名库的介绍——XML 6、C++各大有名库的介绍——科学计算 7、C++各大有名库的介绍——游戏开发 8、C++各大有名库的介绍——线程 9、C++各大有名库的介绍——序列化 10、C++各大有名库的介绍——字符串 11、C++各大有名库的介绍——综合 12、C++各大有名库的介绍——其他库 13、C++名人的网站 在 C++中，库的地位是非常高的。C++之父 Bjarne Stroustrup先生多次表示了设计库来扩充功能要好过设计更多的语法的言论。现实中，C++的库门类繁多，解决的问题也是极其广泛，库从轻量级到重 量级的都有。不少都是让人眼界大开，亦或是望而生叹的思维杰作。由于库的数量非常庞大，而且限于笔者水平，其中很多并不了解。所以文中所提的一些库都是比 较著名的大型库。 1、C++各大有名库的介绍——C++标准库 标准库中提供了C++程序的基本设施。虽然C++标准库随着C++标准折腾了许多年，直到标准的出台才正式定型，但是在标准库的实现上却很令人欣慰得看到多种实现，并且已被实践证明为有工业级别强度的佳作。 1.1、Dinkumware C++ Library P.J. Plauger编写的高品质的标准库。P.J. Plauger博士是Dr. Dobb’s程序设计杰出奖的获得者。其编写的库长期被Microsoft采用，并且最近Borland也取得了其OEM的license，在其 C/C++的产品中采用Dinkumware的库。 1.2、RogueWave Standard C++ Library 这个库在Borland C++ Builder的早期版本中曾经被采用，后来被其他的库给替换了。笔者不推荐使用。 1.3、SGI STL SGI公司的C++标准模版库。 1.4、STLport SGI STL库的跨平台可移植版本。 2、C++各大有名库的介绍——准标准库Boost Boost库是一个经过千锤百炼、可移植、提供源代码的C++库，作为标准库的后备，是C++标准化进程的发动机之一。 Boost库由C++标准委员会库工作组成员发起，在C++社区中影响甚大，其成员已近2000人。 Boost库为我们带来了最新、最酷、最实用的技术，是不折不扣的”准”标准库。 Boost中比较有名气的有这么几个库： 2.1 Regex 正则表达式库 2.2 Spirit LL parser framework，用C++代码直接表达EBNF 2.3 Graph 图组件和算法 2.4 Lambda 在调用的地方定义短小匿名的函数对象，很实用的functional功能 2.5 concept check 检查泛型编程中的concept 2.6 Mpl 用模板实现的元编程框架 2.7 Thread 可移植的C++多线程库 2.8 Python 把C++类和函数映射到Python之中 2.9 Pool 内存池管理 2.10 smart_ptr 5个智能指针，学习智能指针必读，一份不错的参考是来自CUJ的文章： Smart Pointers in Boost,哦，这篇文章可以查到，CUJ是提供在线浏览的。中文版见笔者在《Dr.Dobb’s Journal软件研发杂志》第7辑上的译文。 Boost总体来说是实用价值很高，质量很高的库。并且由于其对跨平台的强调，对标准C++的强调，是编写平台无关，现代C++的开发者必备的 工具。但是Boost中也有很多是实验性质的东西，在实际的开发中实用需要谨慎。并且很多Boost中的库功能堪称对语言功能的扩展，其构造用尽精巧的手 法，不要贸然的花费时间研读。Boost另外一面，比如Graph这样的库则是具有工业强度，结构良好，非常值得研读的精品代码，并且也可以放心的在产品 代码中多多利用。 3、C++各大有名库的介绍——GUI 在众多C++的库中，GUI部分的库算是比较繁荣，也比较引人注目的。在实际开发中，GUI库的选择也是非常重要的一件事情，下面我们综述一下可选择的GUI库，各自的特点以及相关工具的支持。 3.1、MFC 大名鼎鼎的微软基础类库（Microsoft Foundation Class）。大凡学过VC++的人都应该知道这个库。虽然从技术角度讲，MFC是不大漂亮的，但是它构建于Windows API 之上，能够使程序员的工作更容易,编程效率高，减少了大量在建立 Windows 程序时必须编写的代码，同时它还提供了所有一般 C++ 编程的优点，例如继承和封装。MFC 编写的程序在各个版本的Windows操作系统上是可移植的，例如，在Windows 3.1下编写的代码可以很容易地移植到 Windows NT 或 Windows 95 上。但是在最近发展以及官方支持上日渐势微。 3.2、QT Qt是Trolltech公司的一个多平台的C++图形用户界面应用程序框架。它提供给应用程序开发者建立艺术级的图形用户界面所需的所用功 能。Qt是完全面向对象的很容易扩展，并且允许真正地组件编程。自从1996年早些时候，Qt进入商业领域，它已经成为全世界范围内数千种成功的应用程序 的基础。Qt也是流行的Linux桌面环境KDE 的基础，同时它还支持Windows、Macintosh、Unix/X11等多种平台。[wangxinus注:QT目前已经是Nokia旗下的产品，原官方网站已经失效，目前为http://qt.nokia.com.2009年初发布的Qt4.5版本开始使用LGPL协议，诺基亚希望以此来吸引更多的开发人员使用Qt库] 3.3、WxWindows 跨平台的GUI库。因为其类层次极像MFC，所以有文章介绍从MFC到WxWindows的代码移植以实现跨平台的功能。通过多年的开发也是一个日趋完善的GUI库，支持同样不弱于前面两个库。并且是完全开放源代码的。新近的C++ Builder X的GUI设计器就是基于这个库的。[wangxinus注:迫于微软的施压，已经由WxWindows更名为wxWidgets] 3.4、Fox 开放源代码的GUI库。作者从自己亲身的开发经验中得出了一个理想的GUI库应该是什么样子的感受出发，从而开始了对这个库的开发。有兴趣的可以尝试一下。 3.5、WTL 基于ATL的一个库。因为使用了大量ATL的轻量级手法，模板等技术，在代码尺寸，以及速度优化方面做得非常到位。主要面向的使用群体是开发COM轻量级供网络下载的可视化控件的开发者。 3.6、GTK GTK是一个大名鼎鼎的C的开源GUI库。在Linux世界中有Gnome这样的杀手应用。而Qt就是这个库的C++封装版本。[wangxinus注:”Qt 就是这个库的C++封装版本”是错误的。Qt早于GTK，最初Qt由于协议的原因引起社区的不满，另外开发了一个基于C语言的GTK库，后面的扩展版本为 GTK＋。GTK+的Gnome和Qt的KDE是目前linux桌面的两大阵营，曾有水火不容之势。目前双方都以及开源社区的精神，已经和解。] 4、C++各大有名库的介绍——网络通信 4.１、ACE C++库的代表，超重量级的网络通信开发框架。ACE自适配通信环境（Adaptive Communication Environment）是可以自由使用、开放源代码的面向对象框架，在其中实现了许多用于并发通信软件的核心模式。ACE提供了一组丰富的可复用C++ 包装外观（Wrapper Facade）和框架组件，可跨越多种平台完成通用的通信软件任务，其中包括：事件多路分离和事件处理器分派、信号处理、服务初始化、进程间通信、共享内存管理、消息路由、分布式服务动态（重）配置、并发执行和同步，等等。 4.２、StreamModule 设计用于简化编写分布式程序的库。尝试着使得编写处理异步行为的程序更容易，而不是用同步的外壳包起异步的本质。 4.３、SimpleSocket 这个类库让编写基于socket的客户/服务器程序更加容易。 4.４、A Stream Socket API for C++ 又一个对Socket的封装库。 5、C++各大有名库的介绍——XML 5.１、Xerces Xerces-C++ 是一个非常健壮的XML解析器，它提供了验证，以及SAX和DOM API。XML验证在文档类型定义(Document Type Definition，DTD)方面有很好的支持，并且在2001年12月增加了支持W3C XMLSchema 的基本完整的开放标准。 5.２、XMLBooster 这个库通过产生特制的parser的办法极大的提高了XML解析的速度，并且能够产生相应的GUI程序来修改这个parser。在DOM和SAX两大主流XML解析办法之外提供了另外一个可行的解决方案。 5.３、Pull Parser 这个库采用pull方法的parser。在每个SAX的parser底层都有一个pull的parser，这个xpp把这层暴露出来直接给大家使用。在要充分考虑速度的时候值得尝试。 5.４、Xalan Xalan是一个用于把XML文档转换为HTML，纯文本或者其他XML类型文档的XSLT处理器。 5.５、CMarkup 这是一种使用EDOM的XML解析器。在很多思路上面非常灵活实用。值得大家在DOM和SAX之外寻求一点灵感。 5.６、libxml++ libxml++是对著名的libxml XML解析器的C++封装版本。 6、C++各大有名库的介绍——科学计算 6.１、Blitz++ Blitz++ 是一个高效率的数值计算函数库，它的设计目的是希望建立一套既具像C++ 一样方便，同时又比Fortran速度更快的数值计算环境。通常，用C++所写出的数值程序，比 Fortran慢20%左右，因此Blitz++正是要改掉这个缺点。方法是利用C++的template技术，程序执行甚至可以比Fortran更快。 Blitz++目前仍在发展中，对于常见的SVD，FFTs，QMRES等常见的线性代数方法并不提供，不过使用者可以很容易地利用Blitz++所提供的函数来构建。 6.２、POOMA POOMA是一个免费的高性能的C++库，用于处理并行式科学计算。POOMA的面向对象设计方便了快速的程序开发，对并行机器进行了优化以达到最高的效率，方便在工业和研究环境中使用。 6.３、MTL Matrix Template Library(MTL)是一个高性能的泛型组件库，提供了各种格式矩阵的大量线性代数方面的功能。在某些应用使用高性能编译器的情况下，比如Intel的编译器，从产生的汇编代码可以看出其与手写几乎没有两样的效能。 6.４、CGAL Computational Geometry Algorithms Library的目的是把在计算几何方面的大部分重要的解决方案和方法以C++库的形式提供给工业和学术界的用户。 7、C++各大有名库的介绍——游戏开发 7.１、Audio/Video 3D C++ Programming Library 7.２、KlayGE 国内游戏开发高手自己用C++开发的游戏引擎。KlayGE是一个开放源代码、跨平台的游戏引擎，并使用Python作脚本语言。KlayGE在LGPL协议下发行。感谢龚敏敏先生为中国游戏开发事业所做出的贡献。 7.３、OGRE OGRE（面向对象的图形渲染引擎）是用C++开发的，使用灵活的面向对象3D引擎。它的目的是让开发者能更方便和直接地开发基于3D硬件设备 的应用程序或游戏。引擎中的类库对更底层的系统库（如：Direct3D和OpenGL）的全部使用细节进行了抽象，并提供了基于现实世界对象的接口和其 它类。 8、C++各大有名库的介绍——线程 8.１、C++ Threads 这个库的目标是给程序员提供易于使用的类，这些类被继承以提供在Linux环境中很难看到的大量的线程方面的功能。 8.２、ZThreads 一个先进的面向对象，跨平台的C++线程和同步库。 9、C++各大有名库的介绍——序列化 9.１、s11n 一个基于STL的C++库，用于序列化POD，STL容器以及用户定义的类型。 9.２、Simple XML Persistence Library 这是一个把对象序列化为XML的轻量级的C++库。 10、C++各大有名库的介绍——字符串 10.１、C++ Str Library 操作字符串和字符的库，支持Windows和支持gcc的多种平台。提供高度优化的代码，并且支持多线程环境和Unicode，同时还有正则表达式的支持。 10.２、Common Text Transformation Library 这是一个解析和修改STL字符串的库。CTTL substring类可以用来比较，插入，替换以及用EBNF的语法进行解析。 10.３、GRETA 这是由微软研究院的研究人员开发的处理正则表达式的库。在小型匹配的情况下有非常优秀的表现。 11、C++各大有名库的介绍——综合 11.１、P::Classes 一个高度可移植的C++应用程序框架。当前关注类型和线程安全的signal/slot机制，i/o系统包括基于插件的网络协议透明的i/o架构，基于插件的应用程序消息日志框架，访问sql数据库的类等等。 11.２、ACDK - Artefaktur Component Development Kit 这是一个平台无关的C++组件框架，类似于Java或者.NET中的框架（反射机制，线程，Unicode，废料收集，I/O，网络，实用工具，XML，等等），以及对Java, Perl, Python, TCL, Lisp, COM 和 CORBA的集成。 11.３、dlib C++ library 各种各样的类的一个综合。大整数，Socket，线程，GUI，容器类,以及浏览目录的API等等。 11.４、Chilkat C++ Libraries 这是提供zip，e-mail，编码，S/MIME，XML等方面的库。 11.５、C++ Portable Types Library (PTypes) 这是STL的比较简单的替代品，以及可移植的多线程和网络库。 11.６、LFC 哦，这又是一个尝试提供一切的C++库 12、C++各大有名库的介绍——其他库 12.１、Loki 哦，你可能抱怨我早该和Boost一起介绍它，一个实验性质的库。作者在loki中把C++模板的功能发挥到了极致。并且尝试把类似设计模式这样思想层面的东西通过库来提供。同时还提供了智能指针这样比较实用的功能。 12.２、ATL ATL(Active Template Library)是一组小巧、高效、灵活的类，这些类为创建可互操作的COM组件提供了基本的设施。 12.３、FC++: The Functional C++ Library 这个库提供了一些函数式语言中才有的要素。属于用库来扩充语言的一个代表作。如果想要在OOP之外寻找另一分的乐趣，可以去看看函数式程序设计的世界。大师Peter Norvig在 “Teach Yourself Programming in Ten Years”一文中就将函数式语言列为至少应当学习的6类编程语言之一。 12.４、FACT! 另外一个实现函数式语言特性的库 12.５、Crypto++ 提供处理密码，消息验证，单向hash，公匙加密系统等功能的免费库。 还有很多非常激动人心或者是极其实用的C++库，限于我们的水平以及文章的篇幅不能包括进来。在对于这些已经包含近来的库的介绍中，由于并不是每一个我们都使用过，所以难免有偏颇之处，请读者见谅。 13、C++名人的网站 正如我们可以通过计算机历史上的重要人物了解计算机史的发展，C++相关人物的网站也可以使我们得到最有价值的参考与借鉴，下面的人物我们认为没 有介绍的必要，只因下面的人物在C++领域的地位众所周知，我们只将相关的资源进行罗列以供读者学习，他们有的工作于贝尔实验室，有的工作于知名编译器厂 商，有的在不断推进语言的标准化，有的为读者撰写了多部千古奇作…… １、Bjarne Stroustrup ２、Stanley B. Lippman ３、Scott Meyers ４、David Musser ５、Bruce Eckel ６、Nicolai M. Josuttis ７、Herb Sutter ８、Andrei Alexandrescu","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"【转】 STM32的can总线实验心得","slug":"z_csdn_001_6773192","date":"2011-04-12T20:00:00.000Z","updated":"2021-12-10T06:23:57.228Z","comments":true,"path":"2011/04/12/z_csdn_001_6773192/","link":"","permalink":"http://vball.fun/2011/04/12/z_csdn_001_6773192/","excerpt":"","text":"**(一) 工业现场总线 CAN 的基本介绍以及 STM32 的 CAN 模块简介**首先通读手册中关于CAN的文档，必须精读。STM32F10xxx 参考手册Rev7V3.pdfhttp://www.mystm32.com/bbs/redirect.php?tid=255&amp;goto=lastpost#lastpost 需要精读的部分为 RCC 和 CAN 两个章节。为什么需要精读 RCC 呢？因为我们将学习 CAN 的波特率的设置，将要使用到 RCC 部分的设置，因此推荐大家先复习下这部分中的几个时钟。 关于 STM32 的 can 总线简单介绍bxCAN 是基本扩展 CAN (Basic Extended CAN) 的缩写，它支持 CAN 协议 2.0A 和 2.0B 。它的设计目标是，以最小的 CPU 负荷来高效处理大量收到的报文。它也支持报文发送的优先级要求（优先级特性可软件配置）。对于安全紧要的应用，bxCAN 提供所有支持时间触发通信模式所需的硬件功能。 **主要特点**· 支持 CAN 协议 2.0A 和 2.0B 主动模式· 波特率最高可达 1 兆位 / 秒· 支持时间触发通信功能 **发送**· 3 个发送邮箱· 发送报文的优先级特性可软件配置· 记录发送 SOF 时刻的时间戳 **接收**· 3 级深度的2个接收 FIFO· 14 个位宽可变的过滤器组 － 由整个 CAN 共享· 标识符列表· FIFO 溢出处理方式可配置· 记录接收 SOF 时刻的时间戳 **可支持时间触发通信模式**· 禁止自动重传模式· 16 位自由运行定时器· 定时器分辨率可配置· 可在最后 2 个数据字节发送时间戳 **管理**· 中断可屏蔽· 邮箱占用单独 1 块地址空间，便于提高软件效率 (二) STM32 CAN 模块工作模式STM32 的 can 的工作模式分为:/* CAN operating mode /#define CAN_Mode_Normal ((u8)0x00) / normal mode /#define CAN_Mode_LoopBack ((u8)0x01) / loopback mode /#define CAN_Mode_Silent ((u8)0x02) / silent mode /#define CAN_Mode_Silent_LoopBack ((u8)0x03) / loopback combined with silent mode */ 在此章我们的 Mini-STM32 教程中我们将使用到 CAN_Mode_LoopBack 和 CAN_Mode_Normal 两种模式。我们第一步做的就是使用运行在 CAN_Mode_LoopBack 下进行自测试。 在参考手册中 CAN_Mode_LoopBack (环回模式) 的定义如下:环回模式可用于自测试。为了避免外部的影响，在环回模式下 CAN 内核忽略确认错误 (在数据 / 远程帧的确认位时刻，不检测是否有显性位) 。在环回模式下，bxCAN 在内部把 Tx 输出回馈到 Rx 输入上，而完全忽略 CANRX 引脚的实际状态。发送的报文可以在 CANTX 引脚上检测到。因此这种模式也特别适合大家做好硬件后自测程序。 **(三) CAN 接口端口映射** STM32 中的 CAN 物理引脚脚位可以设置成三种： 默认模式，重定义地址1模式，重定义地址2模式 。 在我们的 Mini-STM32 上面没有接出 CAN 的接口芯片, 所以我们可以利用 RealView MDK 的 CAN 软件 模拟 模块来做实验. 默认模式 /* Configure CAN pin: RX */ GPIO _InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* Configure CAN pin: TX */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); 重定义地址1模式 /* Configure CAN pin: RX */ //GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* Configure CAN pin: TX */ //GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* Configure CAN Remap 重影射 */ //GPIO_PinRemapConfig(GPIO_Remap1_CAN, ENABLE); **重定义地址2模式** /* Configure CAN pin: RX */ //GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* Configure CAN pin: TX */ //GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* Configure CAN Remap 重影射 */ //GPIO_PinRemapConfig(GPIO_Remap2_CAN, ENABLE); 设置完 CAN 的引脚之后还需要打开 CAN 的时钟： /* CAN Periph clock enable */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE); **(四) CAN 波特率设置** 4、我们需要搞明白CAN波特率的设置，这个章节也是使用CAN的最重要的部分之一，因为这实际应用中我们需要根据我们实际的场合来选择 CAN 的波特率。 一般情况下面1M bps 的速率下可以最高可靠传输 40 米以内的距离。 在 50K 以下的波特率中一般可以可靠传输数公里远。 对于波特率的设置需要详细学习参考手册对应部分的解释。我们在调试软件的时候可以使用示波器来测试 CANTX 引脚上的波形的波特率，这样可以得到事半功倍的效果，大大的缩短调试学习的时间。 // *************************************************************** // BaudRate = 1 / NominalBitTime // NominalBitTime = 1tq + tBS1 + tBS2 // tq = (BRP[9:0] + 1) x tPCLK // tPCLK = CAN’s clock = APB1’s clock // **************************************************************** 也就是BaudRate = APB1 / ((BS1 + BS2 + 1) * Prescaler) 这里注意的是采用点的位置,也就时BS1,BS2的设置问题，这里我也找了一些资料，抄录下来给大家,是 CANopen 协议中推荐的设置。 1Mbps 速率下，采用点的位置在6tq位置处，BS1=5, BS2=2 500kbps 速率下，采用点的位置在8tq位置处，BS1=7, BS2=3 250kbps 速率下，采用点的位置在14tq位置处，BS1=13, BS2=2 125k, 100k, 50k, 20k, 10k 的采用点位置与 250K 相同。 因此我们需要重视的有软件中的这么几个部分： // 设置 AHB 时钟（HCLK） // RCC_SYSCLK_Div1 AHB 时钟 = 系统时钟 RCC_HCLKConfig(RCC_SYSCLK_Div8); // 设置低速 AHB 时钟（PCLK1） // RCC_HCLK_Div2 APB1 时钟 = HCLK / 2 RCC_PCLK1Config(RCC_HCLK_Div2); // PLLCLK = 8MHz * 8 = 64 MHz // 设置 PLL 时钟源及倍频系数 RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_8); CAN 波特率设置中需要的就是PCLK1 的时钟。 CAN_InitStructure.CAN_Mode=CAN_Mode_LoopBack; CAN_InitStructure.CAN_SJW=CAN_SJW_1tq; CAN_InitStructure.CAN_BS1=CAN_BS1_8tq; CAN_InitStructure.CAN_BS2=CAN_BS2_7tq; CAN_InitStructure.CAN_Prescaler=5; 通过上面部分的时钟设置我们已经可以算出我们的波特率了 CAN_bps = PCLK1 / ((1 + 7 + 8) * 5) = 25K bps 大家也可以实际测试中修改时钟值来通过示波器测试我们需要的波特率是否正确例如将PLLCLK 设置降低一半： // PLLCLK = 8MHz * 4 = 32 MHz // 设置 PLL 时钟源及倍频系数 RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_4); 那么我们得到的CAN_bps也会降低一半。 接下来还可以修改 HCLK 和 PCLK1 ，其实最终这几个分频和倍频值最终影响的都是 PCLK1。 通过几次试验，相信大家应该很容易掌握波特率的设置了。 设置完波特率我们直接测试函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* CAN transmit at 100Kb/s and receive by polling in loopback mode*/TestRx = CAN_Polling();if (TestRx == FAILED)&#123;/* Turn on led connected to PA.00 pin (LD1) */GPIO_SetBits(GPIOA, GPIO_Pin_0);&#125;else&#123;/* Turn off led connected to PA.00 pin (LD1) */GPIO_ResetBits(GPIOA, GPIO_Pin_0);&#125;/* CAN transmit at 500Kb/s and receive by interrupt in loopback mode*/TestRx = CAN_Interrupt();if (TestRx == FAILED)&#123;/* Turn on led connected to PA.01 pin (LD2) */GPIO_SetBits(GPIOA, GPIO_Pin_1);&#125;else&#123;/* Turn off led connected to PA.01 pin (LD2) */GPIO_ResetBits(GPIOA, GPIO_Pin_1);&#125; 将CAN 软件仿真模拟器调用出来. 大家可以仿真程序，当程序中 Test 等于 Passed 那么说明 Loopback 模式测试通过了。 并且在 CAN 通讯框中我们可以看到发送和接收到的数据: 回循模式下的源代码, 基于 MDK3.5: (493.79 KB) 到此时说明如果大家只有一块CAN模块的时候学习可以告一个段落了，不过这个并不代表大家就已经掌握了 CAN 了，正真要掌握它，大家还是需要看大量的 CAN 部分的资料，参考手册部分的也是不够的，市面上有几本专门介绍现场总线和CAN总线的书，推荐大家买来经常翻翻看看，这样到需要实际应用的时候才可以做到 如鱼得水。 **(五) 正常模式** 完成了 loopback 模式的测试之后接下来我们需要学习的就是多机通讯了，当然由于我们的 Mini-STM32 没有将 CAN 接口引出来, 所以我们没有办法在板子上面做这部分的试验了，只能在 RealView MDK 的软件中进行模拟。 如果您拥有两块带 CAN 硬件的 STM32 的板子，您需要自己构建硬件的物理层的连接, 使用三根线将 CANH,CANL,GND 三根线直连，当然你要接好终端电阻才能保证通讯的正常通讯，当两块板子都跳好后我们使用万用表测量下 CANH和CANL之间的电阻是否为 60 欧姆。多块板子多机通讯的是否你只需要在总线的主机端和最后一端接上终端电阻就可以了. 在初始化完成后，软件应该让硬件进入正常模式，以便正常接收和发送报文。软件可以通过对 CAN_MCR 寄存器的INRQ位清 ‘0’，来请求从初始化模式进入正常模式，然后要等待硬件对 CAN_MSR 寄存器的 INAK 位置 ‘1’ 的确认。在跟 CAN 总线取得同步，即在 CANRX 引脚上监测到 11 个连续的隐性位 (等效于总线空闲) 后，bxCAN 才能正常接收和发送报文。 不需要在初始化模式下进行过滤器初值的设置，但必须在它处在非激活状态下完成 (相应的 FACT 位为 ‘0’ ) 。而过滤器的位宽和模式的设置，则必须在初始化模式中进入正常模式前完成。 准备工作做完我们需要设置 CAN 通讯部份软件。 我们把 TestStatus CAN_Polling(void) 函数和 TestStatus CAN_Interrupt(void) 函数中的 LoopBack 模式修改为 Normal 模式. //CAN_InitStructure.CAN_Mode=CAN_Mode_LoopBack; CAN_InitStructure.CAN_Mode=CAN_Mode_Normal; 接下来我们就可以做实验了. 但是由于 RealView MDK 的 CAN 模块没有办法接收, 所以我们只做发送的例子. 我们的例子中分别发送两帧数据: (1) TestStatus CAN_Polling(void) 查询发送 第一帧数据为: ID 为 0x11, 数据为 8 个字节的一个数据包. TxMessage.StdId=0x11; TxMessage.RTR=CAN_RTR_DATA; TxMessage.IDE=CAN_ID_STD; TxMessage.DLC=8; TxMessage.Data[0]=0x01; TxMessage.Data[1]=0x02; TxMessage.Data[2]=0x03; TxMessage.Data[3]=0x04; TxMessage.Data[4]=0x05; TxMessage.Data[5]=0x06; TxMessage.Data[6]=0x07; TxMessage.Data[7]=0x08; **(2) TestStatus CAN_Interrupt(void) 中断发送** 第二帧数据为:ID 为 0x1234, 数据为 8 个字节的一个数据包. TxMessage.StdId=0x12; TxMessage.ExtId=0x34; TxMessage.IDE=CAN_ID_EXT; TxMessage.RTR=CAN_RTR_DATA; TxMessage.DLC=8; TxMessage.Data[0]=0x11; TxMessage.Data[1]=0x22; TxMessage.Data[2]=0x33; TxMessage.Data[3]=0x44; TxMessage.Data[4]=0x55; TxMessage.Data[5]=0x66; TxMessage.Data[6]=0x77; TxMessage.Data[7]=0x88; CAN_Transmit(&amp;TxMessage); 在主函数中初始化之后加上这两句发送函数: /* CAN transmit at 100Kb/s and receive by polling in Normal mode*/ CAN_Polling(); while(i++ &lt; 1000); /* CAN transmit at 500Kb/s and receive by interrupt in Normal mode*/ CAN_Interrupt(); 程序改完了, 我们需要编译通过后, 点软件仿真. 将 CAN 软件仿真模拟器 调用出来. 接下来我们全速运行到 while(1) 就可以看到结果了.","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"java学习书籍","slug":"z_csdn_015_6153267","date":"2011-01-19T01:58:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2011/01/19/z_csdn_015_6153267/","link":"","permalink":"http://vball.fun/2011/01/19/z_csdn_015_6153267/","excerpt":"","text":"一直有这么个想法，列一下我个人认为在学习和使用Java过程中可以推荐一读的书籍，给初学者或者想深入的朋友一些建议，帮助成长。推荐的的都是我自己读过，也会推荐一些朋友读过并且口碑不错的书籍。 一、基础类1、《Thinking in java》，入门第一位是建立正确的概念。2、《Core Java》，我没系统读过，这本书更贴近实践，更多API的介绍，同样，更新也更频繁。 二、进阶类1、《Effective Java》，在熟悉语法、API之后，你需要知道最佳实践和陷阱，没有比这本更好的。2、《Java Puzzlers》，通过谜题介绍一些你可能没有注意到的边角料，作为趣味读物也不错3、《深入Java虚拟机》，翻译一般，但不可不读，最好结合最新的JVM规范来读。 三、特定领域1、网络编程：（1） O’Reilly的《Java nio》，很多人都推荐，我个人觉的一般，基本上只是个API更详细的说明文档,O’reilly的java系列很多都是这样。（2）我更推荐这本《Fundamental networking in java》，由浅入深教你怎么做java网络编程，并且介绍很多背景知识，甚至介绍了各种最佳实践、网络编程模型以及Java socket在不同平台之间的差异等等。 2、并发编程：（1）《Java Concurrency in Practic》，并发领域必读经典。（2）《Java并发编程：设计原则与模式》，同样是Doug lea的作品。（3) 《java threads》，入门读物。 3、web编程，这块我许久未接触了，就不推荐了，有兴趣的朋友可以补充下。 四、模式与设计 1、《设计模式》，GOF的经典。2、《设计模式精解》，应该有最新版，个人认为更适合入门。3、《Head first设计模式》，更轻松的入门读物。4、《企业应用架构模式》5、《分析模式——可复用对象模型》6、《面向模式的软件体系结构》，国内貌似翻译了3卷，绝对经典，可惜翻译较差。7、《重构——改善既有代码设计》,想写好代码必读。8、《重构与模式》 五、方法论1、《敏捷软件开发》2、《测试驱动开发》，你不一定要TDD，但是你一定要学会做单元测试。3、《Agile Java》，也可以作为java入门读物。4、《快速软件开发》5、《面向对象分析与设计》，OO设计必读。6、《Unix编程艺术》，打开你的眼界。 六、Java之外 1、《unix网络编程》，学习网络编程必读书。2、《C++网络编程》上下两卷，介绍ACE的，但是其中对各种模式运用的介绍非常值的一读。3、《Joel说软件》，编程文化4、《人月神话》、《人件》5、《卓有成效的程序员》，给我很大启发的一本书。6、《程序员修炼之道》7、《计算机程序的构造与解释》，必读8、《算法导论》，可以作为参考书9、《深入理解计算机系统》10、《编译原理》龙书，最新版用java解释，我没有读完，顺便提下。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"跨平台开发c++","slug":"z_csdn_074_6153271","date":"2011-01-19T01:58:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2011/01/19/z_csdn_074_6153271/","link":"","permalink":"http://vball.fun/2011/01/19/z_csdn_074_6153271/","excerpt":"","text":"made with nui 跨平台开发c++，for C++ multiplatform API: Mac OS X, iPhone, iPad, Win32, Win64, Linux 超越qt范围啊，呵呵，回头仔细看看 上面的网址需要翻墙，呵呵，自己去找资料吧，貌似很强大","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"收藏","slug":"z_csdn_036_6101585","date":"2010-12-28T11:34:11.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2010/12/28/z_csdn_036_6101585/","link":"","permalink":"http://vball.fun/2010/12/28/z_csdn_036_6101585/","excerpt":"","text":"打开协议栈，在工程文件的左边Workspace 中可以看到整个协议栈的构架，如图所示， APP ：应用层目录，这是用户创建各种不同工程的区域，在这个目录中包含了应用层的内容和这个项目的主要内容，在协议栈里面一般是以操作系统的任务实现的。 HAL ：硬件层目录，包含有与硬件相关的配置和驱动及操作函数。 MAC ：MAC 层目录，包含了MAC 层的参数配置文件及其MAC 的LIB 库的函数接口文件。 MT ：实现通过串口可控各层，于各层进行直接交互。 NWK ：网络层目录，含网络层配置参数文件及网络层库的函数接口文件，APS 层库的函数接口 OSAL ：协议栈的操作系统。 Profile ：AF 层目录，包含AF 层处理函数文件。 Security ：安全层目录，安全层处理函数，比如加密函数等。 Services ：地址处理函数目录，包括着地址模式的定义及地址处理函数。 Tools ：工程配置目录，包括空间划分及ZStack 相关配置信息。 ZDO ：ZDO 目录。 ZMac ：MAC 层目录，包括MAC 层参数配置及MAC 层LIB 库函数回调处理函数。 ZMain ：主函数目录，包括入口函数及硬件配置文件。 Output ：输出文件目录，这个EW8051 IDE 自动生成的。 从上面的描述中可以看出，整个协议栈中，对于Zigbee 的功能已经全部体现，在次基础上建立一个项目的方法主要是改动应用层，下面，我们以一个简单的例子，协调器用按键控制发送一组数据，通过这组数据控制路由器设备的小灯闪烁，来讲解整个协议栈的使用。我们将这个项目的名字设置为WXL_example 功能分析项目的功能一共有按键检测、发送数据、接收数据、小灯控制四种，在协议栈中已经将CC2430 的底层驱动全部固化在协议栈中，我们直接调用就可以了。 添加一个任务整个协议栈是以一个OS 贯穿的，我们要加入自己的应用，就要添加一个任务，（具体关于操作系统的介绍，请参考OSAL API_F8W-2003-0002_.pdf 文档），在任务中执行，与协议栈实现无缝连接。 在协议栈中的OSAL.c 文件中，byte osal_init_system( void )函数的功能是初始化OS 、添加任务到OS 任务表中。在这个函数中通过调用osalAddTasks()函数来定制项目所需要应用的任务，该函数属于应用层和OS 之间的接口函数，一般项目的建立需要根据系统的需要自己编写改函数，并将函数放到应用层。osalAddTasks()函数是通过osalTaskAdd()函数完成任务添加。 首先，将支持协议栈功能需要的任务加载到该函数中， void osalAddTasks( void ) osalTaskAdd (Hal_Init, Hal_ProcessEvent, OSAL_TASK_PRIORITY_LOW); #if defined( ZMAC_F8W ) osalTaskAdd( macTaskInit, macEventLoop, OSAL_TASK_PRIORITY_HIGH ); #endif #if defined( MT_TASK ) osalTaskAdd( MT_TaskInit, MT_ProcessEvent, OSAL_TASK_PRIORITY_LOW ); #endif osalTaskAdd( nwk_init, nwk_event_loop, OSAL_TASK_PRIORITY_MED ); osalTaskAdd( APS_Init, APS_event_loop, OSAL_TASK_PRIORITY_LOW ); osalTaskAdd( ZDApp_Init, ZDApp_event_loop, OSAL_TASK_PRIORITY_LOW ); 这些任务是协议栈运行的先决条件，为了更好的使用协议栈，建议将这些任务都添加到任务列表中。这些函数的参数条件在协议栈中已经定义好，可以直接使用。 从上面加载的函数中可以发现，要建立一个单独的任务，必须先将osalTaskAdd()函数所需要的参数条件定义好，这些参数分别是初始化函数WXL_example_Init ，任务处理函数WXL_example_event_loop 和任务优先级。 任务初始化函数的功能是将该任务需要完成的功能的功能部件初始化，在每一个任务的初始化函数中，必须完成的功能是要得到设置任务的任务ID 。 void WXL_ SampleApp _Init ( uint8 task_id ) WXL_ SampleApp _Init = task_id; 由于在这个任务中还有其他的功能，所以，我们对其他功能也需要做一定的初始化，包括对发送数据的设置，按键的设置等。实现的函数为： void WXL_SampleApp_Init ( uint8 task_id ) WXL_SampleApp_TaskID = task_id;//任务ID /**********************************************************/ /通讯需要的参数/ /**********************************************************/ WXL_SampleApp_NwkState = DEV_INIT;//网络类型 WXL_SampleApp_TransID = 0; //设置发送数据的方式和目的地址 //广播到所有的设备 WXL_SampleApp_All_DstAddr.addrMode = (afAddrMode_t)AddrBroadcast; WXL_SampleApp_All_DstAddr.endPoint = WXL_SAMPLEAPP_ENDPOINT; WXL_SampleApp_All_DstAddr.addr.shortAddr = 0xFFFF; //单播到一个设备 WXL_SampleApp_Single_DstAddr.addrMode = (afAddrMode_t)afAddrGroup; WXL_SampleApp_Single_DstAddr.endPoint = WXL_SAMPLEAPP_ENDPOINT; //设置endpoint description. WXL_SampleApp_epDesc.endPoint = WXL_SAMPLEAPP_ENDPOINT; WXL_SampleApp_epDesc.task_id = &amp;WXL_SampleApp_TaskID; WXL_SampleApp_epDesc.simpleDesc = (SimpleDescriptionFormat_t *)&amp;WXL_SampleApp_SimpleDesc; WXL_SampleApp_epDesc.latencyReq = noLatencyReqs; //登记endpoint description 到AF afRegister( &amp;WXL_SampleApp_epDesc ); //登记所有的按键事件 RegisterForKeys( WXL_SampleApp_TaskID ); 任务处理函数是对任务发生后的事件进行处理，在这个项目中主要完成的功能是通过协调器上的按键发送一个数据，控制路由器的小灯。所以里面就应该设计到按键的事件处理，网络状态的判断（判断设备的类型，是协调器还是路由器或者是终端设备）和接收到信息后的处理。处理函数为： /********************************************************************* @函数名WXL_SampleApp_ProcessEvent *函数功能:一般应用任务事件处理，这个函数是处理所有的事件到任务，事件包括 *时间片、消息和所有其他使用者定义过的时间。 @参数：task_id - OS 分配的任务ID.这个ID 将用于发送数据和设置时间片. *events-处理的事件 @returnnone uint16 WXL_SampleApp_ProcessEvent( uint8 task_id, uint16 events ) afIncomingMSGPacket_t *MSGpkt; if ( events &amp; SYS_EVENT_MSG )//系统信息， MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( WXL_SampleApp_TaskID );//OS 发送过来的信息 while ( MSGpkt ) switch ( MSGpkt-&gt;hdr.event ) //按键事件 case KEY_CHANGE: //按键处理函数 WXL_SampleApp_HandleKeys( ((keyChange_t *)MSGpkt)-&gt;keys ); break; //接收数据事件 case AF_INCOMING_MSG_CMD: //接收数据的处理函数 WXL_SampleApp_MessageMSGCB( MSGpkt ); break; //网络状态发生变化时间 case ZDO_STATE_CHANGE: WXL_SampleApp_NwkState = (devStates_t)(MSGpkt-&gt;hdr.status);//获取网络状态 if ( (WXL_SampleApp_NwkState == DEV_ZB_COORD)//判断网络类型 || (WXL_SampleApp_NwkState == DEV_ROUTER) || (WXL_SampleApp_NwkState == DEV_END_DEVICE) ) else //设备不属于这个网络 break; default: break; //释放存储器 osal_msg_deallocate( (uint8 *)MSGpkt ); // Next -如果有一个空闲的任务 MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( WXL_SampleApp_TaskID ); //返回未处理的任务 return (events ^ SYS_EVENT_MSG); return 0; 按键子函数的功能是处理所有的按键事件，在这里需要特别申明的是，本程序只实用与无线龙通讯科技有限公司的硬件。按键的底层驱动函数在Hal_key.c 中，我们在这里按键需要完成的任务是，当协调器按键1 被按下后，以广播的方式发送数据去让路由器小灯闪烁。 /********************************************************************* @函数名WXL_SampleApp_HandleKeys @函数功能：处理所有的按键事件 @参数：keys -返回的按键值 @returnnone void WXL_SampleApp_HandleKeys(uint8 keys ) if ( keys &amp; HAL_KEY_SW_1 ) if(WXL_SampleApp_NwkState == DEV_ZB_COORD)//如果是协调器 WXL_SampleApp_SendFlashMessage( WXL_SAMPLEAPP_FLASH_DURATION );//发送数据 else 接收处理函数的功能有两部分，一是路由器的接收函数，二是协调器的接收处理函数。在这个项目里面，我们将这两种设备的处理函数都固化在了一个函数里面，用串ID 来判断他们的设备类型。当路由器接收到数据后，先判断该信息的串ID ，然后判断命令，如果命令正确，则小灯闪烁，然后单播发送确认信号给协调器，协调器收到信号后，同样先判断串ID ，然后确认命令后小灯闪烁示意。 /********************************************************************* @函数名：SampleApp_MessageMSGCB @函数功能：接收的数据处理量.根据不同的串ID 实现不同的功能。 @paramnone @returnnone void WXL_SampleApp_MessageMSGCB( afIncomingMSGPacket_t *pkt ) unsigned char Rx_Buf[4]; switch ( pkt-&gt;clusterId ) case WXL_SAMPLEAPP_CLUSTERID1: memcpy(Rx_Buf,pkt-&gt;cmd.Data,3); if((Rx_Buf[0] == ‘Y’) &amp;&amp; (Rx_Buf[1] == ‘E’) &amp;&amp; (Rx_Buf[2] == ‘S’)) HalLedBlink( HAL_LED_4, 4, 50, 250);//小灯闪烁四次 break; case WXL_SAMPLEAPP_CLUSTERID2: memcpy(Rx_Buf,pkt-&gt;cmd.Data,4); if((Rx_Buf[0] == ‘O’) &amp;&amp; (Rx_Buf[1] == ‘P’) &amp;&amp; (Rx_Buf[2] == ‘E’) &amp;&amp; (Rx_Buf[3] == ‘N’)) HalLedBlink( HAL_LED_4, 4, 50, 250);//小灯闪烁四次 SendData(“YES”,pkt-&gt;srcAddr.addr.shortAddr,3);//以单播的方式回复信号 break; /********************************************************************* @函数名：SampleApp_SendFlashMessage @函数功能：广播发送一串数据。 @paramnone @returnnone void WXL_SampleApp_SendFlashMessage( uint8 *buffer ) if ( AF_DataRequest( &amp;WXL_SampleApp_All_DstAddr, &amp;WXL_SampleApp_epDesc, WXL_SAMPLEAPP_CLUSTERID2, buffer, &amp;WXL_SampleApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS ) else // Error occurred in request to send. //********************************************************************** //**以短地址方式发送数据 //buf ::发送的数据 //addr::目的地址 //Leng::数据长度 //******************************************************************** void WXL_SampleApp_SendData(uint8 *buf, uint16 addr, uint8 Leng) WXL_SampleApp_Single_DstAddr.addr.shortAddr = addr; if ( AF_DataRequest( &amp;WXL_SampleApp_Single_DstAddr, //发送的地址和模式 &amp;WXL_SampleApp_epDesc,//终端（比如操作系统中任务ID 等） WXL_SAMPLEAPP_CLUSTERID1,//发送串ID Leng, buf, &amp;WXL_SampleApp_TransID, AF_DISCV_ROUTE, //AF_ACK_REQUEST, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS ) else 发送数据只是掉用一个函数，在这里不多做解释。 完成任务的添加这时候回到2.2 节中将建立的任务添加在列表中。 void osalAddTasks( void ) osalTaskAdd (Hal_Init, Hal_ProcessEvent, OSAL_TASK_PRIORITY_LOW); #if defined( ZMAC_F8W ) osalTaskAdd( macTaskInit, macEventLoop, OSAL_TASK_PRIORITY_HIGH ); #endif #if defined( MT_TASK ) osalTaskAdd( MT_TaskInit, MT_ProcessEvent, OSAL_TASK_PRIORITY_LOW ); #endif osalTaskAdd( nwk_init, nwk_event_loop, OSAL_TASK_PRIORITY_MED ); osalTaskAdd( APS_Init, APS_event_loop, OSAL_TASK_PRIORITY_LOW ); osalTaskAdd( ZDApp_Init, ZDApp_event_loop, OSAL_TASK_PRIORITY_LOW ); osalTaskAdd( WXL_SampleApp_Init, WXL_SampleApp_ProcessEvent, OSAL_TASK_PRIORITY_LOW ); 其他定义const cId_t WXL_SampleApp_ClusterList[WXL_SAMPLEAPP_MAX_CLUSTERS] = WXL_SAMPLEAPP_CLUSTERID1, WXL_SAMPLEAPP_CLUSTERID2 const SimpleDescriptionFormat_t WXL_SampleApp_SimpleDesc = WXL_SAMPLEAPP_ENDPOINT,//int Endpoint; WXL_SAMPLEAPP_PROFID,//uint16 AppProfId[2]; WXL_SAMPLEAPP_DEVICEID,//uint16 AppDeviceId[2]; WXL_SAMPLEAPP_DEVICE_VERSION,//intAppDevVer:4; WXL_SAMPLEAPP_FLAGS,//intAppFlags:4; WXL_SAMPLEAPP_MAX_CLUSTERS,//uint8AppNumInClusters; (cId_t *)WXL_SampleApp_ClusterList,//uint8 *pAppInClusterList; WXL_SAMPLEAPP_MAX_CLUSTERS,//uint8AppNumInClusters; (cId_t *)WXL_SampleApp_ClusterList//uint8 *pAppInClusterList; endPointDesc_t WXL_SampleApp_epDesc; /变量申明*****/ uint8 WXL_SampleApp_TaskID;//内部的任务ID ，它的值在SampleApp_Init （）中获得 devStates_t WXL_SampleApp_NwkState;//网络状态 uint8 WXL_SampleApp_TransID;//这是唯一的一个消息ID(计数器) afAddrType_t WXL_SampleApp_All_DstAddr;//广播的方式 afAddrType_t WXL_SampleApp_Single_DstAddr;//短地址单播的方式 #define WXL_SAMPLEAPP_ENDPOINT20 #define WXL_SAMPLEAPP_PROFID0x0F08 #define WXL_SAMPLEAPP_DEVICEID0x0001 #define WXL_SAMPLEAPP_DEVICE_VERSION0 #define WXL_SAMPLEAPP_FLAGS0 #define WXL_SAMPLEAPP_MAX_CLUSTERS2 #define WXL_SAMPLEAPP_CLUSTERID11 #define WXL_SAMPLEAPP_CLUSTERID22 通过上面的介绍，可以知道协议栈的一个简单的使用流程，由于整个协议栈已经将数据通讯的代码做好，我们只需要调用里面的函数就可以了，所以就没有具体介绍网络层里面的东西。完成任务添加后，在编译下载，就可以运行协议栈了，下载后，按协调器按键1 （对应无线龙扩展板UP 键），会发送一个数据给路由器，路由器红灯闪烁，然后路由器也会发送一个数据回来，导致协调器红灯闪烁。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"收藏","slug":"z_csdn_018_6101587","date":"2010-12-27T23:36:10.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2010/12/27/z_csdn_018_6101587/","link":"","permalink":"http://vball.fun/2010/12/27/z_csdn_018_6101587/","excerpt":"","text":"打开协议栈，在工程文件的左边Workspace 中可以看到整个协议栈的构架，如图所示， APP ：应用层目录，这是用户创建各种不同工程的区域，在这个目录中包含了应用层的内容和这个项目的主要内容，在协议栈里面一般是以操作系统的任务实现的。 HAL ：硬件层目录，包含有与硬件相关的配置和驱动及操作函数。 MAC ：MAC 层目录，包含了MAC 层的参数配置文件及其MAC 的LIB 库的函数接口文件。 MT ：实现通过串口可控各层，于各层进行直接交互。 NWK ：网络层目录，含网络层配置参数文件及网络层库的函数接口文件，APS 层库的函数接口 OSAL ：协议栈的操作系统。 Profile ：AF 层目录，包含AF 层处理函数文件。 Security ：安全层目录，安全层处理函数，比如加密函数等。 Services ：地址处理函数目录，包括着地址模式的定义及地址处理函数。 Tools ：工程配置目录，包括空间划分及ZStack 相关配置信息。 ZDO ：ZDO 目录。 ZMac ：MAC 层目录，包括MAC 层参数配置及MAC 层LIB 库函数回调处理函数。 ZMain ：主函数目录，包括入口函数及硬件配置文件。 Output ：输出文件目录，这个EW8051 IDE 自动生成的。 从上面的描述中可以看出，整个协议栈中，对于Zigbee 的功能已经全部体现，在次基础上建立一个项目的方法主要是改动应用层，下面，我们以一个简单的例子，协调器用按键控制发送一组数据，通过这组数据控制路由器设备的小灯闪烁，来讲解整个协议栈的使用。我们将这个项目的名字设置为WXL_example 功能分析项目的功能一共有按键检测、发送数据、接收数据、小灯控制四种，在协议栈中已经将CC2430 的底层驱动全部固化在协议栈中，我们直接调用就可以了。 添加一个任务整个协议栈是以一个OS 贯穿的，我们要加入自己的应用，就要添加一个任务，（具体关于操作系统的介绍，请参考OSAL API_F8W-2003-0002_.pdf 文档），在任务中执行，与协议栈实现无缝连接。 在协议栈中的OSAL.c 文件中，byte osal_init_system( void )函数的功能是初始化OS 、添加任务到OS 任务表中。在这个函数中通过调用osalAddTasks()函数来定制项目所需要应用的任务，该函数属于应用层和OS 之间的接口函数，一般项目的建立需要根据系统的需要自己编写改函数，并将函数放到应用层。osalAddTasks()函数是通过osalTaskAdd()函数完成任务添加。 首先，将支持协议栈功能需要的任务加载到该函数中， void osalAddTasks( void ) osalTaskAdd (Hal_Init, Hal_ProcessEvent, OSAL_TASK_PRIORITY_LOW); #if defined( ZMAC_F8W ) osalTaskAdd( macTaskInit, macEventLoop, OSAL_TASK_PRIORITY_HIGH ); #endif #if defined( MT_TASK ) osalTaskAdd( MT_TaskInit, MT_ProcessEvent, OSAL_TASK_PRIORITY_LOW ); #endif osalTaskAdd( nwk_init, nwk_event_loop, OSAL_TASK_PRIORITY_MED ); osalTaskAdd( APS_Init, APS_event_loop, OSAL_TASK_PRIORITY_LOW ); osalTaskAdd( ZDApp_Init, ZDApp_event_loop, OSAL_TASK_PRIORITY_LOW ); 这些任务是协议栈运行的先决条件，为了更好的使用协议栈，建议将这些任务都添加到任务列表中。这些函数的参数条件在协议栈中已经定义好，可以直接使用。 从上面加载的函数中可以发现，要建立一个单独的任务，必须先将osalTaskAdd()函数所需要的参数条件定义好，这些参数分别是初始化函数WXL_example_Init ，任务处理函数WXL_example_event_loop 和任务优先级。 任务初始化函数的功能是将该任务需要完成的功能的功能部件初始化，在每一个任务的初始化函数中，必须完成的功能是要得到设置任务的任务ID 。 void WXL_ SampleApp _Init ( uint8 task_id ) WXL_ SampleApp _Init = task_id; 由于在这个任务中还有其他的功能，所以，我们对其他功能也需要做一定的初始化，包括对发送数据的设置，按键的设置等。实现的函数为： void WXL_SampleApp_Init ( uint8 task_id ) WXL_SampleApp_TaskID = task_id;//任务ID /**********************************************************/ /通讯需要的参数/ /**********************************************************/ WXL_SampleApp_NwkState = DEV_INIT;//网络类型 WXL_SampleApp_TransID = 0; //设置发送数据的方式和目的地址 //广播到所有的设备 WXL_SampleApp_All_DstAddr.addrMode = (afAddrMode_t)AddrBroadcast; WXL_SampleApp_All_DstAddr.endPoint = WXL_SAMPLEAPP_ENDPOINT; WXL_SampleApp_All_DstAddr.addr.shortAddr = 0xFFFF; //单播到一个设备 WXL_SampleApp_Single_DstAddr.addrMode = (afAddrMode_t)afAddrGroup; WXL_SampleApp_Single_DstAddr.endPoint = WXL_SAMPLEAPP_ENDPOINT; //设置endpoint description. WXL_SampleApp_epDesc.endPoint = WXL_SAMPLEAPP_ENDPOINT; WXL_SampleApp_epDesc.task_id = &amp;WXL_SampleApp_TaskID; WXL_SampleApp_epDesc.simpleDesc = (SimpleDescriptionFormat_t *)&amp;WXL_SampleApp_SimpleDesc; WXL_SampleApp_epDesc.latencyReq = noLatencyReqs; //登记endpoint description 到AF afRegister( &amp;WXL_SampleApp_epDesc ); //登记所有的按键事件 RegisterForKeys( WXL_SampleApp_TaskID ); 任务处理函数是对任务发生后的事件进行处理，在这个项目中主要完成的功能是通过协调器上的按键发送一个数据，控制路由器的小灯。所以里面就应该设计到按键的事件处理，网络状态的判断（判断设备的类型，是协调器还是路由器或者是终端设备）和接收到信息后的处理。处理函数为： /********************************************************************* @函数名WXL_SampleApp_ProcessEvent *函数功能:一般应用任务事件处理，这个函数是处理所有的事件到任务，事件包括 *时间片、消息和所有其他使用者定义过的时间。 @参数：task_id - OS 分配的任务ID.这个ID 将用于发送数据和设置时间片. *events-处理的事件 @returnnone uint16 WXL_SampleApp_ProcessEvent( uint8 task_id, uint16 events ) afIncomingMSGPacket_t *MSGpkt; if ( events &amp; SYS_EVENT_MSG )//系统信息， MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( WXL_SampleApp_TaskID );//OS 发送过来的信息 while ( MSGpkt ) switch ( MSGpkt-&gt;hdr.event ) //按键事件 case KEY_CHANGE: //按键处理函数 WXL_SampleApp_HandleKeys( ((keyChange_t *)MSGpkt)-&gt;keys ); break; //接收数据事件 case AF_INCOMING_MSG_CMD: //接收数据的处理函数 WXL_SampleApp_MessageMSGCB( MSGpkt ); break; //网络状态发生变化时间 case ZDO_STATE_CHANGE: WXL_SampleApp_NwkState = (devStates_t)(MSGpkt-&gt;hdr.status);//获取网络状态 if ( (WXL_SampleApp_NwkState == DEV_ZB_COORD)//判断网络类型 || (WXL_SampleApp_NwkState == DEV_ROUTER) || (WXL_SampleApp_NwkState == DEV_END_DEVICE) ) else //设备不属于这个网络 break; default: break; //释放存储器 osal_msg_deallocate( (uint8 *)MSGpkt ); // Next -如果有一个空闲的任务 MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( WXL_SampleApp_TaskID ); //返回未处理的任务 return (events ^ SYS_EVENT_MSG); return 0; 按键子函数的功能是处理所有的按键事件，在这里需要特别申明的是，本程序只实用与无线龙通讯科技有限公司的硬件。按键的底层驱动函数在Hal_key.c 中，我们在这里按键需要完成的任务是，当协调器按键1 被按下后，以广播的方式发送数据去让路由器小灯闪烁。 /********************************************************************* @函数名WXL_SampleApp_HandleKeys @函数功能：处理所有的按键事件 @参数：keys -返回的按键值 @returnnone void WXL_SampleApp_HandleKeys(uint8 keys ) if ( keys &amp; HAL_KEY_SW_1 ) if(WXL_SampleApp_NwkState == DEV_ZB_COORD)//如果是协调器 WXL_SampleApp_SendFlashMessage( WXL_SAMPLEAPP_FLASH_DURATION );//发送数据 else 接收处理函数的功能有两部分，一是路由器的接收函数，二是协调器的接收处理函数。在这个项目里面，我们将这两种设备的处理函数都固化在了一个函数里面，用串ID 来判断他们的设备类型。当路由器接收到数据后，先判断该信息的串ID ，然后判断命令，如果命令正确，则小灯闪烁，然后单播发送确认信号给协调器，协调器收到信号后，同样先判断串ID ，然后确认命令后小灯闪烁示意。 /********************************************************************* @函数名：SampleApp_MessageMSGCB @函数功能：接收的数据处理量.根据不同的串ID 实现不同的功能。 @paramnone @returnnone void WXL_SampleApp_MessageMSGCB( afIncomingMSGPacket_t *pkt ) unsigned char Rx_Buf[4]; switch ( pkt-&gt;clusterId ) case WXL_SAMPLEAPP_CLUSTERID1: memcpy(Rx_Buf,pkt-&gt;cmd.Data,3); if((Rx_Buf[0] == ‘Y’) &amp;&amp; (Rx_Buf[1] == ‘E’) &amp;&amp; (Rx_Buf[2] == ‘S’)) HalLedBlink( HAL_LED_4, 4, 50, 250);//小灯闪烁四次 break; case WXL_SAMPLEAPP_CLUSTERID2: memcpy(Rx_Buf,pkt-&gt;cmd.Data,4); if((Rx_Buf[0] == ‘O’) &amp;&amp; (Rx_Buf[1] == ‘P’) &amp;&amp; (Rx_Buf[2] == ‘E’) &amp;&amp; (Rx_Buf[3] == ‘N’)) HalLedBlink( HAL_LED_4, 4, 50, 250);//小灯闪烁四次 SendData(“YES”,pkt-&gt;srcAddr.addr.shortAddr,3);//以单播的方式回复信号 break; /********************************************************************* @函数名：SampleApp_SendFlashMessage @函数功能：广播发送一串数据。 @paramnone @returnnone void WXL_SampleApp_SendFlashMessage( uint8 *buffer ) if ( AF_DataRequest( &amp;WXL_SampleApp_All_DstAddr, &amp;WXL_SampleApp_epDesc, WXL_SAMPLEAPP_CLUSTERID2, buffer, &amp;WXL_SampleApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS ) else // Error occurred in request to send. //********************************************************************** //**以短地址方式发送数据 //buf ::发送的数据 //addr::目的地址 //Leng::数据长度 //******************************************************************** void WXL_SampleApp_SendData(uint8 *buf, uint16 addr, uint8 Leng) WXL_SampleApp_Single_DstAddr.addr.shortAddr = addr; if ( AF_DataRequest( &amp;WXL_SampleApp_Single_DstAddr, //发送的地址和模式 &amp;WXL_SampleApp_epDesc,//终端（比如操作系统中任务ID 等） WXL_SAMPLEAPP_CLUSTERID1,//发送串ID Leng, buf, &amp;WXL_SampleApp_TransID, AF_DISCV_ROUTE, //AF_ACK_REQUEST, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS ) else 发送数据只是掉用一个函数，在这里不多做解释。 完成任务的添加这时候回到2.2 节中将建立的任务添加在列表中。 void osalAddTasks( void ) osalTaskAdd (Hal_Init, Hal_ProcessEvent, OSAL_TASK_PRIORITY_LOW); #if defined( ZMAC_F8W ) osalTaskAdd( macTaskInit, macEventLoop, OSAL_TASK_PRIORITY_HIGH ); #endif #if defined( MT_TASK ) osalTaskAdd( MT_TaskInit, MT_ProcessEvent, OSAL_TASK_PRIORITY_LOW ); #endif osalTaskAdd( nwk_init, nwk_event_loop, OSAL_TASK_PRIORITY_MED ); osalTaskAdd( APS_Init, APS_event_loop, OSAL_TASK_PRIORITY_LOW ); osalTaskAdd( ZDApp_Init, ZDApp_event_loop, OSAL_TASK_PRIORITY_LOW ); osalTaskAdd( WXL_SampleApp_Init, WXL_SampleApp_ProcessEvent, OSAL_TASK_PRIORITY_LOW ); 其他定义const cId_t WXL_SampleApp_ClusterList[WXL_SAMPLEAPP_MAX_CLUSTERS] = WXL_SAMPLEAPP_CLUSTERID1, WXL_SAMPLEAPP_CLUSTERID2 const SimpleDescriptionFormat_t WXL_SampleApp_SimpleDesc = WXL_SAMPLEAPP_ENDPOINT,//int Endpoint; WXL_SAMPLEAPP_PROFID,//uint16 AppProfId[2]; WXL_SAMPLEAPP_DEVICEID,//uint16 AppDeviceId[2]; WXL_SAMPLEAPP_DEVICE_VERSION,//intAppDevVer:4; WXL_SAMPLEAPP_FLAGS,//intAppFlags:4; WXL_SAMPLEAPP_MAX_CLUSTERS,//uint8AppNumInClusters; (cId_t *)WXL_SampleApp_ClusterList,//uint8 *pAppInClusterList; WXL_SAMPLEAPP_MAX_CLUSTERS,//uint8AppNumInClusters; (cId_t *)WXL_SampleApp_ClusterList//uint8 *pAppInClusterList; endPointDesc_t WXL_SampleApp_epDesc; /变量申明*****/ uint8 WXL_SampleApp_TaskID;//内部的任务ID ，它的值在SampleApp_Init （）中获得 devStates_t WXL_SampleApp_NwkState;//网络状态 uint8 WXL_SampleApp_TransID;//这是唯一的一个消息ID(计数器) afAddrType_t WXL_SampleApp_All_DstAddr;//广播的方式 afAddrType_t WXL_SampleApp_Single_DstAddr;//短地址单播的方式 #define WXL_SAMPLEAPP_ENDPOINT20 #define WXL_SAMPLEAPP_PROFID0x0F08 #define WXL_SAMPLEAPP_DEVICEID0x0001 #define WXL_SAMPLEAPP_DEVICE_VERSION0 #define WXL_SAMPLEAPP_FLAGS0 #define WXL_SAMPLEAPP_MAX_CLUSTERS2 #define WXL_SAMPLEAPP_CLUSTERID11 #define WXL_SAMPLEAPP_CLUSTERID22 通过上面的介绍，可以知道协议栈的一个简单的使用流程，由于整个协议栈已经将数据通讯的代码做好，我们只需要调用里面的函数就可以了，所以就没有具体介绍网络层里面的东西。完成任务添加后，在编译下载，就可以运行协议栈了，下载后，按协调器按键1 （对应无线龙扩展板UP 键），会发送一个数据给路由器，路由器红灯闪烁，然后路由器也会发送一个数据回来，导致协调器红灯闪烁。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"单片机c语言下lcd多级菜单的一种实现方法","slug":"z_csdn_029_6098980","date":"2010-12-27T03:41:05.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2010/12/27/z_csdn_029_6098980/","link":"","permalink":"http://vball.fun/2010/12/27/z_csdn_029_6098980/","excerpt":"","text":"图形点阵式液晶可显示用户自定义的任意符号 和图形,并可卷动显示。它作为单片机系统人机交 互界面的重要组成部分被广泛应用于实时检测和显 示的仪器仪表中,例如手机上的显示屏就是图形点 阵液晶。 采用图形点阵式液晶显示较之其它显示方式主 要有以下优点: (1) 工作电压低、功耗极低。工作电压仅为3～ 5 v ,工作电流≤10 μa/ cm2 ,特别适用于低功耗的 仪器仪表中。 (2) 液晶显示属被动显示,受外界光线干扰小。 (3) 图形点阵式液晶可显示的信息量大、分辨 率高。 (4) 不产生电磁干扰。 (5) 可*性高,使用寿命长。 本文所介绍的lcd 采用128 ×64 点阵的液晶 屏,因此可显示16 ×16 点阵的汉字4 行8 列。菜单 为多级嵌套形式,最长的有13 层,主要完成对某个 测点各方面的设置或查询,可通过”向上”、”向下”、 “回退”、”确认”4 个键或遥控器来实现对菜单的选 择。具体功能: “向上”键:在本层菜单的项目中向上移动进行 选择; “向下”键:在本层菜单的项目中向下移动进行 选择; “回退”键:取消本层的菜单设置,返回上层菜 “确认”键:确认本层的菜单设置,进入下级菜 可根据用户在菜单中的选择项对测点进行某些 设置,或者进行某些特殊的显示,例如对某个测点的 实时曲线显示等。 程序设计 根据需求,首先建立一个结构,并定义一个结构 变量kbdtabst ruct 。结构变量就是把多个不同类 型的变量结合在一起形成的一个组合型变量,构成 一个结构的各个变量称为结构元素。该结构中共有 6 个结构元素,分别是5 个字符型和1 个指针变量, 5 个字符型变量分别为当前及各个按键的索引号, 也就是*作的状态号,最后1 个指针变量指向需执 行函数。这样就可以做一个结构数组,在结构数组 里为每一个菜单项编制一个单独的函数,并根据菜 单的嵌套顺序排好本菜单项的索引号,以及本级菜 单项的上、下卷动的索引号和上、下级菜单的索引号。 具体程序如下所述: typedef st ruct uchar keystateindex ; / / 当前状态索引号 uchar keydnstate ; / / 按下”向下”键时转向的状态索引号 uchar keyupstate ; / / 按下”向上”键时转向的状态索引号 uchar keycrstate ; / / 按下”回车”键时转向的状态索引号 uchar keybackstate ; / / 按下”退回”键时转向的状态索引号 void ( 3 currentoperate) ( ) ; / / 当前状态应该执行的 功能*作 } kbdtabst ruct ; define size - of keybd - menu 55 / / 菜单总长度kbdtabst ruct code keytab[ size - of - keybd - menu ] = {0 ,0 ,0 ,1 ,0 , ( 3 mainjob1) } , {1 ,7 ,2 ,8 ,0 , ( 3 dsp point) } , / / 第一层 {2 ,1 ,3 ,8 ,0 , ( 3 dspcurve) ) , / / 第一层 {3 ,2 ,4 ,36 ,0 , ( 3 dsp kout) } , / / 第一层 {4 ,3 ,5 ,50 ,0 , ( 3 disclosedown) } , / / 第一层 程序设计 根据需求,首先建立一个结构,并定义一个结构 变量kbdtabst ruct 。结构变量就是把多个不同类 型的变量结合在一起形成的一个组合型变量,构成 一个结构的各个变量称为结构元素。该结构中共有 6 个结构元素,分别是5 个字符型和1 个指针变量, 5 个字符型变量分别为当前及各个按键的索引号, 也就是*作的状态号,最后1 个指针变量指向需执 行函数。这样就可以做一个结构数组,在结构数组 里为每一个菜单项编制一个单独的函数,并根据菜 单的嵌套顺序排好本菜单项的索引号,以及本级菜 单项的上、下卷动的索引号和上、下级菜单的索引号。 具体程序如下所述: typedef st ruct uchar keystateindex ; / / 当前状态索引号 uchar keydnstate ; / / 按下”向下”键时转向的状态索引号 uchar keyupstate ; / / 按下”向上”键时转向的状态索引号 uchar keycrstate ; / / 按下”回车”键时转向的状态索引号 uchar keybackstate ; / / 按下”退回”键时转向的状态索引号 void ( 3 currentoperate) ( ) ; / / 当前状态应该执行的 功能*作 } kbdtabst ruct ; define size - of keybd - menu 55 / / 菜单总长度kbdtabst ruct code keytab[ size - of - keybd - menu ] = {0 ,0 ,0 ,1 ,0 , ( 3 mainjob1) } , {1 ,7 ,2 ,8 ,0 , ( 3 dsp point) } , / / 第一层 {2 ,1 ,3 ,8 ,0 , ( 3 dspcurve) ) , / / 第一层 {3 ,2 ,4 ,36 ,0 , ( 3 dsp kout) } , / / 第一层 {4 ,3 ,5 ,50 ,0 , ( 3 disclosedown) } , / / 第一层 下面是一个具体的例子： unsigned char tempin,tempout,temprun; unsigned char Key_Value(); unsigned char Change_Value(unsigned char); void Delay_1(unsigned int m); void Run_Satus(); char * MainMenuTitle = “主菜单”; const char * MainMenuItems[] = { “1.室内温度调整”, “2.室外温度调整”, “3.运行时间调整”, “4.ESC退出”, TMenu MainMenu; void OnSelectMainMenu(int index) if (index &lt; 0 || index &gt;= sizeof(MainMenuItems) / sizeof(char *)) return; ClearScreen(); switch (index) { case 0: TextOut(0, 1, “室内调整开始 “); tempin=Change_Value(tempin); TextOut(0, 1, “室内调整完毕”); Delay_1(300000); break; case 1: TextOut(0, 1, “室外调整开始 “); tempout=Change_Value(tempout); TextOut(0, 1, “室外调整完毕”); Delay_1(300000); break; case 2: TextOut(0, 1, “运行时间调整开始”); tempout=Change_Value(temprun); TextOut(0, 1, “运行时间完毕”); Delay_1(300000); break; case 3: break; ClearScreen(); UINT OnMainMenuOk(void * arg) TMenu * pMenu = (TMenu *)arg; if (pMenu) OnSelectMainMenu(pMenu-&gt;Current); return 0; UINT OnMainMenuCancel(void * arg) TMenu * pMenu = (TMenu *)arg; if (pMenu) { CloseMenu(pMenu); return 0; UINT OnMainMenuOtherKey(void * arg) TMenu * pMenu = (TMenu *)arg; char key; if (pMenu) { key = pMenu-&gt;EventArg; OnSelectMainMenu(key - ‘1’); DrawMenu(pMenu); return 0; void InitMenu() InitializeMenu(&amp;MainMenu, MainMenuTitle, MainMenuItems, sizeof (MainMenuItems) / sizeof(char *)); MainMenu.OnOk = OnMainMenuOk; MainMenu.OnOtherKey = OnMainMenuOtherKey; MainMenu.OnCancel = OnMainMenuCancel; unsigned char Key_Value() unsigned char KeyTemp; KeyTemp=GetKey(); switch(KeyTemp) case(VK_ESCAPE): return(0); break; case(VK_ENTER): return(1); break; case(VK_UP): return(2); break; case(VK_DOWN): return(3); break; unsigned char Change_Value(unsigned char temp2) unsigned char temp3; temp3=temp2; while((Key_Value()!=0)&amp;&amp;(Key_Value()!=1)) if(Key_Value()==2)temp3++; else if(Key_Value()==3)temp3–; ClearLine(1); TextOut(0, 1, “调整状态%d”, temp3); if(Key_Value()==1)return(temp3); else if(Key_Value()==0) return(temp2); void Delay_1(unsigned int m) while(m–); void Run_Satus() ClearScreen(); TextOut(0, 0, “室内温度%d”,tempin); TextOut(0, 1, “室外温度%d”,tempout); TextOut(0, 2, “运行时间%d”,temprun); TextOut(0, 3, “ENTER 进入调整”); void tmain() tempin=30; tempout=30; temprun=30; unsigned char key; InitMenu(); while(1) Run_Satus(); key=GetKey(); if(key==VK_ENTER)ShowMenu(&amp;MainMenu);","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"一个按键液晶多级菜单设计方法","slug":"z_csdn_047_6098974","date":"2010-12-26T10:38:01.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2010/12/26/z_csdn_047_6098974/","link":"","permalink":"http://vball.fun/2010/12/26/z_csdn_047_6098974/","excerpt":"","text":"typedef struct{uchar KeyStateIndex ; / / 当前状态索引号uchar KeyDnState ; / / 按下”向下”键时转向的状态索引号uchar KeyUpState ; / / 按下”向上”键时转向的状态索引号uchar KeyCrState ; / / 按下”回车”键时转向的状态索引号uchar KeyBackState ; / / 按下”退回”键时转向的状态索引号void (*CurrentOperate)( ) ; / / 当前状态应该执行的功能操作} KbdTabSt ruct ; define SIZE - OF KEYBD - MENU 55 / / 菜单总长度KbdTabSt ruct code KeyTab[ SIZE - OF - KEYBD - MENU ] ={{0 ,0 ,0 ,1 ,0 , MainJob1 } ,{1 ,7 ,2 ,8 ,0 , Dsp Point} , / / 第一层{2 ,1 ,3 ,8 ,0 , DspCurve}, / / 第一层{3 ,2 ,4 ,36 ,0 ,Dsp Kout} , / / 第一层{4 ,3 ,5 ,50 ,0 , DisCloseDown } , / / 第一层 {5 ,4 ,6 ,8 ,0 , ModifyPoint} , / / 第一层{6 ,5 ,7 ,52 ,0 , SetCloseDown } , / / 第一层{7 ,6 ,1 ,0 ,0 , Cancel} , / / 第一层… … {52 ,53 ,53 ,0 ,1 , OkSetCloseDown1} ,{53 ,52 ,52 ,0 ,1 , OkSetCloseDown2} ,{54 ,0 ,0 ,0 ,0 , Disable} ,… … } ;void Get Keylnput (void){switch ( status &amp;0xf0){case 0xe0 :/ / 回车键,找出新的菜单状态编号… KeyFuncIndex = KeyTab[ KeyFuncIndex ] . KeyCrState ;… break ;case 0xb0 :/ / 向下键,找出新的菜单状态编号… KeyFuncIndex = KeyTab [ KeyFuncIndex ] . KeyDn2State ;… break ;case 0xd0 :/ / 向上键,找出新的菜单状态编号 … KeyFuncIndex = KeyTab [ KeyFuncIndex ] . KeyUp2State ;… break ;case 0x70 :/ / 回退键,找出新的菜单状态编号… KeyFuncIndex = KeyTab [ KeyFuncIndex ] . KeyBack2State ;… break ;case 0 ;return ; / / 错误的处理break ;}KeyFuncPt r = KeyTab[ KeyFuncIndex ] . CurrentOperate ;( * KeyFuncPt r) () ; / / 执行当前按键的操作}","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"C语言编程开发中用好位操作符","slug":"z_csdn_013_6074579","date":"2010-12-14T07:11:10.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2010/12/14/z_csdn_013_6074579/","link":"","permalink":"http://vball.fun/2010/12/14/z_csdn_013_6074579/","excerpt":"","text":"1. C 语言中的位操作符 因为C语言的设计目的是取代汇编语言，所以它必须支持汇编语言所具有的运算能力，所以C语言支持全部的位操作符(Bitwise Operators)。位操作是对字节或字中的位(bit)进行测试、置位或移位处理，在对微处理器的编程中，特别适合对寄存器、I/O端口进行操作。因而本节将对此作比较详细地介绍。 6种位操作符的形式与含义如下： &amp; ：按位”与”(AND)；| ：按位”或”(OR)；^ ：按位”异或”(XOR)；~ ：”取反” (NOT)； ：数据右移；&lt;&lt; ：数据左移； 1) 按位”与”运算 按位”与”运算符 &amp; 的作用是对运算符两侧以二进制表达的操作数按位分别进行”与”运算，而这一运算是以数中相同的位(bit)为单位的。操作的规则是：仅当两个操作数都为1时，输出的结果才为1，否则为0。 例如： 其中，&amp; 运算符让a数0x88与B数0x81的1位与1位、2位与2位……7位与7位分别相”与”。由于”与”运算的操作规则是，两个操作数中各位只要有1个为0，其结果中对应的位就为0。而a数与b数中只有最高位(第7位)均为1，因而该位结果为1，其它各位结果都为0。 通常我们可把按位”与”操作 &amp; 作为关闭某位(即将该位置0)的手段，例如我们想要关闭a数中的第3位，而又不影响其它位的现状，可以用一个数0xF7，即二进制数1111 0111去与a数作按位”与”运算： 0x88 1000 1000 a数&amp; 0xF7 1111 0111 屏蔽数= 1000 0000 注意，这个数除第3位为0外，其它各位均为1，操作的结果只会将a数中的第3位置0，而a数的其它位不受影响。也就是说，若需要某个数的第n位关闭，只需要将该数与另一个数按位相与，另一个数除了相应的第n位为0外，其它各位都为1，以起到对其它各位的屏蔽作用。 上面的运算可以用a = a &amp;(0xF7) 来表示，也可以用a &amp; =(0xF7) 来表达。这两个表达式功能是相同的(见上节”复合赋值运算符”部分)，但在源程序代码中常常见到的以第二种形式为多。 2) 按位”或”运算 按位”或” 运算符 | 的作用是对运算符两侧以二进制表达的操作数按位分别进行”或”运算，而这一运算是以数中相同的位(bit)为单位的。操作的规则是：仅当两个操作数都为0时，输出的结果才为0，否则为1。 例如： 通常我们可把按位”与”操作 &amp; 作为置位(即将该位置1)的手段，例如我们想要将a数中的第0位和1位置1，而又不影响其它位的现状，可以用一个数0x03，即二进制数00000011去与a数作按位”或”运算： 0x88 1000 1000 a数| 0x03 0000 0011 屏蔽数= 1000 1011 注意，这个数除第0、1位为1外，其它各位均为0，操作的结果只会将a数中的第0、1位置0，而a数的其它位不受影响。也就是说，若需要某个数的第n位置1，只需要将该数与另一个数按位相”或”，另一个数除了相应的第n位为1外，其它各位都为0，以起到对其它各位的屏蔽作用。上面的运算可以用a = a | (0xF7) 来表示，也可以用a | =(0xF7) 来表达。 3) 按位”异或”运算 按位”异或”运算符 ^ 的作用是对运算符两侧以二进制表达的操作数按位分别进行”异或”运算，而这一运算是以数中相同的位(bit)为单位的。异或运算操作的规则是：仅当两个操作数不同时，相应的输出结果才为1，否则为0。 例如： a = 0x88，b = 0x81，则a ^ b 的运算结果如下：0x88 1000 1000 a数^ 0x81 1000 0001 屏蔽数= 0000 1001 按位”异或”运算 ^ 具有一些特殊的应用，介绍如下： ① 按位”异或”运算可以使特定的位取反 例如：我们想让a数中的最低位和最高位取反，只要用0x81，即二进制数10000001去与它作按位”异或”运算，其运算结果同上式。经过操作后，最高位的值已经由1变0，而最低位的值也已经由0变1，起到了使这两位翻转的效果。其它位的状态保持不变。 可以看到，这个数除最低位、最高位为1外，其它各位均为0，操作的结果只会将a数中的第0、7位取反，而a数的其它位不受影响。也就是说，若需要某个数的第n位取反，只需要将该数与另一个数按位相”异或”，另一个数除了相应的第n位为1外，其它各位都为0，以起到对其它各位的屏蔽作用。上面的运算可以用a = a ^ (0x81) 来表示，也可以用a ^ =(0x81) 来表达。 ② 直接交换两个变量的值 例如，若有变量a = 3，b = 4，想要交换它们的值，可以做如下一组操作： a ^ = bb ^ = aa ^ = b首先，a ^ = b:a 0000 0011^ b 0000 0100a = 0000 0111其次，b ^ = a:b 0000 0100^ a 0000 0111b = 0000 0011最后，a ^ = b:a 0000 0111^ b 0000 0011a = 0000 0100 这样，a、b两个变量中的值就进行了对调。 4) “取反”运算 “取反”运算符 ~ 的作用是将各位数字取反：所有的0置为1，1置为0。例如： 1001 0110 取反后为0110 1001。 5) 数据右移 数据右移操作符 &gt;&gt; 将变量的各位按要求向右移动若干位。右移语句的通常形式是： variable &gt;&gt;右移位数 如：a = 1111 0000；进行 a = a &gt;&gt; 2 操作后，a = 0011 1100。 6) 数据左移 数据左移操作符 &lt;&lt; 将变量的各位按要求向左移动若干位。左移语句的通常形式是： variable &lt;&lt; 左移位数 如：a = 1111 0000；进行 a = a &lt;&lt; 2 操作后，a =1100 0000。 无论是左移还是右移，当某位从一端移出时，另一端出现的空白将以从外面移入的0（某些计算机是送1，详细内容请查阅相应C编译程序用户手册）来补充。这说明，移位不同于循环，从一端移出的位并不送回到另一端去，移去的位永远丢失了，同时在另一端只能补上相应位数的0。 移位操作可用于整数的快速乘除运算，左移一位等效于乘2，而右移一位等效于除以2。 如：x = 7， 二进制表达为：0000 0111， x &lt;&lt; 1 0000 1110，相当于： x =27=14，x &lt;&lt; 3 0111 0000，相当于： x=14222=112x &lt;&lt; 2 1100 0000， x= 192 在作第三次左移时，其中一位为1的位移到外面去了，而左边只能以0补齐，因而便不等于11222=448，而是等于192了。当x按刚才的步骤反向移动回去时，就不能返回到原来的值了，因为左边丢掉的一个1，再也不能找回来了： x &gt;&gt; 2 0011 0000， x=48x &gt;&gt; 3 0000 0110 x=48/8=6x &gt;&gt; 1 0000 0011 x=6/2=3 移位操作还可以配合其它位操作夫对寄存器或者数据I/O接口的各个位进行设置、检测，具体方法见下一节。 2. 位操作符的一些实用方法介绍 1) 学会应用复合运算符 如前面所介绍的，位操作运算符可以和赋值运算符”=”一起组成复合运算符。即如下5个： &lt; 其中，x &lt;&lt; = y，相当于x = x &lt;&lt; y； x &gt;&gt; = y，相当于x = x &gt;&gt; y；x &amp; = y， 相当于x = x &amp; y；x ^ = y， 相当于x = x ^ y；x | = y， 相当于x = x | y； 学会在C语言中使用复合运算符，可以简化源程序，优化目标程序。 2) C 语言中一些常见的位操作方法 由于我们此处学习C 语言的目的主要是为了开发微控制器的控制程序，为此我们特别关注一下对MPU的寄存器、I/O中某一位的操作语句。假如要对PORTA(端口A)的某些位进行赋值、置0、置1、取反、测试，可能会用到如一下一些语句： ① PORTA = 0x87 给整个PORTA赋值，作用是将1000 0111这个数赋予PORTA，即让PORTA的第0、1、2和7位置1，其它位清0。 ② PORTA = (1&lt;","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"QPainter begin Paint device returned engine","slug":"z_csdn_026_6069869","date":"2010-12-11T11:09:01.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2010/12/11/z_csdn_026_6069869/","link":"","permalink":"http://vball.fun/2010/12/11/z_csdn_026_6069869/","excerpt":"","text":"QPainter::begin: Paint device returned engine == 0, type: 1QPainter默认只能在paintEvent里面调用,但是: 在其他事件中绘制窗体，提示信息如下： 1QPainter::begin: Paint device returned engine == 0, type: 1 绘制操作应该在paintEvent中完成. 有一个属性值，在构造函数中设置可以在paintEvent()之外进行绘制： 1this-&gt;setAttribute(Qt::WA_PaintOutsidePaintEvent); 但是只支持X11，对于 Windows, Mac OS X or Embedded Linux。。。。不予支持 1234567void xx::paintEvent(QPaintEvent *p)painter.begin(this);painter.drawImage(image);painter.end();","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}]},{"title":"STM32 定时器用于外部脉冲计数，修改版，解决3..4库对应的无响应外部脉冲的问题","slug":"z_csdn_027_7779582","date":"2010-08-14T00:00:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2010/08/14/z_csdn_027_7779582/","link":"","permalink":"http://vball.fun/2010/08/14/z_csdn_027_7779582/","excerpt":"","text":"因为用stm32f103c8作主控制器,来控制小车,小车的转速由两路光电编码盘输入(左右各一路).因此想到外部时钟触发模式（TIM——ETRClockMode2Config)。 可以试好好久，发现TIM1不能计数，到网上查了很久，也没有找到相关的文章，开始怀疑TIM1是不是需要特殊设置。经过很久的纠结，终于找到了问题——其实是我自己在GPIO设置的时候，后面的不小心覆盖了前面的了——没想到自己也会犯这么SB的事情。 现总结程序如下： 第一步，设置GPIO GPIO_InitTypeDef GPIO_InitStructure; /* PA0,PA12-&gt; 左右脉冲输入 */GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_12;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //50M时钟速度GPIO_Init(GPIOA, &amp;GPIO_InitStructure); 注意：（1）stm32f103c8只有TIM1_ETR(PA12,Pin33)，和TIM2_CH1_ETR(PA0,Pin10)两个可以用。其它更多管脚的芯片，有更多的可以输入（如100管脚的有4个可以输入的）；（2）外部时钟输入与中断无关；（3）stm32f103c8的这个两个应用中，不需要重映射。 对于哪些需要重映射，参考数据手册。 第二步：设置RCC RCC_ClocksTypeDef RCC_ClockFreq; SystemInit();//源自system_stm32f10x.c文件,只需要调用此函数,则可完成RCC的配置. RCC_GetClocksFreq(&amp;RCC_ClockFreq); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); 第三步，设置定时器模式 void TIM1_Configuration(void) //只用一个外部脉冲端口{TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; //配置TIMER1作为计数器TIM_DeInit(TIM1); TIM_TimeBaseStructure.TIM_Period = 0xFFFF;TIM_TimeBaseStructure.TIM_Prescaler = 0x00;//设置预分频可以将外部信号分频TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure); // Time base configuration TIM_ITRxExternalClockConfig(TIM2,TIM_TS_ETRF); //我测试中一直不能用的原因是缺少这句话，缺少后，timer的驱动时钟源默认是RCC，需要更改为外部ETR输入才行。TIM_ETRClockMode2Config(TIM1, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, 0); TIM_SetCounter(TIM1, 0);TIM_Cmd(TIM1, ENABLE);} void TIM2_Configuration(void) //只用一个外部脉冲端口{TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; //配置TIMER2作为计数器TIM_DeInit(TIM2); TIM_TimeBaseStructure.TIM_Period = 0xFFFF;TIM_TimeBaseStructure.TIM_Prescaler = 0x00;TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure); // Time base configuration TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, 0); TIM_SetCounter(TIM2, 0);TIM_Cmd(TIM2, ENABLE);} 第四步，可以在主函数中读取计数器的值，其它的应用，就看具体的情况了。 u16 COUN1=0;u16 COUN2=0; int main(void){ChipHalInit();ChipOutHalInit(); while(1){COUN1=TIM1-&gt;CNT;COUN2=TIM2-&gt;CNT;} 然后就可以用了 当然你可以使能中断，TIM_ARRPreloadConfig(TIM2, ENABLE);/预先清除所有中断位/TIM_ClearITPendingBit(TIM2,TIM_IT_Update);/* 4个通道和溢出都配置中断*/TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); 并且在终端中重装填计数器数据，既可以在计数若干后产生一次中断 void TIM2_IRQHandler(void){ if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET){TIM_ClearITPendingBit(TIM2, TIM_IT_Update);//TIM_Cmd(TIM2, DISABLE);TIM2-&gt;CNT=65530;}} 仁者见仁吧，以后有机会再深入研究。。不得不说，用了stm32 的api库后，很多寄存器都懒得看了。。。。悲剧啊","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"Linux┊详解udev","slug":"z_csdn_033_6948265","date":"2009-06-03T08:00:00.000Z","updated":"2021-12-10T06:23:57.232Z","comments":true,"path":"2009/06/03/z_csdn_033_6948265/","link":"","permalink":"http://vball.fun/2009/06/03/z_csdn_033_6948265/","excerpt":"","text":"如果你使用Linux比较长时间了，那你就知道，在对待设备文件这块，Linux改变了几次策略。在Linux早期，设备文件仅仅是是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs, 一个基于内核的动态设备文件系统，他首次出现在2.3.46内核中。Mandrake，Gentoo等Linux分发版本采用了这种方式。devfs创建 的设备文件是动态的。但是devfs有一些严重的限制，从2.6.13版本后移走了。目前取代他的便是文本要提到的udev－－一个用户空间程序。 目前很多的Linux分发版本采纳了udev的方式，因为它在Linux设备访问，特别是那些对设备有极端需求的站点(比如需要控制上千个硬盘)和热插拔设备(比如USB摄像头和MP3播放器)上解决了几个问题。下面我我们来看看如何管理udev设备。 实际上，对于那些为磁盘，终端设备等准备的标准配置文件而言，你不需要修改什么。但是，你需要了解udev配置来使用新的或者外来设备，如果不修改配置， 这些设备可能无法访问，或者说Linux可能会采用不恰当的名字，属组或权限来创建这些设备文件。你可能也想知道如何修改RS－232串口，音频设备等文件的属组或者权限。这点在实际的Linux实施中是会遇到的。 为什么使用udev 在此之前的设备文件管理方法(静态文件和devfs)有几个缺点： *不确定的设备映射。特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称 为/dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为 他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一 设备文件来映射。但是静态文件和devfs都无法做到这点。 *没有足够的主/辅设备号。我们知道，每一个设备文件是有两个8位的数字：一个是主设备号 ，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型(块设备或者字符设备)来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。 */dev目录下文件太多。一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。 *命名不够灵活。尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。 *内核内存使用，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时(比如上面我们提到的系统一个上有好几千磁盘时) udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你之大如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。 udev配置文件 主要的udev配置文件是/etc/udev/udev.conf。这个文件通常很短，他可能只是包含几行#开头的注释，然后有几行选项： udev_root = “/dev/ **”**udev_rules = “/etc/udev/rules.d/ **”**udev_log = **”**err “ 上面的第二行非常重要，因为他表示udev规则存储的目录，这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。你的/etc/udev/rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包 生成的。比如在Fedora Core 5系统上，sane-backends包就会安装60-libsane.rules文件，另外initscripts包会安装60-net.rules文 件。这些规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。 规则文件里的规则有一系列的键/值对组成，键/值对之间用逗号(,)分割。每一个键或者是用户匹配键，或者是一个赋值键。匹配键确定规则是否被应用，而赋 值键表示分配某值给该键。这些值将影响udev创建的设备文件。赋值键可以处理一个多值列表。匹配键和赋值键操作符解释见下表： udev 键/值对操作符 操作符 匹配或赋值 解释－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－== 匹配 相等比较!= 匹配 不等比较= 赋值 分配一个特定的值给该键，他可以覆盖之前的赋值。+= 赋值 追加特定的值给已经存在的键:= 赋值 分配一个特定的值给该键，后面的规则不可能覆盖它。 这有点类似我们常见的编程语言，比如C语言。只是这里的键一次可以处理多个值。有一些键在udev规则文件里经常出现，这些键的值可以使用通配符(*,?,甚至范围，比如[0-9])，这些常用键列举如下： 常用udev键键 含义ACTION 一个时间活动的名字，比如add，当设备增加的时候KERNEL 在内核里看到的设备名字，比如sd表示任意SCSI磁盘设备DEVPATH 内核设备录进，比如/devices/SUBSYSTEM 子系统名字，比如sound,netBUS 总线的名字，比如IDE,USBDRIVER 设备驱动的名字，比如ide-cdromID 独立于内核名字的设备名字SYSFS{ value} sysfs属性值，他可以表示任意ENV{ key} 环境变量，可以表示任意PROGRAM 可执行的外部程序，如果程序返回0值，该键则认为为真(true)RESULT 上一个PROGRAM调用返回的标准输出。NAME 根据这个规则创建的设备文件的文件名。注意：仅仅第一行的NAME描述是有效的，后面的均忽略。 如果你想使用使用两个以上的名字来访问一个设备的话，可以考虑SYMLINK键。SYMLINK 根据规则创建的字符连接名OWNER 设备文件的属组GROUP 设备文件所在的组。MODE 设备文件的权限，采用8进制RUN 为设备而执行的程序列表LABEL 在配置文件里为内部控制而采用的名字标签(下下面的GOTO服务)GOTO 跳到匹配的规则（通过LABEL来标识），有点类似程序语言中的GOTOIMPORT{ type} 导入一个文件或者一个程序执行后而生成的规则集到当前文件WAIT_FOR_SYSFS 等待一个特定的设备文件的创建。主要是用作时序和依赖问题。PTIONS 特定的选项： last_rule 对这类设备终端规则执行； ignore_device 忽略当前规则； ignore_remove 忽略接下来的并移走请求。all_partitions 为所有的磁盘分区创建设备文件。 我们给出一个列子来解释如何使用这些键。下面的例子来自Fedora Core 5系统的标准配置文件。 上面的例子给出了5个规则，每一个都是KERNEL或者ACTION键开头： *第一个规则是缺省的，他匹配任意被内核识别到的设备，然后设定这些设备的属组是root，组是root，访问权限模式是0600(-rw——-)。这也是一个安全的缺省设置保证所有的设备在默认情况下只有root可以读写 *第二个规则也是比较典型的规则了。它匹配终端设备(tty)，然后设置新的权限为0600，所在的组是tty。它也设置了一个特别的设备文件名:%K。在这里例子里，%k代表设备的内核名字。那也就意味着内核识别出这些设备是什么名字，就创建什么样的设备文件名。 第三行开始的KERNEL==”scd[0-9]“,表示 SCSI CD-ROM 驱动. 它创建一对设备符号连接：cdrom和cdrom-%k。 *第四行，开始的 KERNEL==”hd[a-z]”, 表示ATA CDROM驱动器。这个规则创建和上面的规则相同的符号连接。ATA CDROM驱动器需要sysfs值以来区别别的ATA设备，因为SCSI CDROM可以被内核唯一识别。. *第五行以 ACTION==”add”开始，它告诉udev增加 /sbin/modprobe sg 到命令列表，当任意SCSI设备增加到系统后，这些命令将执行。其效果就是计算机应该会增加sg内核模块来侦测新的SCSI设备。 当然，上面仅仅是一小部分例子，如果你的系统采用了udev方式，那你应该可以看到更多的规则。如果你想修改设备的权限或者创建信的符号连接，那么你需要熟读这些规则，特别是要仔细注意你修改的那些与之相关的设备。 修改你的udev配置 在修改udev配置之前，我们一定要仔细，通常的考虑是：你最好不要修改系统预置的那些规则，特别不要指定影响非常广泛的配置，比如上面例子中的第一行。不正确的配置可能会导致严重的系统问题或者系统根本就无法这个正确的访问设备。 而我们正确的做法应该是在/etc/udev/rules.d/下创建一个信的规则文件。确定你给出的文件的后缀是rules文件名给出的数字序列应该比 标准配置文件高。比如，你可以创建一个名为99-my-udev.rules的规则文件。在你的规则文件中，你可以指定任何你想修改的配置，比如，假设你 修改修改floppy设备的所在组，还准备创建一个信的符号连接/dev/floppy，那你可以这么写： KERNEL= **=”*fd[0-9] “, GROUP= **”**users “, SYMLINK+= **”**floppy “ 有些发行版本，比如Fedora，采用了外部脚本来修改某些特定设备的属组，组关系和权限。因此上面的改动可能并不见得生效。如果你遇到了这个问题，你就需要跟踪和修改这个脚本来达到你的目的。或者你可以修改PROGRAM或RUN键的值来做到这点。 某些规则的修改可能需要更深的挖掘。比如，你可能想在一个设备上使用sysfs信息来唯一标识一个设备。这些信息最好通过udevinfo命令来获取。 上面的命令两次使用udevinfo：一次是返回sysfs设备路径(他通常和我们看到的Linux设备文件名所在路径－－/dev/hda－－不同)；第 二次才是查询这个设备路径，结果将是非常常的syfs信息汇总。你可以找到最够的信息来唯一标志你的设备，你可以采用适当的替换udev配置文件中的 SYSFS选项。下面的结果就是上面的命令输出 Pages: 1","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"},{"title":"undefined reference to `libiconv(已解决)","slug":"z_csdn_063_6900328","date":"2009-05-04T20:00:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2009/05/04/z_csdn_063_6900328/","link":"","permalink":"http://vball.fun/2009/05/04/z_csdn_063_6900328/","excerpt":"","text":"undefined reference to `libiconv(已解决) 2009年05月05日 星期二 14:21 安装sphinx时又报错，真是疯了啊。 在make时报错，错误内容：r/local/src/sphinx/sphinx-0.9.8-rc2/src/tokenizer_zhcn.cpp:280: undefined reference to `libiconv’libsphinx.a(tokenizer_zhcn.o)(.text+0x6fd):/usr/local/src/sphinx/sphinx-0.9.8-rc2/src/tokenizer_zhcn.cpp:55: undefined reference to `libiconv_open’libsphinx.a(tokenizer_zhcn.o)(.text+0x719):/usr/local/src/sphinx/sphinx-0.9.8-rc2/src/tokenizer_zhcn.cpp:58: undefined reference to libiconv&#39; libsphinx.a(tokenizer_zhcn.o)(.text+0x7a4): In function CSphTokenizer_zh_CN_UTF8::CSphTokenizer_zh_CN_UTF8()’:/usr/local/src/sphinx/sphinx-0.9.8-rc2/src/tokenizer_zhcn.cpp:34: undefined reference to libiconv_close&#39; libsphinx.a(tokenizer_zhcn.o)(.text+0xd04): In function CSphTokenizer_zh_CN_UTF8::CSphTokenizer_zh_CN_UTF8()’:/usr/local/src/sphinx/sphinx-0.9.8-rc2/src/tokenizer_zhcn.cpp:34: undefined reference to libiconv_close&#39; libsphinx.a(tokenizer_zhcn.o)(.text+0x125c): In function CSphTokenizer_zh_CN_UTF8::~CSphTokenizer_zh_CN_UTF8()’:/usr/local/src/sphinx/sphinx-0.9.8-rc2/src/tokenizer_zhcn.cpp:34: undefined reference to `libiconv_close’ 解决一开始以为libiconv的问题，又重装了几次还是一样，最后终于找着办法了编辑：./src/MakeFile文件将LIBS = -lm -lexpat -L/usr/local/lib改成LIBS = -lm -lexpat -liconv -L/usr/local/lib ok了 还是不行啊 gcc -O2 -fno-strict-aliasing -pipe -L /usr/obj/usr/src/sys/GOD/modules/usr/src/sys/modules/libiconv/ -liconv ~/test/iconv/main.c -o ~/test/iconv/code/home/soj/test/iconv/main.c: In function main&#39;: /home/soj/test/iconv/main.c:49: warning: passing arg 2 of libiconv’ from incompatible pointer type/usr/bin/ld: cannot find -liconv dangk 发表于 2006-12-19 15:50 回复 3楼 balabalacha 的帖子-I/usr/local/include -L/usr/local/lib/ -liconv balabalacha 发表于 2006-12-19 20:42","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"Dangk 发表于 2006-12-19 15:50"},{"title":"linux下获取时间的若干函数(z)","slug":"z_csdn_067_6928987","date":"2008-04-28T22:13:00.000Z","updated":"2021-12-10T06:23:57.236Z","comments":true,"path":"2008/04/28/z_csdn_067_6928987/","link":"","permalink":"http://vball.fun/2008/04/28/z_csdn_067_6928987/","excerpt":"","text":"asctime（将时间和日期以字符串格式表示） 相关函数 time，ctime，gmtime，localtime 表头文件 #include 定义函数 char * asctime(const struct tm * timeptr); 函数说明 asctime()将参数timeptr所指的tm结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串形态返回。此函数已经由时区转换成当地时间，字符串格式为:”Wed Jun 30 21:49:08 1993\\n” 返回值 若再调用相关的时间日期函数，此字符串可能会被破坏。此函数与ctime不同处在于传入的参数是不同的结构。 附加说明 返回一字符串表示目前当地的时间日期。 #include Sat Oct 28 02:10:06 2000 ctime（将时间和日期以字符串格式表示） 相关函数 time，asctime，gmtime，localtime 表头文件 #include 定义函数 char *ctime(const time_t *timep); 函数说明 ctime()将参数timep所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串形态返回。此函数已经由时区转换成当地时间，字符串格式为”Wed Jun 30 21 :49 :08 1993\\n”。若再调用相关的时间日期函数，此字符串可能会被破坏。 返回值 返回一字符串表示目前当地的时间日期。 #include Sat Oct 28 10 : 12 : 05 2000 gettimeofday（取得目前的时间） 相关函数 time，ctime，ftime，settimeofday 表头文件 #include 定义函数 int gettimeofday ( struct timeval * tv , struct timezone * tz ) 函数说明 gettimeofday()会把目前的时间有tv所指的结构返回，当地时区的信息则放到tz所指的结构中。timeval结构定义为:struct timeval{long tv_sec; /秒/long tv_usec; /微秒/};timezone 结构定义为:struct timezone{int tz_minuteswest; /和Greenwich 时间差了多少分钟/int tz_dsttime; /日光节约时间的状态/};上述两个结构都定义在/usr/include/sys/time.h。tz_dsttime 所代表的状态如下DST_NONE /不使用/DST_USA /美国/DST_AUST /澳洲/DST_WET /西欧/DST_MET /中欧/DST_EET /东欧/DST_CAN /加拿大/DST_GB /大不列颠/DST_RUM /罗马尼亚/DST_TUR /土耳其/DST_AUSTALT /澳洲（1986年以后）/ 返回值 成功则返回0，失败返回－1，错误代码存于errno。附加说明EFAULT指针tv和tz所指的内存空间超出存取权限。 #include tv_sec: 974857339tv_usec:136996tz_minuteswest:-540tz_dsttime:0 gmtime（取得目前时间和日期） 相关函数 time,asctime,ctime,localtime 表头文件 #include 定义函数 struct tmgmtime(const time_ttimep); 函数说明 gmtime()将参数timep 所指的time_t 结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果由结构tm返回。结构tm的定义为struct tm{int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int tm_year;int tm_wday;int tm_yday;int tm_isdst;};int tm_sec 代表目前秒数，正常范围为0-59，但允许至61秒int tm_min 代表目前分数，范围0-59int tm_hour 从午夜算起的时数，范围为0-23int tm_mday 目前月份的日数，范围01-31int tm_mon 代表目前月份，从一月算起，范围从0-11int tm_year 从1900 年算起至今的年数int tm_wday 一星期的日数，从星期一算起，范围为0-6int tm_yday 从今年1月1日算起至今的天数，范围为0-365int tm_isdst 日光节约时间的旗标此函数返回的时间日期未经时区转换，而是UTC时间。 返回值 返回结构tm代表目前UTC 时间 #include 2000/10/28 Sat 8:15:38 localtime（取得当地目前时间和日期） 相关函数 time, asctime, ctime, gmtime 表头文件 #include 定义函数 struct tm *localtime(const time_t * timep); 函数说明 localtime()将参数timep所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果由结构tm返回。结构tm的定义请参考gmtime()。此函数返回的时间日期已经转换成当地时区。 返回值 返回结构tm代表目前的当地时间。 #include 2000/10/28 Sat 11:12:22 mktime（将时间结构数据转换成经过的秒数） 相关函数 time，asctime，gmtime，localtime 表头文件 #include 定义函数 time_t mktime(strcut tm * timeptr); 函数说明 mktime()用来将参数timeptr所指的tm结构数据转换成从公元1970年1月1日0时0分0 秒算起至今的UTC时间所经过的秒数。 返回值 返回经过的秒数。 /* 用time()取得时间（秒数），利用localtime()转换成struct tm 再利用mktine（）将struct tm转换成原来的秒数*/#include time():974943297time()-&gt;localtime()-&gt;mktime():974943297 settimeofday（设置目前时间） 相关函数 time，ctime，ftime，gettimeofday 表头文件 #include 定义函数 int settimeofday ( const struct timeval *tv,const struct timezone *tz); 函数说明 settimeofday()会把目前时间设成由tv所指的结构信息，当地时区信息则设成tz所指的结构。详细的说明请参考gettimeofday()。注意，只有root权限才能使用此函数修改时间。 返回值 成功则返回0，失败返回－1，错误代码存于errno。 错误代码 EPERM 并非由root权限调用settimeofday（），权限不够。EINVAL 时区或某个数据是不正确的，无法正确设置时间。 time（取得目前的时间） 相关函数 ctime，ftime，gettimeofday 表头文件 #include 定义函数 time_t time(time_t *t); 函数说明 此函数会返回从公元1970年1月1日的UTC时间从0时0分0秒算起到现在所经过的秒数。如果t 并非空指针的话，此函数也会将返回值存到t指针所指的内存。 返回值 成功则返回秒数，失败则返回((time_t)-1)值，错误原因存于errno中。","categories":[],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"}],"author":"蛋蛋_rmvb Csdn认证博客专家 Csdn认证企业博客 码龄14年 暂无认证"}],"categories":[{"name":"game","slug":"game","permalink":"http://vball.fun/categories/game/"},{"name":"gnu","slug":"gnu","permalink":"http://vball.fun/categories/gnu/"},{"name":"tools","slug":"tools","permalink":"http://vball.fun/categories/tools/"},{"name":"hexo","slug":"tools/hexo","permalink":"http://vball.fun/categories/tools/hexo/"}],"tags":[{"name":"Ffmpeg","slug":"Ffmpeg","permalink":"http://vball.fun/tags/Ffmpeg/"},{"name":"Microsoft","slug":"Microsoft","permalink":"http://vball.fun/tags/Microsoft/"},{"name":"Sharepoint","slug":"Sharepoint","permalink":"http://vball.fun/tags/Sharepoint/"},{"name":"Vscode","slug":"Vscode","permalink":"http://vball.fun/tags/Vscode/"},{"name":"Plugin","slug":"Plugin","permalink":"http://vball.fun/tags/Plugin/"},{"name":"Grammar","slug":"Grammar","permalink":"http://vball.fun/tags/Grammar/"},{"name":"Github actions","slug":"Github-actions","permalink":"http://vball.fun/tags/Github-actions/"},{"name":"Yaml","slug":"Yaml","permalink":"http://vball.fun/tags/Yaml/"},{"name":"Automatic","slug":"Automatic","permalink":"http://vball.fun/tags/Automatic/"},{"name":"Github","slug":"Github","permalink":"http://vball.fun/tags/Github/"},{"name":"Actions","slug":"Actions","permalink":"http://vball.fun/tags/Actions/"},{"name":"Python","slug":"Python","permalink":"http://vball.fun/tags/Python/"},{"name":"pynput","slug":"pynput","permalink":"http://vball.fun/tags/pynput/"},{"name":"7yuv","slug":"7yuv","permalink":"http://vball.fun/tags/7yuv/"},{"name":"Snap","slug":"Snap","permalink":"http://vball.fun/tags/Snap/"},{"name":"Qt4","slug":"Qt4","permalink":"http://vball.fun/tags/Qt4/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://vball.fun/tags/Ubuntu/"},{"name":"Opencv","slug":"Opencv","permalink":"http://vball.fun/tags/Opencv/"},{"name":"Freetype","slug":"Freetype","permalink":"http://vball.fun/tags/Freetype/"},{"name":"Font","slug":"Font","permalink":"http://vball.fun/tags/Font/"},{"name":"FFMPEG","slug":"FFMPEG","permalink":"http://vball.fun/tags/FFMPEG/"},{"name":"H264","slug":"H264","permalink":"http://vball.fun/tags/H264/"},{"name":"YUV","slug":"YUV","permalink":"http://vball.fun/tags/YUV/"},{"name":"toneoz","slug":"toneoz","permalink":"http://vball.fun/tags/toneoz/"},{"name":"pinyin","slug":"pinyin","permalink":"http://vball.fun/tags/pinyin/"},{"name":"1984","slug":"1984","permalink":"http://vball.fun/tags/1984/"},{"name":"Shit","slug":"Shit","permalink":"http://vball.fun/tags/Shit/"},{"name":"CSDN","slug":"CSDN","permalink":"http://vball.fun/tags/CSDN/"},{"name":"Linux","slug":"Linux","permalink":"http://vball.fun/tags/Linux/"},{"name":"Samba","slug":"Samba","permalink":"http://vball.fun/tags/Samba/"},{"name":"game","slug":"game","permalink":"http://vball.fun/tags/game/"},{"name":"daily","slug":"daily","permalink":"http://vball.fun/tags/daily/"},{"name":"gdb","slug":"gdb","permalink":"http://vball.fun/tags/gdb/"},{"name":"linux","slug":"linux","permalink":"http://vball.fun/tags/linux/"},{"name":"stl","slug":"stl","permalink":"http://vball.fun/tags/stl/"},{"name":"gnu","slug":"gnu","permalink":"http://vball.fun/tags/gnu/"},{"name":"mermaid","slug":"mermaid","permalink":"http://vball.fun/tags/mermaid/"},{"name":"hexo","slug":"hexo","permalink":"http://vball.fun/tags/hexo/"}]}