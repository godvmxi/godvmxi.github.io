I"≈*<p>We have seen‚Ä¶</p>

<ul>
  <li><em>propositions</em>: factual claims
    <ul>
      <li>equality propositions (<code class="language-plaintext highlighter-rouge">e1 = e2</code>)</li>
      <li>implications (<code class="language-plaintext highlighter-rouge">P ‚Üí Q</code>)</li>
      <li>quantified propositions (<code class="language-plaintext highlighter-rouge">‚àÄ x, P</code>)</li>
    </ul>
  </li>
  <li><em>proofs</em>: ways of presenting <strong>evidence</strong> for the truth of a proposition</li>
</ul>

<h2 id="prop-type"><code class="language-plaintext highlighter-rouge">Prop</code> type</h2>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Check</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w">  </span><span class="c">(* ===&gt; Prop. A provable prop *)</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="o">.</span><span class="w">  </span><span class="c">(* ===&gt; Prop. A unprovable prop *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Prop</code> is <em>first-class entity</em> we can</p>
<ul>
  <li>name it</li>
  <li><em>parametrized</em>!</li>
</ul>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">is_three</span><span class="w"> </span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w">

</span><span class="k">Check</span><span class="w"> </span><span class="no">is_three</span><span class="pi">.</span><span class="w"> </span><span class="c">(* ===&gt; nat -&gt; Prop *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="properties">Properties</h3>

<blockquote>
  <p>In Coq, <em>functions that return propositions</em> are said to define <em>properties</em> of their arguments.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">injective</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="p">‚àÄ</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="pi">.</span><span class="w">
</span><span class="k">Lemma</span><span class="w"> </span><span class="no">succ_inj</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">injective</span><span class="w"> </span><span class="no">S</span><span class="pi">.</span><span class="w"> </span><span class="c">(* can be read off as "injectivity is a property of S" *)</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> 
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">injection</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>The equality operator <code class="language-plaintext highlighter-rouge">=</code> is also a function that returns a <code class="language-plaintext highlighter-rouge">Prop</code>. (property: <em>equality</em>)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">Check</span><span class="w"> </span><span class="o">@</span><span class="no">eq</span><span class="pi">.</span><span class="w"> </span><span class="c">(* ===&gt; forall A : Type, A -&gt; A -&gt; Prop *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Theroems are types, and proofs are existentials.</p>

<h2 id="slide-qa---1">Slide Q&amp;A - 1.</h2>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Prop</code></li>
  <li><code class="language-plaintext highlighter-rouge">Prop</code></li>
  <li><code class="language-plaintext highlighter-rouge">Prop</code></li>
  <li>Not typeable</li>
  <li><code class="language-plaintext highlighter-rouge">nat -&gt; nat</code></li>
  <li><code class="language-plaintext highlighter-rouge">nat -&gt; Prop</code></li>
  <li>(3)</li>
</ol>

<p>think that Big Lambda (the type abstraction) works at type level, accepts type var, substitute and reture a type.
<code class="language-plaintext highlighter-rouge">forall</code> in Coq is same (the concrete syntax) and only typecheck with <code class="language-plaintext highlighter-rouge">Type</code> or its subtype <code class="language-plaintext highlighter-rouge">Set</code> &amp; <code class="language-plaintext highlighter-rouge">Prop</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Check</span><span class="w"> </span><span class="o">(</span><span class="p">‚àÄ</span><span class="no">n</span><span class="p">:</span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">S</span><span class="w"> </span><span class="o">(</span><span class="no">pred</span><span class="w"> </span><span class="no">n</span><span class="o">)).</span><span class="w">  </span><span class="c">(* not typeable *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">foo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="kr">forall</span><span class="w"> </span><span class="no">n</span><span class="p">:</span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="w"> </span><span class="c">(* foo: nat -&gt; bool *)</span><span class="w">
  </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="logical-connectives">Logical Connectives</h2>

<blockquote>
  <p>noticed that connectives symbols are ‚Äúunicodize‚Äù in book and spacemacs.</p>
</blockquote>

<h3 id="conjuction-logical-and">Conjuction (logical and)</h3>

<p><code class="language-plaintext highlighter-rouge">and</code> is just binary <code class="language-plaintext highlighter-rouge">Prop -&gt; Prop -&gt; Prop</code> and associative.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Print</span><span class="w"> </span><span class="s2">"/\".
Inductive and (A B : Prop) : Prop :=  conj : A -&gt; B -&gt; A /\ B
Check and. (* ===&gt; and : Prop -&gt; Prop -&gt; Prop *)
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="and-introduction">and introduction</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">and_intro</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="no">B</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="no">HA</span><span class="w"> </span><span class="no">HB</span><span class="pi">.</span><span class="w"> </span><span class="kp">split</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">HA</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">HB</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>
<blockquote>
  <p>To prove a conjunction,</p>
  <ul>
    <li>use the <code class="language-plaintext highlighter-rouge">split</code> tactic. It will generate two subgoals,</li>
    <li>or use <code class="language-plaintext highlighter-rouge">apply and_intro.</code>, which match the conclusion and give its two premises as your subgoals.</li>
  </ul>
</blockquote>

<h4 id="and-elimination">and elimination</h4>

<p>if we already have a proof of <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">destruct</code> can give us both.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">and_example2'</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="p">‚àÄ</span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">‚àß</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">[</span><span class="no">Hn</span><span class="w"> </span><span class="no">Hm</span><span class="o">].</span><span class="w"> </span><span class="c">(* = intro H. destruct H. *)</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hn</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hm</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">  </span><span class="c">(* you could use only one *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Instead of packing into conjunction <code class="language-plaintext highlighter-rouge">‚àÄn m : nat, n = 0 ‚àß m = 0 ‚Üí n + m = 0.</code>
why not two separate premises?      <code class="language-plaintext highlighter-rouge">‚àÄn m : nat, n = 0 -&gt; m = 0 ‚Üí n + m = 0.</code> 
Both are fine in this case but conjunction are useful as intermediate step etc.</p>

<blockquote>
  <p>Coq Intensive Q: why <code class="language-plaintext highlighter-rouge">destruct</code> can work on <code class="language-plaintext highlighter-rouge">and</code>? is <code class="language-plaintext highlighter-rouge">and</code> inductively defined?
A: Yes.</p>
</blockquote>

<h3 id="disjunction-locial-or">Disjunction (locial or)</h3>

<h4 id="or-elimination">or elimination</h4>

<p>We need do case analysis (either <code class="language-plaintext highlighter-rouge">P</code> or <code class="language-plaintext highlighter-rouge">Q</code> should be able to prove the theroem separately!)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">or_example</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">\/</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="c">(* This pattern implicitly does case analysis on [n = 0 \/ m = 0] *)</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">[</span><span class="no">Hn</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">Hm</span><span class="o">].</span><span class="w"> </span><span class="c">(* = intro H. destruct H. *)</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* Here, [n = 0] *)</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hn</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* Here, [m = 0] *)</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hm</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">mult_n_O</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="or-introduction">or introduction</h4>

<p>When trying to establish (intro into conclusion) an <code class="language-plaintext highlighter-rouge">or</code>, using <code class="language-plaintext highlighter-rouge">left</code> or <code class="language-plaintext highlighter-rouge">right</code> to pick one side to prove is sufficient.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">or_intro</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">\/</span><span class="w"> </span><span class="no">B</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="no">HA</span><span class="pi">.</span><span class="w">
  </span><span class="no">left</span><span class="pi">.</span><span class="w">  </span><span class="c">(* tactics *)</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">HA</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="falsehood-and-negation">Falsehood and negation</h3>

<h4 id="false">False?</h4>

<p>Recall the <em>princple of explosion</em>: it asserts that, if we assume a <em>contradiction</em>, then any other proposition can be derived.
we could define <code class="language-plaintext highlighter-rouge">¬¨ P</code> (‚Äúnot P‚Äù) as <code class="language-plaintext highlighter-rouge">‚àÄ Q, P ‚Üí Q.</code>.</p>

<blockquote>
  <p>Coq actually makes a slightly different (but equivalent) choice, defining <code class="language-plaintext highlighter-rouge">¬¨ P as P ‚Üí False</code>, where <code class="language-plaintext highlighter-rouge">False</code> is a specific <em>contradictory proposition</em> defined in the standard library.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="p">:</span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">False</span><span class="pi">.</span><span class="w">
</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"¬¨x"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">not</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">type_scope</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Prove the <em>princple of explosion</em>:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">ex_falso_quodlibet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="p">:</span><span class="kr">Prop</span><span class="o">),</span><span class="w">
  </span><span class="no">False</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">P</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">contra</span><span class="pi">.</span><span class="w">
  </span><span class="kp">destruct</span><span class="w"> </span><span class="no">contra</span><span class="pi">.</span><span class="w">  </span><span class="k">Qed</span><span class="pi">.</span><span class="w">  </span><span class="c">(* 0 cases to prove since ‚ä• is not provable. [inversion] also works *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="inequality">Inequality</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">Notation</span><span class="w"> </span><span class="s2">"x &lt;&gt; y"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(~(</span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="o">)).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Same as SML and OCaml (for structural equality, OCaml uses <code class="language-plaintext highlighter-rouge">!=</code> for physical equality.)</p>

<h4 id="proving-of-negation-or-how-to-prove-p">Proving of negation (or how to prove <code class="language-plaintext highlighter-rouge">¬¨P</code>)</h4>

<p>thinking about as <code class="language-plaintext highlighter-rouge">unfold not</code>, i.e. <code class="language-plaintext highlighter-rouge">P -&gt; False</code>.
so you have an assumptions <code class="language-plaintext highlighter-rouge">P</code> that could be <code class="language-plaintext highlighter-rouge">intros HP.</code> and the residual goal would be simply <code class="language-plaintext highlighter-rouge">False</code>. 
which is usually proved by some kind of contradiction in hypotheses with tactics <code class="language-plaintext highlighter-rouge">discriminate.</code> or <code class="language-plaintext highlighter-rouge">contradiction.</code></p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">contradiction_implies_anything</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w">
  </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="nv">~P</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">Q</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="o">[</span><span class="no">HP</span><span class="w"> </span><span class="no">HNA</span><span class="o">].</span><span class="w">                 </span><span class="c">(* we could [contradiction.] to end the proof here`*)</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">HNA</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">HNA</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">HP</span><span class="pi">.</span><span class="w">  </span><span class="c">(* HP : False, HNA : P -&gt; False  ‚ä¢  HP: False  *)</span><span class="w">
  </span><span class="kp">destruct</span><span class="w"> </span><span class="no">HP</span><span class="pi">.</span><span class="w">  </span><span class="k">Qed</span><span class="pi">.</span><span class="w">                   </span><span class="c">(* destruct False.  *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="tactic-exfalso">Tactic <code class="language-plaintext highlighter-rouge">exfalso.</code></h4>

<blockquote>
  <p>If you are trying to prove a goal that is nonsensical (e.g., the goal state is <code class="language-plaintext highlighter-rouge">false = true</code>), apply <code class="language-plaintext highlighter-rouge">ex_falso_quodlibet</code> to change the goal to <code class="language-plaintext highlighter-rouge">False</code>. This makes it easier to use assumptions of the form <code class="language-plaintext highlighter-rouge">¬¨P</code> that may be available in the context ‚Äî in particular, assumptions of the form <code class="language-plaintext highlighter-rouge">x‚â†y</code>.</p>
</blockquote>

<blockquote>
  <p>Since reasoning with <code class="language-plaintext highlighter-rouge">ex_falso_quodlibet</code> is quite common, Coq provides a built-in tactic, <code class="language-plaintext highlighter-rouge">exfalso</code>, for applying it.</p>
</blockquote>

<h2 id="slide-qa---2">Slide Q&amp;A - 2</h2>

<blockquote>
  <p>?<code class="language-plaintext highlighter-rouge">unfold</code> is implicit</p>
</blockquote>

<ol>
  <li>only <code class="language-plaintext highlighter-rouge">destruct</code> (if we consider <code class="language-plaintext highlighter-rouge">intros</code> destruct is also <code class="language-plaintext highlighter-rouge">destruct</code>.), ?<code class="language-plaintext highlighter-rouge">unfold</code></li>
  <li>none (?<code class="language-plaintext highlighter-rouge">unfold</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">left.</code></li>
  <li><code class="language-plaintext highlighter-rouge">destruct</code>, <code class="language-plaintext highlighter-rouge">unfold</code>, <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code></li>
  <li><code class="language-plaintext highlighter-rouge">discrinminate</code> (or <code class="language-plaintext highlighter-rouge">inversion</code>)</li>
</ol>

<h3 id="truth">Truth</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">True_is_true</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">True</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">I</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">I : True</code> is a predefined Prop‚Ä¶</p>

<h3 id="logical-equivalence">Logical Equivalence</h3>

<p><em>if and only if</em> is just the conjunction of two implications. (so we need <code class="language-plaintext highlighter-rouge">split</code> to get 2 subgoals)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">iff</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">Q</span><span class="o">)</span><span class="w"> </span><span class="p">‚àß</span><span class="w"> </span><span class="o">(</span><span class="no">Q</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">P</span><span class="o">).</span><span class="w">
</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"P ‚Üî Q"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">iff</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="o">)</span><span class="w">
                    </span><span class="o">(</span><span class="kp">at</span><span class="w"> </span><span class="no">level</span><span class="w"> </span><span class="mi">95</span><span class="o">,</span><span class="w"> </span><span class="no">no</span><span class="w"> </span><span class="no">associativity</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">type_scope</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">rewrite</code> and <code class="language-plaintext highlighter-rouge">reflexivity</code> can be used with iff statements, not just equalities.</p>
</blockquote>

<h3 id="existential-quantification">Existential Quantification</h3>

<p>To prove a statement of the form <code class="language-plaintext highlighter-rouge">‚àÉx, P</code>, we must show that <code class="language-plaintext highlighter-rouge">P</code> holds for some specific choice of value for <code class="language-plaintext highlighter-rouge">x</code>, 
known as the <strong>witness</strong> of the existential.</p>

<p>So we explicitly tell Coq which witness <code class="language-plaintext highlighter-rouge">t</code> we have in mind by invoking <code class="language-plaintext highlighter-rouge">exists t</code>.
then all occurences of that ‚Äútype variable‚Äù would be replaced.</p>

<h4 id="intro">Intro</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">four_is_even</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kp">exists</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">n</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="elim">Elim</h4>

<p>Below is an interesting question‚Ä¶by intros and destruct we can have equation <code class="language-plaintext highlighter-rouge">n = 4 + m</code> in hypotheses.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">exists_example_2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">n</span><span class="o">,</span><span class="w">
  </span><span class="o">(</span><span class="kp">exists</span><span class="w"> </span><span class="no">m</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">m</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="o">(</span><span class="kp">exists</span><span class="w"> </span><span class="no">o</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">o</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">[</span><span class="no">m</span><span class="w"> </span><span class="no">Hm</span><span class="o">].</span><span class="w"> </span><span class="c">(* note implicit [destruct] here *)</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">m</span><span class="o">).</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">Hm</span><span class="pi">.</span><span class="w">  </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="programming-with-propositions">Programming with Propositions</h2>

<p>Considering writing a common recursive <code class="language-plaintext highlighter-rouge">is_in</code> for polymorphic lists. 
(Though we dont have a polymorphic <code class="language-plaintext highlighter-rouge">=?</code> (<code class="language-plaintext highlighter-rouge">eqb</code>) defined yet)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Fixpoint</span><span class="w"> </span><span class="no">is_in</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="no">l'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="no">x'</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">is_in</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">l'</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Similarly, we can write this function but with disjunction and return a <code class="language-plaintext highlighter-rouge">Prop</code>!
<em>so we can write function to generate/create statements/propositions!</em> (thx for the idea Prop is first-class)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Fixpoint</span><span class="w"> </span><span class="no">In</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">False</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="no">l'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">‚à®</span><span class="w"> </span><span class="no">In</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">l'</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>The whole thing I understood as a <em>type operator</em> (function in type level) and it‚Äôs <em>recursive</em>!</p>

<p>Coq dare to do that becuz its <em>total</em>, which is guarded by its <em>termination checker</em>.
un-total PL, if having this, would make its type system <em>Turing Complete</em> (thus having <em>Halting Problem</em>).
(Recursive Type like ADT/GADT in ML/Haskell is a limited form of recursion allowing no arbitray recursion.)</p>

<h3 id="in_map">In_map</h3>

<p>I took this one since it‚Äôs like a formal version of <em>Property-based Tests</em>!.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">In_map</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">),</span><span class="w">
    </span><span class="no">In</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="no">In</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">map</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">l</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">
  </span><span class="kp">induction</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="o">[|</span><span class="no">x'</span><span class="w"> </span><span class="no">l'</span><span class="w"> </span><span class="no">IHl'</span><span class="o">].</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* l = nil, contradiction *)</span><span class="w">
    </span><span class="kp">simpl</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="o">[].</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* l = x' :: l' *)</span><span class="w">
    </span><span class="kp">simpl</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="o">[</span><span class="no">H</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">H</span><span class="o">].</span><span class="w">           </span><span class="c">(* evaluating [In] gives us 2 cases:  *)</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="no">left</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">  </span><span class="c">(* in head of l *)</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="no">right</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">IHl'</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">    </span><span class="c">(* in tail of l*)</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Q &amp; A:</p>
  <ol>
    <li><code class="language-plaintext highlighter-rouge">eq</code> is just another inductively defined and doesn‚Äôt have any computational content. (satisfication)</li>
    <li>Why use <code class="language-plaintext highlighter-rouge">Prop</code> instead of <code class="language-plaintext highlighter-rouge">bool</code>? See <em>reflection</em> below.</li>
  </ol>
</blockquote>

<h3 id="drawbacks">Drawbacks</h3>

<blockquote>
  <p>In particular, it is subject to Coq‚Äôs usual restrictions regarding the definition of recursive functions, 
e.g., the requirement that they be ‚Äúobviously terminating.‚Äù</p>
</blockquote>

<blockquote>
  <p>In the next chapter, we will see how to define propositions <em>inductively</em>, 
a different technique with its own set of strengths and limitations.</p>
</blockquote>

<h2 id="applying-theorems-to-arguments">Applying Theorems to Arguments.</h2>

<h3 id="check-some_theorem-print-the-statement"><code class="language-plaintext highlighter-rouge">Check some_theorem</code> print the statement!</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Check</span><span class="w"> </span><span class="no">plus_comm</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ===&gt; forall n m : nat, n + m = m + n *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Coq prints the <em>statement</em> of the <code class="language-plaintext highlighter-rouge">plus_comm</code> theorem in the same way that it prints the <em>type</em> of any term that we ask it to Check. Why?</p>
</blockquote>

<p>Hmm‚Ä¶I just noticed that!!
But I should notice because <strong>Propositions are Types! (and terms are proof)</strong></p>

<h3 id="proof-object">Proof Object</h3>

<blockquote>
  <p><em>proofs</em> as first-class objects.</p>
</blockquote>

<p>After <code class="language-plaintext highlighter-rouge">Qed.</code>, Coq defined they as <em>Proof Object</em> and the <em>type of this obj</em> is the statement of the theorem.</p>

<blockquote>
  <p>Provable: some type is inhabited by some thing (having terms).</p>
</blockquote>

<p>So I guess when we apply theorems, Coq implicitly use the type of the Proof Object. (it‚Äôs already type abstraction)
‚Ä¶we will get to there later at ProofObject chapter.</p>

<h3 id="apply-theorem-as-function">Apply theorem as function</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">rewrite</code> select variables greedily by default</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">plus_comm3_take3</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="p">‚àÄ</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="o">,</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="no">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">z</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="pi">.</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">plus_comm</span><span class="pi">.</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">(</span><span class="no">plus_comm</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="o">).</span><span class="w">     </span><span class="c">(* we can explicitly provide type var! *)</span><span class="w">
  </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">x y z</code> were some type var and <em>instantiated to values</em> by <code class="language-plaintext highlighter-rouge">intros</code>, e.g. <code class="language-plaintext highlighter-rouge">x, y, z:nat</code> 
but we can explicilty pass in to <code class="language-plaintext highlighter-rouge">plus_comm</code>, which is a forall type abstraction! (<code class="language-plaintext highlighter-rouge">Œî n m. (eq (n + m) (m + n))</code>)</p>

<blockquote>
  <p>there must be something there in Proof Object so we can apply <em>values</em> to a <em>type-level function</em></p>
</blockquote>

<h2 id="coq-vs-set-theory">Coq vs. Set Theory</h2>

<p>Coq‚Äôs logical core, <em>the Calculus of Inductive Constructions</em>, is a <em>metalanguage for math</em>, but differs from other foundations of math e.g. ZFC Set Theory</p>

<h3 id="functional-extensionality">Functional Extensionality</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">(</span><span class="p">‚àÄ</span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w">

</span><span class="p">‚àÉ</span><span class="no">f</span><span class="w"> </span><span class="no">g</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="p">‚àÄ</span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">‚Üí</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w">

</span><span class="p">‚àÉ</span><span class="no">f</span><span class="w"> </span><span class="no">g</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="p">‚àÄ</span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">‚àß</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="no">g</span><span class="w">    </span><span class="c">(* negation, consistent but not interesting... *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>In common math practice, two functions <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">g</code> are considered equal if they produce the same outputs.
This is known as the principle of <em>functional extensionality</em>.</p>
</blockquote>

<blockquote>
  <p>Informally speaking, an ‚Äúextensional property‚Äù is one that pertains to an object‚Äôs observable behavior.
<a href="https://en.wikipedia.org/wiki/Extensionality">https://en.wikipedia.org/wiki/Extensionality</a>
<a href="https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions">https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions</a>?</p>
</blockquote>

<p>This is not built-in Coq, but we can add them as Axioms. 
Why not add everything?</p>
<blockquote>
  <ol>
    <li>One or multiple axioms combined might render <em>inconsistency</em>.</li>
    <li>Code extraction might be problematic</li>
  </ol>
</blockquote>

<blockquote>
  <p>Fortunately, it is known that adding functional extensionality, in particular, is consistent.
<a href="https://en.wikipedia.org/wiki/Consistency">consistency</a>:
   a consistent theory is one that does not contain a contradiction.</p>
</blockquote>

<h3 id="adding-axioms">Adding Axioms</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="no">Axiom</span><span class="w"> </span><span class="no">functional_extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="w"> </span><span class="no">Y</span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w">
                                    </span><span class="o">{</span><span class="no">f</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">Y</span><span class="o">},</span><span class="w">
  </span><span class="o">(</span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="p">:</span><span class="no">X</span><span class="o">),</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>It‚Äôs like <code class="language-plaintext highlighter-rouge">Admitted.</code> but alerts we‚Äôre not going to fill in later.</p>

<h3 id="exercise---proving-reverse-with-app-and-with-cons-are-fn-exensionally-equivalent">Exercise - Proving Reverse with <code class="language-plaintext highlighter-rouge">app</code> and with <code class="language-plaintext highlighter-rouge">cons</code> are fn-exensionally equivalent.</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">Fixpoint</span><span class="w"> </span><span class="no">rev_append</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">l2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="no">l1'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">rev_append</span><span class="w"> </span><span class="no">l1'</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="no">l2</span><span class="o">)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">tr_rev</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="no">rev_append</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="o">[].</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>BTW, this version is <code class="language-plaintext highlighter-rouge">tail recursive</code> becuz the recursive call is the last operation needs to performed.
(In <code class="language-plaintext highlighter-rouge">rev</code> i.e. <code class="language-plaintext highlighter-rouge">rev t ++ [h]</code>, recursive call is a argument of function <code class="language-plaintext highlighter-rouge">++</code> and we are CBV.)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">tr_rev_correct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">X</span><span class="o">,</span><span class="w"> </span><span class="o">@</span><span class="no">tr_rev</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">@</span><span class="no">rev</span><span class="w"> </span><span class="no">X</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="propositions-and-booleans">Propositions and Booleans</h3>

<blockquote>
  <p>We‚Äôve seen two different ways of expressing logical claims in Coq:</p>
  <ol>
    <li>with booleans     (of type <code class="language-plaintext highlighter-rouge">bool</code>),  ; computational way</li>
    <li>with propositions (of type <code class="language-plaintext highlighter-rouge">Prop</code>).  ; logical way</li>
  </ol>
</blockquote>

<p>There‚Äôre two ways to define 42 is even:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Example</span><span class="w"> </span><span class="no">even_42_bool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">evenb</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_42_prop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÉ</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>We wanna show there are <em>interchangable</em>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">even_bool_prop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÄ</span><span class="no">n</span><span class="o">,</span><span class="w">
  </span><span class="no">evenb</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">‚Üî</span><span class="w"> </span><span class="p">‚àÉ</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>In view of this theorem, we say that the 
boolean computation <code class="language-plaintext highlighter-rouge">evenb n</code> <em>reflects</em> the truth of the proposition <code class="language-plaintext highlighter-rouge">‚àÉ k, n = double k</code>.</p>
</blockquote>

<p>We can futhur general this to any equations representing as <code class="language-plaintext highlighter-rouge">bool</code> or <code class="language-plaintext highlighter-rouge">Prop</code>:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">eqb_eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÄ</span><span class="no">n1</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w">
  </span><span class="no">n1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">‚Üî</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">n2</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="notes-on-computability">Notes on Computability.</h4>

<blockquote>
  <p>However, even they are equivalent from a purely logical perspective, 
they may not be equivalent <code class="language-plaintext highlighter-rouge">operationally</code>.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="no">Fail</span><span class="w"> </span><span class="k">Definition</span><span class="w"> </span><span class="no">is_even_prime</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">if</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kr">else</span><span class="w"> </span><span class="no">false</span><span class="pi">.</span><span class="w">

</span><span class="no">Error</span><span class="p">:</span><span class="w"> </span><span class="no">The</span><span class="w"> </span><span class="no">term</span><span class="w"> </span><span class="s2">"n = 2"</span><span class="w"> </span><span class="no">has</span><span class="w"> </span><span class="no">type</span><span class="w"> </span><span class="s2">"Prop"</span><span class="w"> </span><span class="no">which</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">(</span><span class="no">co</span><span class="o">-)</span><span class="no">inductive</span><span class="w"> </span><span class="no">type</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">=</code>, or <code class="language-plaintext highlighter-rouge">eq</code>, as any function in Coq, need to be computable and total. And we have no way to tell <em>whether any given proposition is true or false</em>. (‚Ä¶We can only naturally deduce things are inductively defined)</p>

<blockquote>
  <p>As a consequence, Prop in Coq does not have a universal case analysis operation telling whether any given proposition is true or false, since such an operation would allow us to write non-computable functions.</p>
</blockquote>

<blockquote>
  <p>Although general non-computable properties cannot be phrased as boolean computations, it is worth noting that even many computable properties are easier to express using Prop than bool, since recursive function definitions are subject to significant restrictions in Coq.</p>
</blockquote>

<p>E.g. Verifying Regular Expr in next chapter.</p>
<blockquote>
  <p>Doing the same with <code class="language-plaintext highlighter-rouge">bool</code> would amount to writing a <em>full regular expression matcher</em> (so we can execute the regex).</p>
</blockquote>

<h4 id="proof-by-reflection">Proof by Reflection!</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="c">(* Logically *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_1000</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÉ</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="p">‚àÉ</span><span class="mi">500</span><span class="o">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">

</span><span class="c">(* Computationally *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_1000'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">evenb</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">

</span><span class="c">(* Prove logical version by reflecting in computational version *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_1000''</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">‚àÉ</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">even_bool_prop</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>As an extreme example, the Coq proof of the famous <em>4-color theorem</em> uses reflection to reduce the analysis of hundreds of different cases to a boolean computation.</p>
</blockquote>

<h3 id="classical-vs-constructive-logic">Classical vs. Constructive Logic</h3>

<p>‚Ä¶</p>

<h2 id="future-schedule">Future Schedule</h2>

<blockquote>
  <p>Proof got messier!
Lean on your past PLT experience</p>
</blockquote>

<p>As discussion leader</p>

<ul>
  <li>having many materials now</li>
  <li>selected troublesome and interesting ones</li>
</ul>

:ET